<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/argparse/lib/argument_parser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/argparse/lib/argument_parser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">61.68</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1161</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">114.92</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.07</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * class ArgumentParser
 *
 * Object for parsing command line strings into js objects.
 *
 * Inherited from [[ActionContainer]]
 **/
&#039;use strict&#039;;

var util    = require(&#039;util&#039;);
var format  = require(&#039;util&#039;).format;
var Path    = require(&#039;path&#039;);

var _ = require(&#039;underscore&#039;);
_.str = require(&#039;underscore.string&#039;);

// Constants
var $$ = require(&#039;./const&#039;);

var ActionContainer = require(&#039;./action_container&#039;);

// Errors
var argumentErrorHelper = require(&#039;./argument/error&#039;);

var HelpFormatter = require(&#039;./help/formatter&#039;);

var Namespace = require(&#039;./namespace&#039;);


/**
 * new ArgumentParser(options)
 *
 * Create a new ArgumentParser object.
 *
 * ##### Options:
 * - `prog`  The name of the program (default: Path.basename(process.argv[1]))
 * - `usage`  A usage message (default: auto-generated from arguments)
 * - `description`  A description of what the program does
 * - `epilog`  Text following the argument descriptions
 * - `parents`  Parsers whose arguments should be copied into this one
 * - `formatterClass`  HelpFormatter class for printing help messages
 * - `prefixChars`  Characters that prefix optional arguments
 * - `fromfilePrefixChars` Characters that prefix files containing additional arguments
 * - `argumentDefault`  The default value for all arguments
 * - `addHelp`  Add a -h/-help option
 * - `conflictHandler`  Specifies how to handle conflicting argument names
 * - `debug`  Enable debug mode. Argument errors throw exception in
 *   debug mode and process.exit in normal. Used for development and
 *   testing (default: false)
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#argumentparser-objects
 **/
var ArgumentParser = module.exports = function ArgumentParser(options) {
  var self = this;
  options = options || {};

  options.description = (options.description || null);
  options.argumentDefault = (options.argumentDefault || null);
  options.prefixChars = (options.prefixChars || &#039;-&#039;);
  options.conflictHandler = (options.conflictHandler || &#039;error&#039;);
  ActionContainer.call(this, options);

  options.addHelp = (options.addHelp === undefined || !!options.addHelp);
  options.parents = (options.parents || []);
  // default program name
  options.prog = (options.prog || Path.basename(process.argv[1]));
  this.prog = options.prog;
  this.usage = options.usage;
  this.epilog = options.epilog;
  this.version = options.version;

  this.debug = (options.debug === true);

  this.formatterClass = (options.formatterClass || HelpFormatter);
  this.fromfilePrefixChars = options.fromfilePrefixChars || null;
  this._positionals = this.addArgumentGroup({title: &#039;Positional arguments&#039;});
  this._optionals = this.addArgumentGroup({title: &#039;Optional arguments&#039;});
  this._subparsers = null;

  // register types
  var FUNCTION_IDENTITY = function (o) {
    return o;
  };
  this.register(&#039;type&#039;, &#039;auto&#039;, FUNCTION_IDENTITY);
  this.register(&#039;type&#039;, null, FUNCTION_IDENTITY);
  this.register(&#039;type&#039;, &#039;int&#039;, function (x) {
    var result = parseInt(x, 10);
    if (isNaN(result)) {
      throw new Error(x + &#039; is not a valid integer.&#039;);
    }
    return result;
  });
  this.register(&#039;type&#039;, &#039;float&#039;, function (x) {
    var result = parseFloat(x);
    if (isNaN(result)) {
      throw new Error(x + &#039; is not a valid float.&#039;);
    }
    return result;
  });
  this.register(&#039;type&#039;, &#039;string&#039;, function (x) {
    return &#039;&#039; + x;
  });

  // add help and version arguments if necessary
  var defaultPrefix = (this.prefixChars.indexOf(&#039;-&#039;) &gt; -1) ? &#039;-&#039; : this.prefixChars[0];
  if (options.addHelp) {
    this.addArgument(
      [defaultPrefix + &#039;h&#039;, defaultPrefix + defaultPrefix + &#039;help&#039;],
      {
        action: &#039;help&#039;,
        defaultValue: $$.SUPPRESS,
        help: &#039;Show this help message and exit.&#039;
      }
    );
  }
  if (this.version !== undefined) {
    this.addArgument(
      [defaultPrefix + &#039;v&#039;, defaultPrefix + defaultPrefix + &#039;version&#039;],
      {
        action: &#039;version&#039;,
        version: this.version,
        defaultValue: $$.SUPPRESS,
        help: &quot;Show program&#039;s version number and exit.&quot;
      }
    );
  }

  // add parent arguments and defaults
  options.parents.forEach(function (parent) {
    self._addContainerActions(parent);
    if (parent._defaults !== undefined) {
      for (var defaultKey in parent._defaults) {
        if (parent._defaults.hasOwnProperty(defaultKey)) {
          self._defaults[defaultKey] = parent._defaults[defaultKey];
        }
      }
    }
  });

};
util.inherits(ArgumentParser, ActionContainer);

/**
 * ArgumentParser#addSubparsers(options) -&gt; [[ActionSubparsers]]
 * - options (object): hash of options see [[ActionSubparsers.new]]
 *
 * See also [subcommands][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#sub-commands
 **/
ArgumentParser.prototype.addSubparsers = function (options) {
  if (!!this._subparsers) {
    this.error(&#039;Cannot have multiple subparser arguments.&#039;);
  }

  options = options || {};
  options.debug = (this.debug === true);
  options.optionStrings = [];
  options.parserClass = (options.parserClass || ArgumentParser);


  if (!!options.title || !!options.description) {

    this._subparsers = this.addArgumentGroup({
      title: (options.title || &#039;subcommands&#039;),
      description: options.description
    });
    delete options.title;
    delete options.description;

  } else {
    this._subparsers = this._positionals;
  }

  // prog defaults to the usage message of this parser, skipping
  // optional arguments and with no &quot;usage:&quot; prefix
  if (!options.prog) {
    var formatter = this._getFormatter();
    var positionals = this._getPositionalActions();
    var groups = this._mutuallyExclusiveGroups;
    formatter.addUsage(this.usage, positionals, groups, &#039;&#039;);
    options.prog = _.str.strip(formatter.formatHelp());
  }

  // create the parsers action and add it to the positionals list
  var ParsersClass = this._popActionClass(options, &#039;parsers&#039;);
  var action = new ParsersClass(options);
  this._subparsers._addAction(action);

  // return the created parsers action
  return action;
};

ArgumentParser.prototype._addAction = function (action) {
  if (action.isOptional()) {
    this._optionals._addAction(action);
  } else {
    this._positionals._addAction(action);
  }
  return action;
};

ArgumentParser.prototype._getOptionalActions = function () {
  return this._actions.filter(function (action) {
    return action.isOptional();
  });
};

ArgumentParser.prototype._getPositionalActions = function () {
  return this._actions.filter(function (action) {
    return action.isPositional();
  });
};


/**
 * ArgumentParser#parseArgs(args, namespace) -&gt; Namespace|Object
 * - args (array): input elements
 * - namespace (Namespace|Object): result object
 *
 * Parsed args and throws error if some arguments are not recognized
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#the-parse-args-method
 **/
ArgumentParser.prototype.parseArgs = function (args, namespace) {
  var argv;
  var result = this.parseKnownArgs(args, namespace);

  args = result[0];
  argv = result[1];
  if (argv &amp;&amp; argv.length &gt; 0) {
    this.error(
      format(&#039;Unrecognized arguments: %s.&#039;, argv.join(&#039; &#039;))
    );
  }
  return args;
};

/**
 * ArgumentParser#parseKnownArgs(args, namespace) -&gt; array
 * - args (array): input options
 * - namespace (Namespace|Object): result object
 *
 * Parse known arguments and return tuple of result object
 * and unknown args
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#partial-parsing
 **/
ArgumentParser.prototype.parseKnownArgs = function (args, namespace) {
  var self = this;

  // args default to the system args
  args = args || process.argv.slice(2);

  // default Namespace built from parser defaults
  namespace = namespace || new Namespace();

  self._actions.forEach(function (action) {
    if (action.dest !== $$.SUPPRESS) {
      if (!_.has(namespace, action.dest)) {
        if (action.defaultValue !== $$.SUPPRESS) {
          var defaultValue = action.defaultValue;
          if (_.isString(action.defaultValue)) {
            defaultValue = self._getValue(action, defaultValue);
          }
          namespace[action.dest] = defaultValue;
        }
      }
    }
  });

  _.keys(self._defaults).forEach(function (dest) {
    namespace[dest] = self._defaults[dest];
  });

  // parse the arguments and exit if there are any errors
  try {
    var res = this._parseKnownArgs(args, namespace);

    namespace = res[0];
    args = res[1];
    if (_.has(namespace, $$._UNRECOGNIZED_ARGS_ATTR)) {
      args = _.union(args, namespace[$$._UNRECOGNIZED_ARGS_ATTR]);
      delete namespace[$$._UNRECOGNIZED_ARGS_ATTR];
    }
    return [namespace, args];
  } catch (e) {
    this.error(e);
  }
};

ArgumentParser.prototype._parseKnownArgs = function (argStrings, namespace) {
  var self = this;

  var extras = [];

  // replace arg strings that are file references
  if (this.fromfilePrefixChars !== null) {
    argStrings = this._readArgsFromFiles(argStrings);
  }
  // map all mutually exclusive arguments to the other arguments
  // they can&#039;t occur with
  // Python has &#039;conflicts = action_conflicts.setdefault(mutex_action, [])&#039;
  // though I can&#039;t conceive of a way in which an action could be a member
  // of two different mutually exclusive groups.

  function actionHash(action) {
    // some sort of hashable key for this action
    // action itself cannot be a key in actionConflicts
    // I think getName() (join of optionStrings) is unique enough
    return action.getName();
  }

  var conflicts, key;
  var actionConflicts = {};

  this._mutuallyExclusiveGroups.forEach(function (mutexGroup) {
    mutexGroup._groupActions.forEach(function (mutexAction, i, groupActions) {
      key = actionHash(mutexAction);
      if (!_.has(actionConflicts, key)) {
        actionConflicts[key] = [];
      }
      conflicts = actionConflicts[key];
      conflicts.push.apply(conflicts, groupActions.slice(0, i));
      conflicts.push.apply(conflicts, groupActions.slice(i + 1));
    });
  });

  // find all option indices, and determine the arg_string_pattern
  // which has an &#039;O&#039; if there is an option at an index,
  // an &#039;A&#039; if there is an argument, or a &#039;-&#039; if there is a &#039;--&#039;
  var optionStringIndices = {};

  var argStringPatternParts = [];

  argStrings.forEach(function (argString, argStringIndex) {
    if (argString === &#039;--&#039;) {
      argStringPatternParts.push(&#039;-&#039;);
      while (argStringIndex &lt; argStrings.length) {
        argStringPatternParts.push(&#039;A&#039;);
        argStringIndex++;
      }
    }
    // otherwise, add the arg to the arg strings
    // and note the index if it was an option
    else {
      var pattern;
      var optionTuple = self._parseOptional(argString);
      if (!optionTuple) {
        pattern = &#039;A&#039;;
      }
      else {
        optionStringIndices[argStringIndex] = optionTuple;
        pattern = &#039;O&#039;;
      }
      argStringPatternParts.push(pattern);
    }
  });
  var argStringsPattern = argStringPatternParts.join(&#039;&#039;);

  var seenActions = [];
  var seenNonDefaultActions = [];


  function takeAction(action, argumentStrings, optionString) {
    seenActions.push(action);
    var argumentValues = self._getValues(action, argumentStrings);

    // error if this argument is not allowed with other previously
    // seen arguments, assuming that actions that use the default
    // value don&#039;t really count as &quot;present&quot;
    if (argumentValues !== action.defaultValue) {
      seenNonDefaultActions.push(action);
      if (!!actionConflicts[actionHash(action)]) {
        actionConflicts[actionHash(action)].forEach(function (actionConflict) {
          if (seenNonDefaultActions.indexOf(actionConflict) &gt;= 0) {
            throw argumentErrorHelper(
              action,
              format(&#039;Not allowed with argument &quot;%s&quot;.&#039;, actionConflict.getName())
            );
          }
        });
      }
    }

    if (argumentValues !== $$.SUPPRESS) {
      action.call(self, namespace, argumentValues, optionString);
    }
  }

  function consumeOptional(startIndex) {
    // get the optional identified at this index
    var optionTuple = optionStringIndices[startIndex];
    var action = optionTuple[0];
    var optionString = optionTuple[1];
    var explicitArg = optionTuple[2];

    // identify additional optionals in the same arg string
    // (e.g. -xyz is the same as -x -y -z if no args are required)
    var actionTuples = [];

    var args, argCount, start, stop;

    while (true) {
      if (!action) {
        extras.push(argStrings[startIndex]);
        return startIndex + 1;
      }
      if (!!explicitArg) {
        argCount = self._matchArgument(action, &#039;A&#039;);

        // if the action is a single-dash option and takes no
        // arguments, try to parse more single-dash options out
        // of the tail of the option string
        var chars = self.prefixChars;
        if (argCount === 0 &amp;&amp; chars.indexOf(optionString[1]) &lt; 0) {
          actionTuples.push([action, [], optionString]);
          optionString = optionString[0] + explicitArg[0];
          var newExplicitArg = explicitArg.slice(1) || null;
          var optionalsMap = self._optionStringActions;

          if (_.keys(optionalsMap).indexOf(optionString) &gt;= 0) {
            action = optionalsMap[optionString];
            explicitArg = newExplicitArg;
          }
          else {
            var msg = &#039;ignored explicit argument %r&#039;;
            throw argumentErrorHelper(action, msg);
          }
        }
        // if the action expect exactly one argument, we&#039;ve
        // successfully matched the option; exit the loop
        else if (argCount === 1) {
          stop = startIndex + 1;
          args = [explicitArg];
          actionTuples.push([action, args, optionString]);
          break;
        }
        // error if a double-dash option did not use the
        // explicit argument
        else {
          var message = &#039;ignored explicit argument %r&#039;;
          throw argumentErrorHelper(action, _.str.sprintf(message, explicitArg));
        }
      }
      // if there is no explicit argument, try to match the
      // optional&#039;s string arguments with the following strings
      // if successful, exit the loop
      else {

        start = startIndex + 1;
        var selectedPatterns = argStringsPattern.substr(start);

        argCount = self._matchArgument(action, selectedPatterns);
        stop = start + argCount;


        args = argStrings.slice(start, stop);

        actionTuples.push([action, args, optionString]);
        break;
      }

    }

    // add the Optional to the list and return the index at which
    // the Optional&#039;s string args stopped
    if (actionTuples.length &lt; 1) {
      throw new Error(&#039;length should be &gt; 0&#039;);
    }
    for (var i = 0; i &lt; actionTuples.length; i++) {
      takeAction.apply(self, actionTuples[i]);
    }
    return stop;
  }

  // the list of Positionals left to be parsed; this is modified
  // by consume_positionals()
  var positionals = self._getPositionalActions();

  function consumePositionals(startIndex) {
    // match as many Positionals as possible
    var selectedPattern = argStringsPattern.substr(startIndex);
    var argCounts = self._matchArgumentsPartial(positionals, selectedPattern);

    // slice off the appropriate arg strings for each Positional
    // and add the Positional and its args to the list
    _.zip(positionals, argCounts).forEach(function (item) {
        var action = item[0];
        var argCount = item[1];
        if (argCount === undefined) {
          return;
        }
        var args = argStrings.slice(startIndex, startIndex + argCount);

        startIndex += argCount;
        takeAction(action, args);
      });

    // slice off the Positionals that we just parsed and return the
    // index at which the Positionals&#039; string args stopped
    positionals = positionals.slice(argCounts.length);
    return startIndex;
  }

  // consume Positionals and Optionals alternately, until we have
  // passed the last option string
  var startIndex = 0;
  var position;

  var maxOptionStringIndex = -1;

  Object.keys(optionStringIndices).forEach(function (position) {
    maxOptionStringIndex = Math.max(maxOptionStringIndex, parseInt(position, 10));
  });

  var positionalsEndIndex, nextOptionStringIndex;

  while (startIndex &lt;= maxOptionStringIndex) {
    // consume any Positionals preceding the next option
    nextOptionStringIndex = null;
    for (position in optionStringIndices) {
      if (!optionStringIndices.hasOwnProperty(position)) { continue; }

      position = parseInt(position, 10);
      if (position &gt;= startIndex) {
        if (nextOptionStringIndex !== null) {
          nextOptionStringIndex = Math.min(nextOptionStringIndex, position);
        }
        else {
          nextOptionStringIndex = position;
        }
      }
    }

    if (startIndex !== nextOptionStringIndex) {
      positionalsEndIndex = consumePositionals(startIndex);
      // only try to parse the next optional if we didn&#039;t consume
      // the option string during the positionals parsing
      if (positionalsEndIndex &gt; startIndex) {
        startIndex = positionalsEndIndex;
        continue;
      }
      else {
        startIndex = positionalsEndIndex;
      }
    }

    // if we consumed all the positionals we could and we&#039;re not
    // at the index of an option string, there were extra arguments
    if (!optionStringIndices[startIndex]) {
      var strings = argStrings.slice(startIndex, nextOptionStringIndex);
      extras = extras.concat(strings);
      startIndex = nextOptionStringIndex;
    }
    // consume the next optional and any arguments for it
    startIndex = consumeOptional(startIndex);
  }

  // consume any positionals following the last Optional
  var stopIndex = consumePositionals(startIndex);

  // if we didn&#039;t consume all the argument strings, there were extras
  extras = extras.concat(_.rest(argStrings, stopIndex));

  // if we didn&#039;t use all the Positional objects, there were too few
  // arg strings supplied.
  if (positionals.length &gt; 0) {
    self.error(&#039;too few arguments&#039;);
  }

  // make sure all required actions were present
  self._actions.forEach(function (action) {
    if (action.required) {
      if (_.indexOf(seenActions, action) &lt; 0) {
        self.error(format(&#039;Argument &quot;%s&quot; is required&#039;, action.getName()));
      }
    }
  });

  // make sure all required groups have one option present
  var actionUsed = false;
  self._mutuallyExclusiveGroups.forEach(function (group) {
    if (group.required) {
      actionUsed = _.any(group._groupActions, function (action) {
        return _.contains(seenNonDefaultActions, action);
      });

      // if no actions were used, report the error
      if (!actionUsed) {
        var names = [];
        group._groupActions.forEach(function (action) {
          if (action.help !== $$.SUPPRESS) {
            names.push(action.getName());
          }
        });
        names = names.join(&#039; &#039;);
        var msg = &#039;one of the arguments &#039; + names + &#039; is required&#039;;
        self.error(msg);
      }
    }
  });

  // return the updated namespace and the extra arguments
  return [namespace, extras];
};

ArgumentParser.prototype._readArgsFromFiles = function (argStrings) {
  // expand arguments referencing files
  var _this = this;
  var fs = require(&#039;fs&#039;);
  var newArgStrings = [];
  argStrings.forEach(function (argString) {
    if (_this.fromfilePrefixChars.indexOf(argString[0]) &lt; 0) {
      // for regular arguments, just add them back into the list
      newArgStrings.push(argString);
    } else {
      // replace arguments referencing files with the file content
      try {
        var argstrs = [];
        var filename = argString.slice(1);
        var content = fs.readFileSync(filename, &#039;utf8&#039;);
        content = content.trim().split(&#039;\n&#039;);
        content.forEach(function (argLine) {
          _this.convertArgLineToArgs(argLine).forEach(function (arg) {
            argstrs.push(arg);
          });
          argstrs = _this._readArgsFromFiles(argstrs);
        });
        newArgStrings.push.apply(newArgStrings, argstrs);
      } catch (error) {
        return _this.error(error.message);
      }
    }
  });
  return newArgStrings;
};

ArgumentParser.prototype.convertArgLineToArgs = function (argLine) {
  return [argLine];
};

ArgumentParser.prototype._matchArgument = function (action, regexpArgStrings) {

  // match the pattern for this action to the arg strings
  var regexpNargs = new RegExp(&#039;^&#039; + this._getNargsPattern(action));
  var matches = regexpArgStrings.match(regexpNargs);
  var message;

  // throw an exception if we weren&#039;t able to find a match
  if (!matches) {
    switch (action.nargs) {
    case undefined:
    case null:
      message = &#039;Expected one argument.&#039;;
      break;
    case $$.OPTIONAL:
      message = &#039;Expected at most one argument.&#039;;
      break;
    case $$.ONE_OR_MORE:
      message = &#039;Expected at least one argument.&#039;;
      break;
    default:
      message = &#039;Expected %s argument(s)&#039;;
    }

    throw argumentErrorHelper(
      action,
      format(message, action.nargs)
    );
  }
  // return the number of arguments matched
  return matches[1].length;
};

ArgumentParser.prototype._matchArgumentsPartial = function (actions, regexpArgStrings) {
  // progressively shorten the actions list by slicing off the
  // final actions until we find a match
  var self = this;
  var result = [];
  var actionSlice, pattern, matches;
  var i, j;

  var getLength = function (string) {
    return string.length;
  };

  for (i = actions.length; i &gt; 0; i--) {
    pattern = &#039;&#039;;
    actionSlice = actions.slice(0, i);
    for (j = 0; j &lt; actionSlice.length; j++) {
      pattern += self._getNargsPattern(actionSlice[j]);
    }

    pattern = new RegExp(&#039;^&#039; + pattern);
    matches = regexpArgStrings.match(pattern);

    if (matches &amp;&amp; matches.length &gt; 0) {
      // need only groups
      matches = matches.splice(1);
      result = result.concat(matches.map(getLength));
      break;
    }
  }

  // return the list of arg string counts
  return result;
};

ArgumentParser.prototype._parseOptional = function (argString) {
  var action, optionString, argExplicit, optionTuples;

  // if it&#039;s an empty string, it was meant to be a positional
  if (!argString) {
    return null;
  }

  // if it doesn&#039;t start with a prefix, it was meant to be positional
  if (this.prefixChars.indexOf(argString[0]) &lt; 0) {
    return null;
  }

  // if the option string is present in the parser, return the action
  if (!!this._optionStringActions[argString]) {
    return [this._optionStringActions[argString], argString, null];
  }

  // if it&#039;s just a single character, it was meant to be positional
  if (argString.length === 1) {
    return null;
  }

  // if the option string before the &quot;=&quot; is present, return the action
  if (argString.indexOf(&#039;=&#039;) &gt;= 0) {
    var argStringSplit = argString.split(&#039;=&#039;);
    optionString = argStringSplit[0];
    argExplicit = argStringSplit[1];

    if (!!this._optionStringActions[optionString]) {
      action = this._optionStringActions[optionString];
      return [action, optionString, argExplicit];
    }
  }

  // search through all possible prefixes of the option string
  // and all actions in the parser for possible interpretations
  optionTuples = this._getOptionTuples(argString);

  // if multiple actions match, the option string was ambiguous
  if (optionTuples.length &gt; 1) {
    var optionStrings = optionTuples.map(function (optionTuple) {
      return optionTuple[1];
    });
    this.error(format(
          &#039;Ambiguous option: &quot;%s&quot; could match %s.&#039;,
          argString, optionStrings.join(&#039;, &#039;)
    ));
  // if exactly one action matched, this segmentation is good,
  // so return the parsed action
  } else if (optionTuples.length === 1) {
    return optionTuples[0];
  }

  // if it was not found as an option, but it looks like a negative
  // number, it was meant to be positional
  // unless there are negative-number-like options
  if (argString.match(this._regexpNegativeNumber)) {
    if (!_.any(this._hasNegativeNumberOptionals)) {
      return null;
    }
  }
  // if it contains a space, it was meant to be a positional
  if (argString.search(&#039; &#039;) &gt;= 0) {
    return null;
  }

  // it was meant to be an optional but there is no such option
  // in this parser (though it might be a valid option in a subparser)
  return [null, argString, null];
};

ArgumentParser.prototype._getOptionTuples = function (optionString) {
  var result = [];
  var chars = this.prefixChars;
  var optionPrefix;
  var argExplicit;
  var action;
  var actionOptionString;

  // option strings starting with two prefix characters are only split at
  // the &#039;=&#039;
  if (chars.indexOf(optionString[0]) &gt;= 0 &amp;&amp; chars.indexOf(optionString[1]) &gt;= 0) {
    if (optionString.indexOf(&#039;=&#039;) &gt;= 0) {
      var optionStringSplit = optionString.split(&#039;=&#039;, 1);

      optionPrefix = optionStringSplit[0];
      argExplicit = optionStringSplit[1];
    } else {
      optionPrefix = optionString;
      argExplicit = null;
    }

    for (actionOptionString in this._optionStringActions) {
      if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {
        action = this._optionStringActions[actionOptionString];
        result.push([action, actionOptionString, argExplicit]);
      }
    }

  // single character options can be concatenated with their arguments
  // but multiple character options always have to have their argument
  // separate
  } else if (chars.indexOf(optionString[0]) &gt;= 0 &amp;&amp; chars.indexOf(optionString[1]) &lt; 0) {
    optionPrefix = optionString;
    argExplicit = null;
    var optionPrefixShort = optionString.substr(0, 2);
    var argExplicitShort = optionString.substr(2);

    for (actionOptionString in this._optionStringActions) {
      action = this._optionStringActions[actionOptionString];
      if (actionOptionString === optionPrefixShort) {
        result.push([action, actionOptionString, argExplicitShort]);
      } else if (actionOptionString.substr(0, optionPrefix.length) === optionPrefix) {
        result.push([action, actionOptionString, argExplicit]);
      }
    }

  // shouldn&#039;t ever get here
  } else {
    throw new Error(format(&#039;Unexpected option string: %s.&#039;, optionString));
  }
  // return the collected option tuples
  return result;
};

ArgumentParser.prototype._getNargsPattern = function (action) {
  // in all examples below, we have to allow for &#039;--&#039; args
  // which are represented as &#039;-&#039; in the pattern
  var regexpNargs;

  switch (action.nargs) {
  // the default (null) is assumed to be a single argument
  case undefined:
  case null:
    regexpNargs = &#039;(-*A-*)&#039;;
    break;
  // allow zero or more arguments
  case $$.OPTIONAL:
    regexpNargs = &#039;(-*A?-*)&#039;;
    break;
  // allow zero or more arguments
  case $$.ZERO_OR_MORE:
    regexpNargs = &#039;(-*[A-]*)&#039;;
    break;
  // allow one or more arguments
  case $$.ONE_OR_MORE:
    regexpNargs = &#039;(-*A[A-]*)&#039;;
    break;
  // allow any number of options or arguments
  case $$.REMAINDER:
    regexpNargs = &#039;([-AO]*)&#039;;
    break;
  // allow one argument followed by any number of options or arguments
  case $$.PARSER:
    regexpNargs = &#039;(-*A[-AO]*)&#039;;
    break;
  // all others should be integers
  default:
    regexpNargs = &#039;(-*&#039; + _.str.repeat(&#039;-*A&#039;, action.nargs) + &#039;-*)&#039;;
  }

  // if this is an optional action, -- is not allowed
  if (action.isOptional()) {
    regexpNargs = regexpNargs.replace(/-\*/g, &#039;&#039;);
    regexpNargs = regexpNargs.replace(/-/g, &#039;&#039;);
  }

  // return the pattern
  return regexpNargs;
};

//
// Value conversion methods
//

ArgumentParser.prototype._getValues = function (action, argStrings) {
  var self = this;

  // for everything but PARSER args, strip out &#039;--&#039;
  if (action.nargs !== $$.PARSER &amp;&amp; action.nargs !== $$.REMAINDER) {
    argStrings = argStrings.filter(function (arrayElement) {
      return arrayElement !== &#039;--&#039;;
    });
  }

  var value, argString;

  // optional argument produces a default when not present
  if (argStrings.length === 0 &amp;&amp; action.nargs === $$.OPTIONAL) {

    value = (action.isOptional()) ? action.constant: action.defaultValue;

    if (typeof(value) === &#039;string&#039;) {
      value = this._getValue(action, value);
      this._checkValue(action, value);
    }

  // when nargs=&#039;*&#039; on a positional, if there were no command-line
  // args, use the default if it is anything other than None
  } else if (argStrings.length === 0 &amp;&amp; action.nargs === $$.ZERO_OR_MORE &amp;&amp;
    action.optionStrings.length === 0) {

    value = (action.defaultValue || argStrings);
    this._checkValue(action, value);

  // single argument or optional argument produces a single value
  } else if (argStrings.length === 1 &amp;&amp;
        (!action.nargs || action.nargs === $$.OPTIONAL)) {

    argString = argStrings[0];
    value = this._getValue(action, argString);
    this._checkValue(action, value);

  // REMAINDER arguments convert all values, checking none
  } else if (action.nargs === $$.REMAINDER) {
    value = argStrings.map(function (v) {
      return self._getValue(action, v);
    });

  // PARSER arguments convert all values, but check only the first
  } else if (action.nargs === $$.PARSER) {
    value = argStrings.map(function (v) {
      return self._getValue(action, v);
    });
    this._checkValue(action, value[0]);

  // all other types of nargs produce a list
  } else {
    value = argStrings.map(function (v) {
      return self._getValue(action, v);
    });
    value.forEach(function (v) {
      self._checkValue(action, v);
    });
  }

  // return the converted value
  return value;
};

ArgumentParser.prototype._getValue = function (action, argString) {
  var result;

  var typeFunction = this._registryGet(&#039;type&#039;, action.type, action.type);
  if (!_.isFunction(typeFunction)) {
    var message = format(&#039;%s is not callable&#039;, typeFunction);
    throw argumentErrorHelper(action, message);
  }

  // convert the value to the appropriate type
  try {
    result = typeFunction(argString);

    // ArgumentTypeErrors indicate errors
    // If action.type is not a registered string, it is a function
    // Try to deduce its name for inclusion in the error message
    // Failing that, include the error message it raised.
  } catch (e) {
    var name = null;
    if (_.isString(action.type)) {
      name = action.type;
    } else {
      name = action.type.name || action.type.displayName || &#039;&lt;function&gt;&#039;;
    }
    var msg = format(&#039;Invalid %s value: %s&#039;, name, argString);
    if (name === &#039;&lt;function&gt;&#039;) {msg += &#039;\n&#039; + e.message; }
    throw argumentErrorHelper(action, msg);
  }
  // return the converted value
  return result;
};

ArgumentParser.prototype._checkValue = function (action, value) {
  // converted value must be one of the choices (if specified)
  var choices = action.choices;
  if (!!choices) {
    // choise for argument can by array or string
    if ((_.isString(choices) || _.isArray(choices)) &amp;&amp;
        choices.indexOf(value) !== -1) {
      return;
    }
    // choise for subparsers can by only hash
    if (_.isObject(choices) &amp;&amp; !_.isArray(choices) &amp;&amp; choices[value]) {
      return;
    }

    if (_.isString(choices)) {
      choices = choices.split(&#039;&#039;).join(&#039;, &#039;);
    }
    else if (_.isArray(choices)) {
      choices =  choices.join(&#039;, &#039;);
    }
    else {
      choices =  _.keys(choices).join(&#039;, &#039;);
    }
    var message = format(&#039;Invalid choice: %s (choose from [%s])&#039;, value, choices);
    throw argumentErrorHelper(action, message);
  }
};

//
// Help formatting methods
//

/**
 * ArgumentParser#formatUsage -&gt; string
 *
 * Return usage string
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
 **/
ArgumentParser.prototype.formatUsage = function () {
  var formatter = this._getFormatter();
  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);
  return formatter.formatHelp();
};

/**
 * ArgumentParser#formatHelp -&gt; string
 *
 * Return help
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
 **/
ArgumentParser.prototype.formatHelp = function () {
  var formatter = this._getFormatter();

  // usage
  formatter.addUsage(this.usage, this._actions, this._mutuallyExclusiveGroups);

  // description
  formatter.addText(this.description);

  // positionals, optionals and user-defined groups
  this._actionGroups.forEach(function (actionGroup) {
    formatter.startSection(actionGroup.title);
    formatter.addText(actionGroup.description);
    formatter.addArguments(actionGroup._groupActions);
    formatter.endSection();
  });

  // epilog
  formatter.addText(this.epilog);

  // determine help from format above
  return formatter.formatHelp();
};

ArgumentParser.prototype._getFormatter = function () {
  var FormatterClass = this.formatterClass;
  var formatter = new FormatterClass({prog: this.prog});
  return formatter;
};

//
//  Print functions
//

/**
 * ArgumentParser#printUsage() -&gt; Void
 *
 * Print usage
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
 **/
ArgumentParser.prototype.printUsage = function () {
  this._printMessage(this.formatUsage());
};

/**
 * ArgumentParser#printHelp() -&gt; Void
 *
 * Print help
 *
 * See also [original guide][1]
 *
 * [1]:http://docs.python.org/dev/library/argparse.html#printing-help
 **/
ArgumentParser.prototype.printHelp = function () {
  this._printMessage(this.formatHelp());
};

ArgumentParser.prototype._printMessage = function (message, stream) {
  if (!stream) {
    stream = process.stdout;
  }
  if (message) {
    stream.write(&#039;&#039; + message);
  }
};

//
//  Exit functions
//

/**
 * ArgumentParser#exit(status=0, message) -&gt; Void
 * - status (int): exit status
 * - message (string): message
 *
 * Print message in stderr/stdout and exit program
 **/
ArgumentParser.prototype.exit = function (status, message) {
  if (!!message) {
    if (status === 0) {
      this._printMessage(message);
    }
    else {
      this._printMessage(message, process.stderr);
    }
  }

  process.exit(status);
};

/**
 * ArgumentParser#error(message) -&gt; Void
 * - err (Error|string): message
 *
 * Error method Prints a usage message incorporating the message to stderr and
 * exits. If you override this in a subclass,
 * it should not return -- it should
 * either exit or throw an exception.
 *
 **/
ArgumentParser.prototype.error = function (err) {
  var message;
  if (err instanceof Error) {
    if (this.debug === true) {
      throw err;
    }
    message = err.message;
  }
  else {
    message = err;
  }
  var msg = format(&#039;%s: error: %s&#039;, this.prog, message) + $$.EOL;

  if (this.debug === true) {
    throw new Error(msg);
  }

  this.printUsage(process.stderr);

  return this.exit(2, msg);
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
