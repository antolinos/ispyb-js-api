<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/cli/cli.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/cli/cli.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">59.91</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1126</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">113.69</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">11.94</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * Copyright (c) 2010 Chris O&#039;Hara &lt;cohara87@gmail.com&gt;
 *
 * Permission is hereby granted, free of charge, to any person obtaining
 * a copy of this software and associated documentation files (the
 * &quot;Software&quot;), to deal in the Software without restriction, including
 * without limitation the rights to use, copy, modify, merge, publish,
 * distribute, sublicense, and/or sell copies of the Software, and to
 * permit persons to whom the Software is furnished to do so, subject to
 * the following conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
 * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
 */

 //Note: cli includes kof/node-natives and creationix/stack. I couldn&#039;t find
 //license information for either - contact me if you want your license added

var cli = exports,
    argv, curr_opt, curr_val, full_opt, is_long,
    short_tags = [], opt_list, parsed = {},
    usage, argv_parsed, command_list, commands,
    daemon, daemon_arg, no_color, show_debug;

cli.app = null;
cli.version = null;
cli.argv = [];
cli.argc = 0;

cli.options = {};
cli.args = [];
cli.command = null;

cli.width = 70;
cli.option_width = 25;

/**
 * Bind kof&#039;s node-natives (https://github.com/kof/node-natives) to `cli.native`
 *
 * Rather than requiring node natives (e.g. var fs = require(&#039;fs&#039;)), all
 * native modules can be accessed like `cli.native.fs`
 */
cli.native = {};
var define_native = function (module) {
    Object.defineProperty(cli.native, module, {
        enumerable: true,
        configurable: true,
        get: function() {
            delete cli.native[module];
            return (cli.native[module] = require(module));
        }
    });
};
var natives = process.binding(&#039;natives&#039;);
for (var module in natives) {
    define_native(module);
}

cli.output = console.log;
cli.exit = require(&#039;exit&#039;);

/**
 * Define plugins. Plugins can be enabled and disabled by calling:
 *
 *     `cli.enable(plugin1, [plugin2, ...])`
 *     `cli.disable(plugin1, [plugin2, ...])`
 *
 * Methods are chainable - `cli.enable(plugin).disable(plugin2)`.
 *
 * The &#039;help&#039; plugin is enabled by default.
 */
var enable = {
    help: true,      //Adds -h, --help
    version: false,  //Adds -v,--version =&gt; gets version by parsing a nearby package.json
    daemon: false,   //Adds -d,--daemon [ARG] =&gt; (see cli.daemon() below)
    status: false,   //Adds -k,--no-color &amp; --debug =&gt; display plain status messages /display debug messages
    timeout: false,  //Adds -t,--timeout N =&gt; timeout the process after N seconds
    catchall: false, //Adds -c,--catch =&gt; catch and output uncaughtExceptions
    glob: false      //Adds glob matching =&gt; use cli.glob(arg)
}
cli.enable = function (/*plugins*/) {
    Array.prototype.slice.call(arguments).forEach(function (plugin) {
        switch (plugin) {
        case &#039;daemon&#039;:
            try {
                daemon = require(&#039;daemon&#039;);
                if (typeof daemon.daemonize !== &#039;function&#039;) {
                    throw &#039;Invalid module&#039;;
                }
            } catch (e) {
                cli.fatal(&#039;daemon.node not installed. Please run `npm install daemon`&#039;);
            }
            break;
        case &#039;catchall&#039;:
            process.on(&#039;uncaughtException&#039;, function (err) {
                cli.error(&#039;Uncaught exception: &#039; + (err.msg || err));
            });
            break;
        case &#039;help&#039;: case &#039;version&#039;: case &#039;status&#039;:
        case &#039;autocomplete&#039;: case &#039;timeout&#039;:
            //Just add switches.
            break;
        case &#039;glob&#039;:
            cli.glob = require(&#039;glob&#039;);
            break;
        default:
            cli.fatal(&#039;Unknown plugin &quot;&#039; + plugin + &#039;&quot;&#039;);
            break;
        }
        enable[plugin] = true;
    });
    return cli;
}
cli.disable = function (/*plugins*/) {
    Array.prototype.slice.call(arguments).forEach(function (plugin) {
        if (enable[plugin]) {
            enable[plugin] = false;
        }
    });
    return cli;
}

/**
 * Sets argv (default is process.argv).
 *
 * @param {Array|String} argv
 * @param {Boolean} keep_arg0 (optional - default is false)
 * @api public
 */
cli.setArgv = function (arr, keep_arg0) {
    if (typeof arr == &#039;string&#039;) {
      arr = arr.split(&#039; &#039;);
    } else {
      arr = arr.slice();
    }
    cli.app = arr.shift();
    // Strip off argv[0] if it&#039;s a node binary
    // So this is still broken and will break if you are calling node through a
    // symlink, unless you are lucky enough to have it as &#039;node&#039; literal. Latter
    // is a hack, but resolving abspaths/symlinks is an unportable can of worms.
    if (!keep_arg0 &amp;&amp; ([&#039;node&#039;, &#039;node.exe&#039;].indexOf(cli.native.path.basename(cli.app)) !== -1
            || cli.native.path.basename(process.execPath) === cli.app
            || process.execPath === cli.app)) {
        cli.app = arr.shift();
    }
    cli.app = cli.native.path.basename(cli.app);
    argv_parsed = false;
    cli.args = cli.argv = argv = arr;
    cli.argc = argv.length;
    cli.options = {};
    cli.command = null;
};
cli.setArgv(process.argv);

/**
 * Returns the next opt, or false if no opts are found.
 *
 * @return {String} opt
 * @api public
 */
cli.next = function () {
    if (!argv_parsed) {
        cli.args = [];
        argv_parsed = true;
    }

    curr_val = null;

    //If we&#039;re currently in a group of short opts (e.g. -abc), return the next opt
    if (short_tags.length) {
        curr_opt = short_tags.shift();
        full_opt = &#039;-&#039; + curr_opt;
        return curr_opt;
    }

    if (!argv.length) {
        return false;
    }

    curr_opt = argv.shift();

    //If an escape sequence is found (- or --), subsequent opts are ignored
    if (curr_opt === &#039;-&#039; || curr_opt === &#039;--&#039;) {
        while (argv.length) {
            cli.args.push(argv.shift());
        }
        return false;
    }

    //If the next element in argv isn&#039;t an opt, add it to the list of args
    if (curr_opt[0] !== &#039;-&#039;) {
        cli.args.push(curr_opt);
        return cli.next();
    } else {
        //Check if the opt is short/long
        is_long = curr_opt[1] === &#039;-&#039;;
        curr_opt = curr_opt.substr(is_long ? 2 : 1);
    }

    //Accept grouped short opts, e.g. -abc =&gt; -a -b -c
    if (!is_long &amp;&amp; curr_opt.length &gt; 1) {
        short_tags = curr_opt.split(&#039;&#039;);
        return cli.next();
    }

    var eq, len;

    //Check if the long opt is in the form --option=VALUE
    if (is_long &amp;&amp; (eq = curr_opt.indexOf(&#039;=&#039;)) &gt;= 0) {
        curr_val = curr_opt.substr(eq + 1);
        curr_opt = curr_opt.substr(0, eq);
        len = curr_val.length;
        //Allow values to be quoted
        if ((curr_val[0] === &#039;&quot;&#039; &amp;&amp; curr_val[len - 1] === &#039;&quot;&#039;) ||
            (curr_val[0] === &quot;&#039;&quot; &amp;&amp; curr_val[len - 1] === &quot;&#039;&quot;))
        {
            curr_val = curr_val.substr(1, len-2);
        }
        if (curr_val.match(/^[0-9]+$/)) {
            curr_val = parseInt(curr_val, 10);
        }
    }

    //Save the opt representation for later
    full_opt = (is_long ? &#039;--&#039; : &#039;-&#039;) + curr_opt;

    return curr_opt;
};

/**
 * Parses command line opts.
 *
 * `opts` must be an object with opts defined like:
 *        long_tag: [short_tag, description, value_type, default_value];
 *
 * `commands` is an optional array or object for apps that are of the form
 *      my_app [OPTIONS] &lt;command&gt; [ARGS]
 *  The command list is output with usage information + there is bundled
 *  support for auto-completion, etc.
 *
 * See README.md for more information.
 *
 * @param {Object} opts
 * @param {Object} commands (optional)
 * @return {Object} opts (parsed)
 * @api public
 */
cli.parse = function (opts, command_def) {
    var default_val, i, parsed = cli.options, seen,
        catch_all = !opts;
    opt_list = opts || {};
    commands = command_def;
    command_list = commands || [];
    if (commands &amp;&amp; !Array.isArray(commands)) {
        command_list = Object.keys(commands);
    }
    while ((o = cli.next())) {
        seen = false;
        for (var opt in opt_list) {
            if (!(opt_list[opt] instanceof Array)) {
                continue;
            }
            if (!opt_list[opt][0]) {
                opt_list[opt][0] = opt;
            }
            if (o === opt || o === opt_list[opt][0]) {
                seen = true;
                if (opt_list[opt].length === 2) {
                    parsed[opt] = true;
                    break;
                }
                default_val = null;
                if (opt_list[opt].length === 4) {
                    default_val = opt_list[opt][3];
                }
                if (opt_list[opt][2] instanceof Array) {
                    for (i = 0, l = opt_list[opt][2].length; i &lt; l; i++) {
                        if (typeof opt_list[opt][2][i] === &#039;number&#039;) {
                            opt_list[opt][2][i] += &#039;&#039;;
                        }
                    }
                    parsed[opt] = cli.getArrayValue(opt_list[opt][2], is_long ? null : default_val);
                    break;
                }
                if (opt_list[opt][2].toLowerCase) {
                    opt_list[opt][2] = opt_list[opt][2].toLowerCase();
                }
                switch (opt_list[opt][2]) {
                case &#039;string&#039;: case 1: case true:
                    parsed[opt] = cli.getValue(default_val);
                    break;
                case &#039;int&#039;: case &#039;number&#039;: case &#039;num&#039;:
                case &#039;time&#039;: case &#039;seconds&#039;: case &#039;secs&#039;: case &#039;minutes&#039;: case &#039;mins&#039;:
                case &#039;x&#039;: case &#039;n&#039;:
                    parsed[opt] = cli.getInt(default_val);
                    break;
                case &#039;float&#039;: case &#039;decimal&#039;:
                    parsed[opt] = cli.getFloat(default_val);
                    break;
                case &#039;path&#039;: case &#039;file&#039;: case &#039;directory&#039;: case &#039;dir&#039;:
                    parsed[opt] = cli.getPath(default_val, opt_list[opt][2]);
                    break;
                case &#039;email&#039;:
                    parsed[opt] = cli.getEmail(default_val);
                    break;
                case &#039;url&#039;: case &#039;uri&#039;: case &#039;domain&#039;: case &#039;host&#039;:
                    parsed[opt] = cli.getUrl(default_val, opt_list[opt][2]);
                    break;
                case &#039;ip&#039;:
                    parsed[opt] = cli.getIp(default_val);
                    break;
                case &#039;bool&#039;: case &#039;boolean&#039;: case &#039;on&#039;:
                    parsed[opt] = true;
                    break;
                case &#039;false&#039;: case &#039;off&#039;: case false: case 0:
                    parsed[opt] = false;
                    break;
                default:
                     cli.fatal(&#039;Unknown opt type &quot;&#039; + opt_list[opt][2] + &#039;&quot;&#039;);
                }
                break;
            }
        }
        if (process.env.NODE_DISABLE_COLORS) {
            no_color = true;
        }
        if (!seen) {
            if (enable.help &amp;&amp; (o === &#039;h&#039; || o === &#039;help&#039;)) {
                cli.getUsage();
            } else if (enable.version &amp;&amp; (o === &#039;v&#039; || o === &#039;version&#039;)) {
                if (cli.version == null) {
                    cli.parsePackageJson();
                }
                console.error(cli.app + &#039; v&#039; + cli.version);
                cli.exit();
                break;
            } else if (enable.daemon &amp;&amp; (o === &#039;d&#039; || o === &#039;daemon&#039;)) {
                daemon_arg = cli.getArrayValue([&#039;start&#039;,&#039;stop&#039;,&#039;restart&#039;,&#039;pid&#039;,&#039;log&#039;], is_long ? null : &#039;start&#039;);
                continue;
            } else if (enable.catchall &amp;&amp; (o === &#039;c&#039; || o === &#039;catch&#039;)) {
                continue;
            } else if (enable.status &amp;&amp; (o === &#039;k&#039; || o === &#039;no-color&#039; || o === &#039;debug&#039;)) {
                no_color = (o === &#039;k&#039; || o === &#039;no-color&#039;);
                show_debug = o === &#039;debug&#039;;
                continue;
            } else if (enable.timeout &amp;&amp; (o === &#039;t&#039; || o === &#039;timeout&#039;)) {
                var secs = cli.getInt();
                setTimeout(function () {
                    cli.fatal(&#039;Process timed out after &#039; + secs + &#039;s&#039;);
                }, secs * 1000);
                continue;
            } else if (catch_all) {
                parsed[o] = curr_val || true;
                continue;
            }
            cli.fatal(&#039;Unknown option &#039; + full_opt);
        }
    }
    //Fill the remaining options with their default value or null
    for (var opt in opt_list) {
        default_val = opt_list[opt].length === 4 ? opt_list[opt][3] : null;
        if (!(opt_list[opt] instanceof Array)) {
            parsed[opt] = opt_list[opt];
            continue;
        } else if (typeof parsed[opt] === &#039;undefined&#039;) {
            parsed[opt] = default_val;
        }
    }
    if (command_list.length) {
        if (cli.args.length === 0) {
            if (enable.help) {
                cli.getUsage();
            } else {
                cli.fatal(&#039;A command is required (&#039; + command_list.join(&#039;, &#039;) + &#039;).&#039;);
            }
            return cli.exit(1);
        } else {
            cli.command = cli.autocompleteCommand(cli.args.shift());
        }
    }
    cli.argc = cli.args.length;
    return parsed;
};

/**
 * Helper method for matching a command from the command list.
 *
 * @param {String} command
 * @return {String} full_command
 * @api public
 */
cli.autocompleteCommand = function (command) {
    var list;
    if (!(command_list instanceof Array)) {
        list = Object.keys(command_list);
    } else {
        list = command_list;
    }
    var i, j = 0, c = command.length, tmp_list;
    if (list.length === 0 || list.indexOf(command) !== -1) {
        return command;
    }
    for (i = 0; i &lt; c; i++) {
        tmp_list = [];
        l = list.length;
        if (l &lt;= 1) break;
        for (j = 0; j &lt; l; j++)
            if (list[j].length &gt;= i &amp;&amp; list[j][i] === command[i])
                tmp_list.push(list[j]);
        list = tmp_list;
    }
    l = list.length;
    if (l === 1) {
        return list[0];
    } else if (l === 0) {
        cli.fatal(&#039;Unknown command &quot;&#039; + command + &#039;&quot;&#039; + (enable.help ? &#039;. Please see --help for more information&#039; : &#039;&#039;));
    } else {
        list.sort();
        cli.fatal(&#039;The command &quot;&#039; + command + &#039;&quot; is ambiguous and could mean &quot;&#039; + list.join(&#039;&quot;, &quot;&#039;) + &#039;&quot;&#039;);
    }
};

/**
 * Adds methods to output styled status messages to stderr.
 *
 * Added methods are cli.info(msg), cli.error(msg), cli.ok(msg), and
 * cli.debug(msg).
 *
 * To control status messages, use the &#039;status&#039; plugin
 *    1) debug() messages are hidden by default. Display them with
 *       the --debug opt.
 *    2) to hide all status messages, use the -s or --silent opt.
 *
 * @api private
 */
cli.status = function (msg, type) {
    var pre;
    switch (type) {
    case &#039;info&#039;:
        pre = no_color ? &#039;INFO:&#039; : &#039;\x1B[33mINFO\x1B[0m:&#039;;
        break;
    case &#039;debug&#039;:
        pre = no_color ? &#039;DEBUG:&#039; : &#039;\x1B[36mDEBUG\x1B[0m:&#039;;
        break;
    case &#039;error&#039;:
    case &#039;fatal&#039;:
        pre = no_color ? &#039;ERROR:&#039; : &#039;\x1B[31mERROR\x1B[0m:&#039;;
        break;
    case &#039;ok&#039;:
        pre = no_color ? &#039;OK:&#039; : &#039;\x1B[32mOK\x1B[0m:&#039;;
        break;
    }
    msg = pre + &#039; &#039; + msg;
    if (type === &#039;fatal&#039;) {
        console.error(msg);
        return cli.exit(1);
    }
    if (enable.status &amp;&amp; !show_debug &amp;&amp; type === &#039;debug&#039;) {
        return;
    }
    console.error(msg);
};
[&#039;info&#039;,&#039;error&#039;,&#039;ok&#039;,&#039;debug&#039;,&#039;fatal&#039;].forEach(function (type) {
    cli[type] = function (msg) {
        cli.status(msg, type);
    };
});

/**
 * Sets the app name and version.
 *
 * Usage:
 *     setApp(&#039;myapp&#039;, &#039;0.1.0&#039;);
 *     setApp(&#039;./package.json&#039;); //Pull name/version from package.json
 *
 * @param {String} name
 * @return cli (for chaining)
 * @api public
 */
cli.setApp = function (name, version) {
    if (name.indexOf(&#039;package.json&#039;) !== -1) {
        cli.parsePackageJson(name);
    } else {
        cli.app = name;
        cli.version = version;
    }
    return cli;
};

/**
 * Parses the version number from package.json. If no path is specified, cli
 * will attempt to locate a package.json in ./, ../ or ../../
 *
 * @param {String} path (optional)
 * @api public
 */
cli.parsePackageJson = function (path) {
    var parse_packagejson = function (path) {
        var packagejson = JSON.parse(cli.native.fs.readFileSync(path, &#039;utf8&#039;));
        cli.version = packagejson.version;
        cli.app = packagejson.name;
    };
    var try_all = function (arr, func, err) {
        for (var i = 0, l = arr.length; i &lt; l; i++) {
            try {
                func(arr[i]);
                return;
            } catch (e) {
                if (i === l-1) {
                    cli.fatal(err);
                }
            }
        }
    };
    try {
        if (path) {
            return parse_packagejson(path);
        }
        try_all([
            __dirname + &#039;/package.json&#039;,
            __dirname + &#039;/../package.json&#039;,
            __dirname + &#039;/../../package.json&#039;
        ], parse_packagejson);
    } catch (e) {
        cli.fatal(&#039;Could not detect &#039; + cli.app + &#039; version&#039;);
    }
};

/**
 * Sets the usage string - default is `app [OPTIONS] [ARGS]`.
 *
 * @param {String} u
 * @return cli (for chaining)
 * @api public
 */
cli.setUsage = function (u) {
    usage = u;
    return cli;
};

var pad = function (str, len) {
    if (typeof len === &#039;undefined&#039;) {
        len = str;
        str = &#039;&#039;;
    }
    if (str.length &lt; len) {
        len -= str.length;
        while (len--) str += &#039; &#039;;
    }
    return str;
};

/**
 * Automatically build usage information from the opts list. If the help
 * plugin is enabled (default), this info is displayed with -h, --help.
 *
 * @api public
 */
cli.getUsage = function (code) {
    var short, desc, optional, line, seen_opts = [],
        switch_pad = cli.option_width;

    var trunc_desc = function (pref, desc, len) {
        var pref_len = pref.length,
            desc_len = cli.width - pref_len,
            truncated = &#039;&#039;;
        if (desc.length &lt;= desc_len) {
            return desc;
        }
        var desc_words = (desc+&#039;&#039;).split(&#039; &#039;), chars = 0, word;
        while (desc_words.length) {
            truncated += (word = desc_words.shift()) + &#039; &#039;;
            chars += word.length;
            if (desc_words.length &amp;&amp; chars + desc_words[0].length &gt; desc_len) {
                truncated += &#039;\n&#039; + pad(pref_len);
                chars = 0;
            }
        }
        return truncated;
    };

    usage = usage || cli.app + &#039; [OPTIONS]&#039; + (command_list.length ? &#039; &lt;command&gt;&#039; : &#039;&#039;) + &#039; [ARGS]&#039;;
    if (no_color) {
        console.error(&#039;Usage:\n  &#039; + usage);
        console.error(&#039;Options: &#039;);
    } else {
        console.error(&#039;\x1b[1mUsage\x1b[0m:\n  &#039; + usage);
        console.error(&#039;\n\x1b[1mOptions\x1b[0m: &#039;);
    }
    for (var opt in opt_list) {

        if (opt.length === 1) {
            long = opt_list[opt][0];
            short = opt;
        } else {
            long = opt;
            short = opt_list[opt][0];
        }

        //Parse opt_list
        desc = opt_list[opt][1].trim();
        type = opt_list[opt].length &gt;= 3 ? opt_list[opt][2] : null;
        optional = opt_list[opt].length === 4 ? opt_list[opt][3] : null;

        //Build usage line
        if (short === long) {
            if (short.length === 1) {
                line = &#039;  -&#039; + short;
            } else {
                line = &#039;      --&#039; + long;
            }
        } else if (short) {
            line = &#039;  -&#039; + short + &#039;, --&#039; + long;
        } else {
            line = &#039;      --&#039; + long;
        }
        line += &#039; &#039;;

        if (type) {
            if (type instanceof Array) {
                desc += &#039;. VALUE must be either [&#039; + type.join(&#039;|&#039;) + &#039;]&#039;;
                type = &#039;VALUE&#039;;
            }
            if (type === true || type === 1) {
                type = long.toUpperCase();
            }
            type = type.toUpperCase();
            if (type === &#039;FLOAT&#039; || type === &#039;INT&#039;) {
                type = &#039;NUMBER&#039;;
            }
            line += optional ? &#039;[&#039; + type + &#039;]&#039; : type;
        }
        line = pad(line, switch_pad);
        line += trunc_desc(line, desc);
        line += optional ? &#039; (Default is &#039; + optional + &#039;)&#039; : &#039;&#039;;
        console.error(line.replace(&#039;%s&#039;, &#039;%\0s&#039;));

        seen_opts.push(short);
        seen_opts.push(long);
    }
    if (enable.timeout &amp;&amp; seen_opts.indexOf(&#039;t&#039;) === -1 &amp;&amp; seen_opts.indexOf(&#039;timeout&#039;) === -1) {
        console.error(pad(&#039;  -t, --timeout N&#039;, switch_pad) + &#039;Exit if the process takes longer than N seconds&#039;);
    }
    if (enable.status) {
        if (seen_opts.indexOf(&#039;k&#039;) === -1 &amp;&amp; seen_opts.indexOf(&#039;no-color&#039;) === -1) {
            console.error(pad(&#039;  -k, --no-color&#039;, switch_pad) + &#039;Omit color from output&#039;);
        }
        if (seen_opts.indexOf(&#039;debug&#039;) === -1) {
            console.error(pad(&#039;      --debug&#039;, switch_pad) + &#039;Show debug information&#039;);
        }
    }
    if (enable.catchall &amp;&amp; seen_opts.indexOf(&#039;c&#039;) === -1 &amp;&amp; seen_opts.indexOf(&#039;catch&#039;) === -1) {
        console.error(pad(&#039;  -c, --catch&#039;, switch_pad) + &#039;Catch unanticipated errors&#039;);
    }
    if (enable.daemon &amp;&amp; seen_opts.indexOf(&#039;d&#039;) === -1 &amp;&amp; seen_opts.indexOf(&#039;daemon&#039;) === -1) {
        console.error(pad(&#039;  -d, --daemon [ARG]&#039;, switch_pad) + &#039;Daemonize the process. Control the daemon using [start, stop, restart, log, pid]&#039;);
    }
    if (enable.version &amp;&amp; seen_opts.indexOf(&#039;v&#039;) === -1 &amp;&amp; seen_opts.indexOf(&#039;version&#039;) === -1) {
        console.error(pad(&#039;  -v, --version&#039;, switch_pad) + &#039;Display the current version&#039;);
    }
    if (enable.help &amp;&amp; seen_opts.indexOf(&#039;h&#039;) === -1 &amp;&amp; seen_opts.indexOf(&#039;help&#039;) === -1) {
        console.error(pad(&#039;  -h, --help&#039;, switch_pad) + &#039;Display help and usage details&#039;);
    }
    if (command_list.length) {
        console.error(&#039;\n\x1b[1mCommands\x1b[0m: &#039;);
        if (!Array.isArray(commands)) {
            for (var c in commands) {
                line = &#039;  &#039; + pad(c, switch_pad - 2);
                line += trunc_desc(line, commands[c]);
                console.error(line);
            }
        } else {
            command_list.sort();
            console.error(&#039;  &#039; + trunc_desc(&#039;  &#039;, command_list.join(&#039;, &#039;)));
        }
    }
    return cli.exit(code);
};

/**
 * Generates an error message when an opt is incorrectly used.
 *
 * @param {String} expects (e.g. &#039;a value&#039;)
 * @param {String} type (e.g. &#039;VALUE&#039;)
 * @api public
 */
cli.getOptError = function (expects, type) {
    var err = full_opt + &#039; expects &#039; + expects
            + &#039;. Use `&#039; + cli.app + &#039; &#039; + full_opt + (is_long ? &#039;=&#039; : &#039; &#039;) + type + &#039;`&#039;;
    return err;
};

/**
 * Gets the next opt value and validates it with an optional validation
 * function. If validation fails or no value can be obtained, this method
 * will return the default value (if specified) or exit with err_msg.
 *
 * @param {String} default_val
 * @param {Function} validate_func
 * @param {String} err_msg
 * @api public
 */
cli.getValue = function (default_val, validate_func, err_msg) {
    err_msg = err_msg || cli.getOptError(&#039;a value&#039;, &#039;VALUE&#039;);

    var value;

    try {
        if (curr_val) {
            if (validate_func) {
                curr_val = validate_func(curr_val);
            }
            return curr_val;
        }

        //Grouped short opts aren&#039;t allowed to have values
        if (short_tags.length) {
            throw &#039;Short tags&#039;;
        }

        //If there&#039;s no args left or the next arg is an opt, return the
        //default value (if specified) - otherwise fail
        if (!argv.length || (argv[0].length === 1 &amp;&amp; argv[0][0] === &#039;-&#039;)) {
            throw &#039;No value&#039;;
        }

        value = argv.shift();

        if (value.match(/^[0-9]+$/)) {
            value = parseInt(value, 10);
        }

        //Run the value through a validation/transformation function if specified
        if (validate_func) {
            value = validate_func(value);
        }
    } catch (e) {

        //The value didn&#039;t pass the validation/transformation. Unshift the value and
        //return the default value (if specified)
        if (value) {
            argv.unshift(value);
        }
        return default_val != null ? default_val : cli.fatal(err_msg);
    }
    return value;
};

cli.getInt = function (default_val) {
    return cli.getValue(default_val, function (value) {
        if (typeof value === &#039;number&#039;) return value;
        if (!value.match(/^(?:-?(?:0|[1-9][0-9]*))$/)) {
            throw &#039;Invalid int&#039;;
        }
        return parseInt(value);
    }, cli.getOptError(&#039;a number&#039;, &#039;NUMBER&#039;));
}

cli.getFloat = function (default_val) {
    return cli.getValue(default_val, function (value) {
        if (!value.match(/^(?:-?(?:0|[1-9][0-9]*))?(?:\.[0-9]*)?$/)) {
            throw &#039;Invalid float&#039;;
        }
        return parseFloat(value, 10);
    }, cli.getOptError(&#039;a number&#039;, &#039;NUMBER&#039;));
}

cli.getUrl = function (default_val, identifier) {
    identifier = identifier || &#039;url&#039;;
    return cli.getValue(default_val, function (value) {
        if (!value.match(/^(?:(?:ht|f)tp(?:s?)\:\/\/|~\/|\/)?(?:\w+:\w+@)?((?:(?:[-\w\d{1-3}]+\.)+(?:com|org|net|gov|mil|biz|info|mobi|name|aero|jobs|edu|co\.uk|ac\.uk|it|fr|tv|museum|asia|local|travel|[a-z]{2})?)|((\b25[0-5]\b|\b[2][0-4][0-9]\b|\b[0-1]?[0-9]?[0-9]\b)(\.(\b25[0-5]\b|\b[2][0-4][0-9]\b|\b[0-1]?[0-9]?[0-9]\b)){3}))(?::[\d]{1,5})?(?:(?:(?:\/(?:[-\w~!$+|.,=]|%[a-f\d]{2})+)+|\/)+|\?|#)?(?:(?:\?(?:[-\w~!$+|.,*:]|%[a-f\d{2}])+=?(?:[-\w~!$+|.,*:=]|%[a-f\d]{2})*)(?:&amp;(?:[-\w~!$+|.,*:]|%[a-f\d{2}])+=?(?:[-\w~!$+|.,*:=]|%[a-f\d]{2})*)*)*(?:#(?:[-\w~!$ |\/.,*:;=]|%[a-f\d]{2})*)?$/i)) {
            throw &#039;Invalid URL&#039;;
        }
        return value;
    }, cli.getOptError(&#039;a &#039; + identifier, identifier.toUpperCase()));
}

cli.getEmail = function (default_val) {
    return cli.getValue(default_val, function (value) {
        if (!value.match(/^(?:[\w\!\#\$\%\&amp;\&#039;\*\+\-\/\=\?\^\`\{\|\}\~]+\.)*[\w\!\#\$\%\&amp;\&#039;\*\+\-\/\=\?\^\`\{\|\}\~]+@(?:(?:(?:[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!\.)){0,61}[a-zA-Z0-9]?\.)+[a-zA-Z0-9](?:[a-zA-Z0-9\-](?!$)){0,61}[a-zA-Z0-9]?)|(?:\[(?:(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d{1,2}|2[0-4]\d|25[0-5])\]))$/)) {
            throw &#039;Invalid email&#039;;
        }
        return value;
    }, cli.getOptError(&#039;an email&#039;, &#039;EMAIL&#039;));
}

cli.getIp = function (default_val) {
    return cli.getValue(default_val, function (value) {
        if (!value.match(/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/)) {
            throw &#039;Invalid IP&#039;;
        }
        return value;
    }, cli.getOptError(&#039;an IP&#039;, &#039;IP&#039;));
}

cli.getPath = function (default_val, identifier) {
    identifier = identifier || &#039;path&#039;;
    return cli.getValue(default_val, function (value) {
        if (value.match(/[?*;{}]/)) {
            throw &#039;Invalid path&#039;;
        }
        return value;
    }, cli.getOptError(&#039;a &#039; + identifier, identifier.toUpperCase()));
}

cli.getArrayValue = function (arr, default_val) {
    return cli.getValue(default_val, function (value) {
        if (arr.indexOf(value) === -1) {
            throw &#039;Unexpected value&#039;;
        }
        return value;
    }, cli.getOptError(&#039;either [&#039; + arr.join(&#039;|&#039;) + &#039;]&#039;, &#039;VALUE&#039;));
}

/**
 * Gets all data from STDIN (with optional encoding) and sends it to callback.
 *
 * @param {String} encoding (optional - default is &#039;utf8&#039;)
 * @param {Function} callback
 * @api public
 */
cli.withStdin = function (encoding, callback) {
    if (typeof encoding === &#039;function&#039;) {
        callback = encoding;
        encoding = &#039;utf8&#039;;
    }
    var stream = process.openStdin(), data = &#039;&#039;;
    stream.setEncoding(encoding);
    stream.on(&#039;data&#039;, function (chunk) {
        data += chunk;
    });
    stream.on(&#039;end&#039;, function () {
        callback.apply(cli, [data]);
    });
};

/**
 * Gets all data from STDIN, splits the data into lines and sends it
 * to callback (callback isn&#039;t called until all of STDIN is read. To
 * process each line as it&#039;s received, see the method below
 *
 * @param {Function} callback
 * @api public
 */
cli.withStdinLines = function (callback) {
    cli.withStdin(function (data) {
        var sep = data.indexOf(&#039;\r\n&#039;) !== -1 ? &#039;\r\n&#039; : &#039;\n&#039;;
        callback.apply(cli, [data.split(sep), sep]);
    });
};

/**
 * Asynchronously reads a file line by line. When a line is received,
 * callback is called with (line, sep) - when EOF is reached, callback
 * receives (null, null, true)
 *
 * @param {String} file (optional - default is &#039;stdin&#039;)
 * @param {String} encoding (optional - default is &#039;utf8&#039;)
 * @param {Function} callback (line, sep, eof)
 * @api public
 */
cli.withInput = function (file, encoding, callback) {
    if (typeof encoding === &#039;function&#039;) {
        callback = encoding;
        encoding = &#039;utf8&#039;;
    } else if (typeof file === &#039;function&#039;) {
        callback = file;
        encoding = &#039;utf8&#039;;
        file = &#039;stdin&#039;;
    }
    if (file === &#039;stdin&#039;) {
        file = process.openStdin();
    } else {
        try {
            file = cli.native.fs.createReadStream(file);
            file.on(&#039;error&#039;, cli.fatal);
        } catch (e) {
            return cli.fatal(e);
        }
    }
    file.setEncoding(encoding);
    var lines = [], data = &#039;&#039;, eof, sep;
    file.on(&#039;data&#039;, function (chunk) {
        if (eof) return;
        data += chunk;
        if (!sep) {
            if (data.indexOf(&#039;\r\n&#039;) !== -1) {
                sep = &#039;\r\n&#039;;
            } else if (data.indexOf(&#039;\n&#039;) !== -1) {
                sep = &#039;\n&#039;;
            } else {
                last_line = data;
                return;
            }
        }
        lines = data.split(sep);
        data = eof ? null : lines.pop();
        while (lines.length) {
            callback.apply(cli, [lines.shift(), sep, false]);
        }
    });
    file.on(&#039;end&#039;, function () {
        eof = true;
        if (data.length) {
            callback.apply(cli, [data, sep || &#039;&#039;, false]);
        }
        callback.apply(cli, [null, null, true]);
    });
};

/**
 * A method for creating and controlling a daemon.
 *
 * `arg` can be:
 *      start = daemonizes the process
 *      stop  = stops the daemon if it is running
 *      restart = alias for stop -&gt; start
 *      pid = outputs the daemon&#039;s PID if it is running
 *      log = outputs the daemon&#039;s log file (stdout + stderr)
 *
 * @param {String} arg (Optional - default is &#039;start&#039;)
 * @param {Function} callback
 * @api public
 */
cli.daemon = function (arg, callback) {
    if (typeof daemon === &#039;undefined&#039;) {
        cli.fatal(&#039;Daemon is not initialized&#039;);
    }

    if (typeof arg === &#039;function&#039;) {
        callback = arg;
        arg = &#039;start&#039;;
    }

    var lock_file = &#039;/tmp/&#039; + cli.app + &#039;.pid&#039;,
        log_file = &#039;/tmp/&#039; + cli.app + &#039;.log&#039;;

    var start = function () {
        daemon.daemonize(log_file, lock_file, function (err) {
            if (err) return cli.error(&#039;Error starting daemon: &#039; + err);
            callback();
        });
    };

    var stop = function () {
        try {
            cli.native.fs.readFileSync(lock_file);
        } catch (e) {
            return cli.error(&#039;Daemon is not running&#039;);
        }
        daemon.kill(lock_file, function (err, pid) {
            if (err &amp;&amp; err.errno === 3) {
                return cli.error(&#039;Daemon is not running&#039;);
            } else if (err) {
                return cli.error(&#039;Error stopping daemon: &#039; + err.errno);
            }
            cli.ok(&#039;Successfully stopped daemon with pid: &#039; + pid);
        });
    };

    switch(arg) {
    case &#039;stop&#039;:
        stop();
        break;
    case &#039;restart&#039;:
        daemon.stop(lock_file, function () {
            start();
        });
        break;
    case &#039;log&#039;:
        try {
            cli.native.fs.createReadStream(log_file, {encoding: &#039;utf8&#039;}).pipe(process.stdout);
        } catch (e) {
            return cli.error(&#039;No daemon log file&#039;);
        }
        break;
    case &#039;pid&#039;:
        try {
            var pid = cli.native.fs.readFileSync(lock_file, &#039;utf8&#039;);
            cli.native.fs.statSync(&#039;/proc/&#039; + pid);
            cli.info(pid);
        } catch (e) {
            return cli.error(&#039;Daemon is not running&#039;);
        }
        break;
    default:
        start();
        break;
    }
}

/**
 * The main entry method. Calling cli.main() is only necessary in
 * scripts that have daemon support enabled. `callback` receives (args, options)
 *
 * @param {Function} callback
 * @api public
 */
cli.main = function (callback) {
    var after = function () {
        callback.apply(cli, [cli.args, cli.options]);
    };
    if (enable.daemon &amp;&amp; daemon_arg) {
        cli.daemon(daemon_arg, after);
    } else {
        after();
    }
}

/**
 * Bind creationix&#039;s stack (https://github.com/creationix/stack).
 *
 * Create a simple middleware stack by calling:
 *
 *     cli.createServer(middleware).listen(port);
 *
 * @return {Server} server
 * @api public
 */
cli.createServer = function(/*layers*/) {
    var defaultStackErrorHandler = function (req, res, err) {
        if (err) {
            console.error(err.stack);
            res.writeHead(500, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
            return res.end(err.stack + &quot;\n&quot;);
        }
        res.writeHead(404, {&quot;Content-Type&quot;: &quot;text/plain&quot;});
        res.end(&quot;Not Found\n&quot;);
    };
    var handle, error;
    handle = error = defaultStackErrorHandler;
    var layers = Array.prototype.slice.call(arguments);

    //Allow createServer(a,b,c) and createServer([a,b,c])
    if (layers.length &amp;&amp; layers[0] instanceof Array) {
        layers = layers[0];
    }
    layers.reverse().forEach(function (layer) {
        var child = handle;
        handle = function (req, res) {
            try {
                layer(req, res, function (err) {
                    if (err) return error(req, res, err);
                    child(req, res);
                });
            } catch (err) {
                error(req, res, err);
            }
        };
    });
    return cli.native.http.createServer(handle);
};

/**
 * A wrapper for child_process.exec().
 *
 * If the child_process exits successfully, `callback` receives an array of
 * stdout lines. The current process exits if the child process has an error
 * and `errback` isn&#039;t defined.
 *
 * @param {String} cmd
 * @param {Function} callback (optional)
 * @param {Function} errback (optional)
 * @api public
 */
cli.exec = function (cmd, callback, errback) {
    cli.native.child_process.exec(cmd, function (err, stdout, stderr) {
        err = err || stderr;
        if (err) {
            if (errback) {
                return errback(err, stdout);
            }
            return cli.fatal(&#039;exec() failed\n&#039; + err);
        }
        if (callback) {
            callback(stdout.split(&#039;\n&#039;));
        }
    });
};

/**
 * Helper method for outputting a progress bar to the console.
 *
 * @param {Number} progress (0 &lt;= progress &lt;= 1)
 * @api public
 */
var last_progress_call, progress_len = 74;
cli.progress = function (progress, decimals, stream) {
    stream = stream || process.stdout;
    if (progress &lt; 0 || progress &gt; 1 || isNaN(progress)) return;
    if (!decimals) decimals = 0;
    var now = (new Date()).getTime();
    if (last_progress_call &amp;&amp; (now - last_progress_call) &lt; 100 &amp;&amp; progress !== 1) {
        return; //Throttle progress calls
    }
    last_progress_call = now;


    var barLength = Math.floor(progress_len * progress),
        str       = &#039;&#039;;
    if (barLength == 0 &amp;&amp; progress &gt; 0) {
        barLength = 1;
    }
    for (var i = 1; i &lt;= progress_len; i++) {
        str += i &lt;= barLength ? &#039;#&#039; : &#039; &#039;;
    }
    var pwr = Math.pow(10, decimals);
    var percentage = Math.floor(progress * 100 * pwr) / pwr + &#039;%&#039;;
    for (i = 0; i &lt; decimals; i++) {
        percentage += &#039; &#039;;
    }
    stream.clearLine();
    stream.write(&#039;[&#039; + str + &#039;] &#039; +  percentage);
    if (progress === 1) {
        stream.write(&#039;\n&#039;);
    } else {
        stream.cursorTo(0);
    }
};

/**
 * Helper method for outputting a spinner to the console.
 *
 * @param {String|Boolean} prefix (optional)
 * @api public
 */
var spinnerInterval;
cli.spinner = function (prefix, end, stream) {
    stream = stream || process.stdout;
    if (end) {
        stream.clearLine();
        stream.cursorTo(0);
        stream.write(prefix + &#039;\n&#039;);
        return clearInterval(spinnerInterval);
    }
    prefix = prefix + &#039; &#039; || &#039;&#039;;
    var spinner = [&#039;-&#039;,&#039;\\&#039;,&#039;|&#039;,&#039;/&#039;], i = 0, l = spinner.length;
    spinnerInterval = setInterval(function () {
        stream.clearLine();
        stream.cursorTo(0);
        stream.write(prefix + spinner[i++]);
        if (i == l) i = 0;
    }, 200);
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
