<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/coffee-script/lib/coffee-script/grammar.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/coffee-script/lib/coffee-script/grammar.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">80.02</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">605</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">37.70</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">7.14</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Generated by CoffeeScript 1.3.3
(function() {
  var Parser, alt, alternatives, grammar, name, o, operators, token, tokens, unwrap;

  Parser = require(&#039;jison&#039;).Parser;

  unwrap = /^function\s*\(\)\s*\{\s*return\s*([\s\S]*);\s*\}/;

  o = function(patternString, action, options) {
    var match;
    patternString = patternString.replace(/\s{2,}/g, &#039; &#039;);
    if (!action) {
      return [patternString, &#039;$$ = $1;&#039;, options];
    }
    action = (match = unwrap.exec(action)) ? match[1] : &quot;(&quot; + action + &quot;())&quot;;
    action = action.replace(/\bnew /g, &#039;$&amp;yy.&#039;);
    action = action.replace(/\b(?:Block\.wrap|extend)\b/g, &#039;yy.$&amp;&#039;);
    return [patternString, &quot;$$ = &quot; + action + &quot;;&quot;, options];
  };

  grammar = {
    Root: [
      o(&#039;&#039;, function() {
        return new Block;
      }), o(&#039;Body&#039;), o(&#039;Block TERMINATOR&#039;)
    ],
    Body: [
      o(&#039;Line&#039;, function() {
        return Block.wrap([$1]);
      }), o(&#039;Body TERMINATOR Line&#039;, function() {
        return $1.push($3);
      }), o(&#039;Body TERMINATOR&#039;)
    ],
    Line: [o(&#039;Expression&#039;), o(&#039;Statement&#039;)],
    Statement: [
      o(&#039;Return&#039;), o(&#039;Comment&#039;), o(&#039;STATEMENT&#039;, function() {
        return new Literal($1);
      })
    ],
    Expression: [o(&#039;Value&#039;), o(&#039;Invocation&#039;), o(&#039;Code&#039;), o(&#039;Operation&#039;), o(&#039;Assign&#039;), o(&#039;If&#039;), o(&#039;Try&#039;), o(&#039;While&#039;), o(&#039;For&#039;), o(&#039;Switch&#039;), o(&#039;Class&#039;), o(&#039;Throw&#039;)],
    Block: [
      o(&#039;INDENT OUTDENT&#039;, function() {
        return new Block;
      }), o(&#039;INDENT Body OUTDENT&#039;, function() {
        return $2;
      })
    ],
    Identifier: [
      o(&#039;IDENTIFIER&#039;, function() {
        return new Literal($1);
      })
    ],
    AlphaNumeric: [
      o(&#039;NUMBER&#039;, function() {
        return new Literal($1);
      }), o(&#039;STRING&#039;, function() {
        return new Literal($1);
      })
    ],
    Literal: [
      o(&#039;AlphaNumeric&#039;), o(&#039;JS&#039;, function() {
        return new Literal($1);
      }), o(&#039;REGEX&#039;, function() {
        return new Literal($1);
      }), o(&#039;DEBUGGER&#039;, function() {
        return new Literal($1);
      }), o(&#039;UNDEFINED&#039;, function() {
        return new Undefined;
      }), o(&#039;NULL&#039;, function() {
        return new Null;
      }), o(&#039;BOOL&#039;, function() {
        return new Bool($1);
      })
    ],
    Assign: [
      o(&#039;Assignable = Expression&#039;, function() {
        return new Assign($1, $3);
      }), o(&#039;Assignable = TERMINATOR Expression&#039;, function() {
        return new Assign($1, $4);
      }), o(&#039;Assignable = INDENT Expression OUTDENT&#039;, function() {
        return new Assign($1, $4);
      })
    ],
    AssignObj: [
      o(&#039;ObjAssignable&#039;, function() {
        return new Value($1);
      }), o(&#039;ObjAssignable : Expression&#039;, function() {
        return new Assign(new Value($1), $3, &#039;object&#039;);
      }), o(&#039;ObjAssignable :\
       INDENT Expression OUTDENT&#039;, function() {
        return new Assign(new Value($1), $4, &#039;object&#039;);
      }), o(&#039;Comment&#039;)
    ],
    ObjAssignable: [o(&#039;Identifier&#039;), o(&#039;AlphaNumeric&#039;), o(&#039;ThisProperty&#039;)],
    Return: [
      o(&#039;RETURN Expression&#039;, function() {
        return new Return($2);
      }), o(&#039;RETURN&#039;, function() {
        return new Return;
      })
    ],
    Comment: [
      o(&#039;HERECOMMENT&#039;, function() {
        return new Comment($1);
      })
    ],
    Code: [
      o(&#039;PARAM_START ParamList PARAM_END FuncGlyph Block&#039;, function() {
        return new Code($2, $5, $4);
      }), o(&#039;FuncGlyph Block&#039;, function() {
        return new Code([], $2, $1);
      })
    ],
    FuncGlyph: [
      o(&#039;-&gt;&#039;, function() {
        return &#039;func&#039;;
      }), o(&#039;=&gt;&#039;, function() {
        return &#039;boundfunc&#039;;
      })
    ],
    OptComma: [o(&#039;&#039;), o(&#039;,&#039;)],
    ParamList: [
      o(&#039;&#039;, function() {
        return [];
      }), o(&#039;Param&#039;, function() {
        return [$1];
      }), o(&#039;ParamList , Param&#039;, function() {
        return $1.concat($3);
      }), o(&#039;ParamList OptComma TERMINATOR Param&#039;, function() {
        return $1.concat($4);
      }), o(&#039;ParamList OptComma INDENT ParamList OptComma OUTDENT&#039;, function() {
        return $1.concat($4);
      })
    ],
    Param: [
      o(&#039;ParamVar&#039;, function() {
        return new Param($1);
      }), o(&#039;ParamVar ...&#039;, function() {
        return new Param($1, null, true);
      }), o(&#039;ParamVar = Expression&#039;, function() {
        return new Param($1, $3);
      })
    ],
    ParamVar: [o(&#039;Identifier&#039;), o(&#039;ThisProperty&#039;), o(&#039;Array&#039;), o(&#039;Object&#039;)],
    Splat: [
      o(&#039;Expression ...&#039;, function() {
        return new Splat($1);
      })
    ],
    SimpleAssignable: [
      o(&#039;Identifier&#039;, function() {
        return new Value($1);
      }), o(&#039;Value Accessor&#039;, function() {
        return $1.add($2);
      }), o(&#039;Invocation Accessor&#039;, function() {
        return new Value($1, [].concat($2));
      }), o(&#039;ThisProperty&#039;)
    ],
    Assignable: [
      o(&#039;SimpleAssignable&#039;), o(&#039;Array&#039;, function() {
        return new Value($1);
      }), o(&#039;Object&#039;, function() {
        return new Value($1);
      })
    ],
    Value: [
      o(&#039;Assignable&#039;), o(&#039;Literal&#039;, function() {
        return new Value($1);
      }), o(&#039;Parenthetical&#039;, function() {
        return new Value($1);
      }), o(&#039;Range&#039;, function() {
        return new Value($1);
      }), o(&#039;This&#039;)
    ],
    Accessor: [
      o(&#039;.  Identifier&#039;, function() {
        return new Access($2);
      }), o(&#039;?. Identifier&#039;, function() {
        return new Access($2, &#039;soak&#039;);
      }), o(&#039;:: Identifier&#039;, function() {
        return [new Access(new Literal(&#039;prototype&#039;)), new Access($2)];
      }), o(&#039;::&#039;, function() {
        return new Access(new Literal(&#039;prototype&#039;));
      }), o(&#039;Index&#039;)
    ],
    Index: [
      o(&#039;INDEX_START IndexValue INDEX_END&#039;, function() {
        return $2;
      }), o(&#039;INDEX_SOAK  Index&#039;, function() {
        return extend($2, {
          soak: true
        });
      })
    ],
    IndexValue: [
      o(&#039;Expression&#039;, function() {
        return new Index($1);
      }), o(&#039;Slice&#039;, function() {
        return new Slice($1);
      })
    ],
    Object: [
      o(&#039;{ AssignList OptComma }&#039;, function() {
        return new Obj($2, $1.generated);
      })
    ],
    AssignList: [
      o(&#039;&#039;, function() {
        return [];
      }), o(&#039;AssignObj&#039;, function() {
        return [$1];
      }), o(&#039;AssignList , AssignObj&#039;, function() {
        return $1.concat($3);
      }), o(&#039;AssignList OptComma TERMINATOR AssignObj&#039;, function() {
        return $1.concat($4);
      }), o(&#039;AssignList OptComma INDENT AssignList OptComma OUTDENT&#039;, function() {
        return $1.concat($4);
      })
    ],
    Class: [
      o(&#039;CLASS&#039;, function() {
        return new Class;
      }), o(&#039;CLASS Block&#039;, function() {
        return new Class(null, null, $2);
      }), o(&#039;CLASS EXTENDS Expression&#039;, function() {
        return new Class(null, $3);
      }), o(&#039;CLASS EXTENDS Expression Block&#039;, function() {
        return new Class(null, $3, $4);
      }), o(&#039;CLASS SimpleAssignable&#039;, function() {
        return new Class($2);
      }), o(&#039;CLASS SimpleAssignable Block&#039;, function() {
        return new Class($2, null, $3);
      }), o(&#039;CLASS SimpleAssignable EXTENDS Expression&#039;, function() {
        return new Class($2, $4);
      }), o(&#039;CLASS SimpleAssignable EXTENDS Expression Block&#039;, function() {
        return new Class($2, $4, $5);
      })
    ],
    Invocation: [
      o(&#039;Value OptFuncExist Arguments&#039;, function() {
        return new Call($1, $3, $2);
      }), o(&#039;Invocation OptFuncExist Arguments&#039;, function() {
        return new Call($1, $3, $2);
      }), o(&#039;SUPER&#039;, function() {
        return new Call(&#039;super&#039;, [new Splat(new Literal(&#039;arguments&#039;))]);
      }), o(&#039;SUPER Arguments&#039;, function() {
        return new Call(&#039;super&#039;, $2);
      })
    ],
    OptFuncExist: [
      o(&#039;&#039;, function() {
        return false;
      }), o(&#039;FUNC_EXIST&#039;, function() {
        return true;
      })
    ],
    Arguments: [
      o(&#039;CALL_START CALL_END&#039;, function() {
        return [];
      }), o(&#039;CALL_START ArgList OptComma CALL_END&#039;, function() {
        return $2;
      })
    ],
    This: [
      o(&#039;THIS&#039;, function() {
        return new Value(new Literal(&#039;this&#039;));
      }), o(&#039;@&#039;, function() {
        return new Value(new Literal(&#039;this&#039;));
      })
    ],
    ThisProperty: [
      o(&#039;@ Identifier&#039;, function() {
        return new Value(new Literal(&#039;this&#039;), [new Access($2)], &#039;this&#039;);
      })
    ],
    Array: [
      o(&#039;[ ]&#039;, function() {
        return new Arr([]);
      }), o(&#039;[ ArgList OptComma ]&#039;, function() {
        return new Arr($2);
      })
    ],
    RangeDots: [
      o(&#039;..&#039;, function() {
        return &#039;inclusive&#039;;
      }), o(&#039;...&#039;, function() {
        return &#039;exclusive&#039;;
      })
    ],
    Range: [
      o(&#039;[ Expression RangeDots Expression ]&#039;, function() {
        return new Range($2, $4, $3);
      })
    ],
    Slice: [
      o(&#039;Expression RangeDots Expression&#039;, function() {
        return new Range($1, $3, $2);
      }), o(&#039;Expression RangeDots&#039;, function() {
        return new Range($1, null, $2);
      }), o(&#039;RangeDots Expression&#039;, function() {
        return new Range(null, $2, $1);
      }), o(&#039;RangeDots&#039;, function() {
        return new Range(null, null, $1);
      })
    ],
    ArgList: [
      o(&#039;Arg&#039;, function() {
        return [$1];
      }), o(&#039;ArgList , Arg&#039;, function() {
        return $1.concat($3);
      }), o(&#039;ArgList OptComma TERMINATOR Arg&#039;, function() {
        return $1.concat($4);
      }), o(&#039;INDENT ArgList OptComma OUTDENT&#039;, function() {
        return $2;
      }), o(&#039;ArgList OptComma INDENT ArgList OptComma OUTDENT&#039;, function() {
        return $1.concat($4);
      })
    ],
    Arg: [o(&#039;Expression&#039;), o(&#039;Splat&#039;)],
    SimpleArgs: [
      o(&#039;Expression&#039;), o(&#039;SimpleArgs , Expression&#039;, function() {
        return [].concat($1, $3);
      })
    ],
    Try: [
      o(&#039;TRY Block&#039;, function() {
        return new Try($2);
      }), o(&#039;TRY Block Catch&#039;, function() {
        return new Try($2, $3[0], $3[1]);
      }), o(&#039;TRY Block FINALLY Block&#039;, function() {
        return new Try($2, null, null, $4);
      }), o(&#039;TRY Block Catch FINALLY Block&#039;, function() {
        return new Try($2, $3[0], $3[1], $5);
      })
    ],
    Catch: [
      o(&#039;CATCH Identifier Block&#039;, function() {
        return [$2, $3];
      })
    ],
    Throw: [
      o(&#039;THROW Expression&#039;, function() {
        return new Throw($2);
      })
    ],
    Parenthetical: [
      o(&#039;( Body )&#039;, function() {
        return new Parens($2);
      }), o(&#039;( INDENT Body OUTDENT )&#039;, function() {
        return new Parens($3);
      })
    ],
    WhileSource: [
      o(&#039;WHILE Expression&#039;, function() {
        return new While($2);
      }), o(&#039;WHILE Expression WHEN Expression&#039;, function() {
        return new While($2, {
          guard: $4
        });
      }), o(&#039;UNTIL Expression&#039;, function() {
        return new While($2, {
          invert: true
        });
      }), o(&#039;UNTIL Expression WHEN Expression&#039;, function() {
        return new While($2, {
          invert: true,
          guard: $4
        });
      })
    ],
    While: [
      o(&#039;WhileSource Block&#039;, function() {
        return $1.addBody($2);
      }), o(&#039;Statement  WhileSource&#039;, function() {
        return $2.addBody(Block.wrap([$1]));
      }), o(&#039;Expression WhileSource&#039;, function() {
        return $2.addBody(Block.wrap([$1]));
      }), o(&#039;Loop&#039;, function() {
        return $1;
      })
    ],
    Loop: [
      o(&#039;LOOP Block&#039;, function() {
        return new While(new Literal(&#039;true&#039;)).addBody($2);
      }), o(&#039;LOOP Expression&#039;, function() {
        return new While(new Literal(&#039;true&#039;)).addBody(Block.wrap([$2]));
      })
    ],
    For: [
      o(&#039;Statement  ForBody&#039;, function() {
        return new For($1, $2);
      }), o(&#039;Expression ForBody&#039;, function() {
        return new For($1, $2);
      }), o(&#039;ForBody    Block&#039;, function() {
        return new For($2, $1);
      })
    ],
    ForBody: [
      o(&#039;FOR Range&#039;, function() {
        return {
          source: new Value($2)
        };
      }), o(&#039;ForStart ForSource&#039;, function() {
        $2.own = $1.own;
        $2.name = $1[0];
        $2.index = $1[1];
        return $2;
      })
    ],
    ForStart: [
      o(&#039;FOR ForVariables&#039;, function() {
        return $2;
      }), o(&#039;FOR OWN ForVariables&#039;, function() {
        $3.own = true;
        return $3;
      })
    ],
    ForValue: [
      o(&#039;Identifier&#039;), o(&#039;ThisProperty&#039;), o(&#039;Array&#039;, function() {
        return new Value($1);
      }), o(&#039;Object&#039;, function() {
        return new Value($1);
      })
    ],
    ForVariables: [
      o(&#039;ForValue&#039;, function() {
        return [$1];
      }), o(&#039;ForValue , ForValue&#039;, function() {
        return [$1, $3];
      })
    ],
    ForSource: [
      o(&#039;FORIN Expression&#039;, function() {
        return {
          source: $2
        };
      }), o(&#039;FOROF Expression&#039;, function() {
        return {
          source: $2,
          object: true
        };
      }), o(&#039;FORIN Expression WHEN Expression&#039;, function() {
        return {
          source: $2,
          guard: $4
        };
      }), o(&#039;FOROF Expression WHEN Expression&#039;, function() {
        return {
          source: $2,
          guard: $4,
          object: true
        };
      }), o(&#039;FORIN Expression BY Expression&#039;, function() {
        return {
          source: $2,
          step: $4
        };
      }), o(&#039;FORIN Expression WHEN Expression BY Expression&#039;, function() {
        return {
          source: $2,
          guard: $4,
          step: $6
        };
      }), o(&#039;FORIN Expression BY Expression WHEN Expression&#039;, function() {
        return {
          source: $2,
          step: $4,
          guard: $6
        };
      })
    ],
    Switch: [
      o(&#039;SWITCH Expression INDENT Whens OUTDENT&#039;, function() {
        return new Switch($2, $4);
      }), o(&#039;SWITCH Expression INDENT Whens ELSE Block OUTDENT&#039;, function() {
        return new Switch($2, $4, $6);
      }), o(&#039;SWITCH INDENT Whens OUTDENT&#039;, function() {
        return new Switch(null, $3);
      }), o(&#039;SWITCH INDENT Whens ELSE Block OUTDENT&#039;, function() {
        return new Switch(null, $3, $5);
      })
    ],
    Whens: [
      o(&#039;When&#039;), o(&#039;Whens When&#039;, function() {
        return $1.concat($2);
      })
    ],
    When: [
      o(&#039;LEADING_WHEN SimpleArgs Block&#039;, function() {
        return [[$2, $3]];
      }), o(&#039;LEADING_WHEN SimpleArgs Block TERMINATOR&#039;, function() {
        return [[$2, $3]];
      })
    ],
    IfBlock: [
      o(&#039;IF Expression Block&#039;, function() {
        return new If($2, $3, {
          type: $1
        });
      }), o(&#039;IfBlock ELSE IF Expression Block&#039;, function() {
        return $1.addElse(new If($4, $5, {
          type: $3
        }));
      })
    ],
    If: [
      o(&#039;IfBlock&#039;), o(&#039;IfBlock ELSE Block&#039;, function() {
        return $1.addElse($3);
      }), o(&#039;Statement  POST_IF Expression&#039;, function() {
        return new If($3, Block.wrap([$1]), {
          type: $2,
          statement: true
        });
      }), o(&#039;Expression POST_IF Expression&#039;, function() {
        return new If($3, Block.wrap([$1]), {
          type: $2,
          statement: true
        });
      })
    ],
    Operation: [
      o(&#039;UNARY Expression&#039;, function() {
        return new Op($1, $2);
      }), o(&#039;-     Expression&#039;, (function() {
        return new Op(&#039;-&#039;, $2);
      }), {
        prec: &#039;UNARY&#039;
      }), o(&#039;+     Expression&#039;, (function() {
        return new Op(&#039;+&#039;, $2);
      }), {
        prec: &#039;UNARY&#039;
      }), o(&#039;-- SimpleAssignable&#039;, function() {
        return new Op(&#039;--&#039;, $2);
      }), o(&#039;++ SimpleAssignable&#039;, function() {
        return new Op(&#039;++&#039;, $2);
      }), o(&#039;SimpleAssignable --&#039;, function() {
        return new Op(&#039;--&#039;, $1, null, true);
      }), o(&#039;SimpleAssignable ++&#039;, function() {
        return new Op(&#039;++&#039;, $1, null, true);
      }), o(&#039;Expression ?&#039;, function() {
        return new Existence($1);
      }), o(&#039;Expression +  Expression&#039;, function() {
        return new Op(&#039;+&#039;, $1, $3);
      }), o(&#039;Expression -  Expression&#039;, function() {
        return new Op(&#039;-&#039;, $1, $3);
      }), o(&#039;Expression MATH     Expression&#039;, function() {
        return new Op($2, $1, $3);
      }), o(&#039;Expression SHIFT    Expression&#039;, function() {
        return new Op($2, $1, $3);
      }), o(&#039;Expression COMPARE  Expression&#039;, function() {
        return new Op($2, $1, $3);
      }), o(&#039;Expression LOGIC    Expression&#039;, function() {
        return new Op($2, $1, $3);
      }), o(&#039;Expression RELATION Expression&#039;, function() {
        if ($2.charAt(0) === &#039;!&#039;) {
          return new Op($2.slice(1), $1, $3).invert();
        } else {
          return new Op($2, $1, $3);
        }
      }), o(&#039;SimpleAssignable COMPOUND_ASSIGN\
       Expression&#039;, function() {
        return new Assign($1, $3, $2);
      }), o(&#039;SimpleAssignable COMPOUND_ASSIGN\
       INDENT Expression OUTDENT&#039;, function() {
        return new Assign($1, $4, $2);
      }), o(&#039;SimpleAssignable EXTENDS Expression&#039;, function() {
        return new Extends($1, $3);
      })
    ]
  };

  operators = [[&#039;left&#039;, &#039;.&#039;, &#039;?.&#039;, &#039;::&#039;], [&#039;left&#039;, &#039;CALL_START&#039;, &#039;CALL_END&#039;], [&#039;nonassoc&#039;, &#039;++&#039;, &#039;--&#039;], [&#039;left&#039;, &#039;?&#039;], [&#039;right&#039;, &#039;UNARY&#039;], [&#039;left&#039;, &#039;MATH&#039;], [&#039;left&#039;, &#039;+&#039;, &#039;-&#039;], [&#039;left&#039;, &#039;SHIFT&#039;], [&#039;left&#039;, &#039;RELATION&#039;], [&#039;left&#039;, &#039;COMPARE&#039;], [&#039;left&#039;, &#039;LOGIC&#039;], [&#039;nonassoc&#039;, &#039;INDENT&#039;, &#039;OUTDENT&#039;], [&#039;right&#039;, &#039;=&#039;, &#039;:&#039;, &#039;COMPOUND_ASSIGN&#039;, &#039;RETURN&#039;, &#039;THROW&#039;, &#039;EXTENDS&#039;], [&#039;right&#039;, &#039;FORIN&#039;, &#039;FOROF&#039;, &#039;BY&#039;, &#039;WHEN&#039;], [&#039;right&#039;, &#039;IF&#039;, &#039;ELSE&#039;, &#039;FOR&#039;, &#039;WHILE&#039;, &#039;UNTIL&#039;, &#039;LOOP&#039;, &#039;SUPER&#039;, &#039;CLASS&#039;], [&#039;right&#039;, &#039;POST_IF&#039;]];

  tokens = [];

  for (name in grammar) {
    alternatives = grammar[name];
    grammar[name] = (function() {
      var _i, _j, _len, _len1, _ref, _results;
      _results = [];
      for (_i = 0, _len = alternatives.length; _i &lt; _len; _i++) {
        alt = alternatives[_i];
        _ref = alt[0].split(&#039; &#039;);
        for (_j = 0, _len1 = _ref.length; _j &lt; _len1; _j++) {
          token = _ref[_j];
          if (!grammar[token]) {
            tokens.push(token);
          }
        }
        if (name === &#039;Root&#039;) {
          alt[1] = &quot;return &quot; + alt[1];
        }
        _results.push(alt);
      }
      return _results;
    })();
  }

  exports.parser = new Parser({
    tokens: tokens.join(&#039; &#039;),
    bnf: grammar,
    operators: operators.reverse(),
    startSymbol: &#039;Root&#039;
  });

}).call(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
