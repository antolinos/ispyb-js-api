<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/coffee-script/lib/coffee-script/lexer.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/coffee-script/lib/coffee-script/lexer.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">51.86</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">787</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">112.02</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">11.77</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Generated by CoffeeScript 1.3.3
(function() {
  var BOOL, CALLABLE, CODE, COFFEE_ALIASES, COFFEE_ALIAS_MAP, COFFEE_KEYWORDS, COMMENT, COMPARE, COMPOUND_ASSIGN, HEREDOC, HEREDOC_ILLEGAL, HEREDOC_INDENT, HEREGEX, HEREGEX_OMIT, IDENTIFIER, INDEXABLE, INVERSES, JSTOKEN, JS_FORBIDDEN, JS_KEYWORDS, LINE_BREAK, LINE_CONTINUER, LOGIC, Lexer, MATH, MULTILINER, MULTI_DENT, NOT_REGEX, NOT_SPACED_REGEX, NUMBER, OPERATOR, REGEX, RELATION, RESERVED, Rewriter, SHIFT, SIMPLESTR, STRICT_PROSCRIBED, TRAILING_SPACES, UNARY, WHITESPACE, compact, count, key, last, starts, _ref, _ref1,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; };

  _ref = require(&#039;./rewriter&#039;), Rewriter = _ref.Rewriter, INVERSES = _ref.INVERSES;

  _ref1 = require(&#039;./helpers&#039;), count = _ref1.count, starts = _ref1.starts, compact = _ref1.compact, last = _ref1.last;

  exports.Lexer = Lexer = (function() {

    function Lexer() {}

    Lexer.prototype.tokenize = function(code, opts) {
      var i, tag;
      if (opts == null) {
        opts = {};
      }
      if (WHITESPACE.test(code)) {
        code = &quot;\n&quot; + code;
      }
      code = code.replace(/\r/g, &#039;&#039;).replace(TRAILING_SPACES, &#039;&#039;);
      this.code = code;
      this.line = opts.line || 0;
      this.indent = 0;
      this.indebt = 0;
      this.outdebt = 0;
      this.indents = [];
      this.ends = [];
      this.tokens = [];
      i = 0;
      while (this.chunk = code.slice(i)) {
        i += this.identifierToken() || this.commentToken() || this.whitespaceToken() || this.lineToken() || this.heredocToken() || this.stringToken() || this.numberToken() || this.regexToken() || this.jsToken() || this.literalToken();
      }
      this.closeIndentation();
      if (tag = this.ends.pop()) {
        this.error(&quot;missing &quot; + tag);
      }
      if (opts.rewrite === false) {
        return this.tokens;
      }
      return (new Rewriter).rewrite(this.tokens);
    };

    Lexer.prototype.identifierToken = function() {
      var colon, forcedIdentifier, id, input, match, prev, tag, _ref2, _ref3;
      if (!(match = IDENTIFIER.exec(this.chunk))) {
        return 0;
      }
      input = match[0], id = match[1], colon = match[2];
      if (id === &#039;own&#039; &amp;&amp; this.tag() === &#039;FOR&#039;) {
        this.token(&#039;OWN&#039;, id);
        return id.length;
      }
      forcedIdentifier = colon || (prev = last(this.tokens)) &amp;&amp; (((_ref2 = prev[0]) === &#039;.&#039; || _ref2 === &#039;?.&#039; || _ref2 === &#039;::&#039;) || !prev.spaced &amp;&amp; prev[0] === &#039;@&#039;);
      tag = &#039;IDENTIFIER&#039;;
      if (!forcedIdentifier &amp;&amp; (__indexOf.call(JS_KEYWORDS, id) &gt;= 0 || __indexOf.call(COFFEE_KEYWORDS, id) &gt;= 0)) {
        tag = id.toUpperCase();
        if (tag === &#039;WHEN&#039; &amp;&amp; (_ref3 = this.tag(), __indexOf.call(LINE_BREAK, _ref3) &gt;= 0)) {
          tag = &#039;LEADING_WHEN&#039;;
        } else if (tag === &#039;FOR&#039;) {
          this.seenFor = true;
        } else if (tag === &#039;UNLESS&#039;) {
          tag = &#039;IF&#039;;
        } else if (__indexOf.call(UNARY, tag) &gt;= 0) {
          tag = &#039;UNARY&#039;;
        } else if (__indexOf.call(RELATION, tag) &gt;= 0) {
          if (tag !== &#039;INSTANCEOF&#039; &amp;&amp; this.seenFor) {
            tag = &#039;FOR&#039; + tag;
            this.seenFor = false;
          } else {
            tag = &#039;RELATION&#039;;
            if (this.value() === &#039;!&#039;) {
              this.tokens.pop();
              id = &#039;!&#039; + id;
            }
          }
        }
      }
      if (__indexOf.call(JS_FORBIDDEN, id) &gt;= 0) {
        if (forcedIdentifier) {
          tag = &#039;IDENTIFIER&#039;;
          id = new String(id);
          id.reserved = true;
        } else if (__indexOf.call(RESERVED, id) &gt;= 0) {
          this.error(&quot;reserved word \&quot;&quot; + id + &quot;\&quot;&quot;);
        }
      }
      if (!forcedIdentifier) {
        if (__indexOf.call(COFFEE_ALIASES, id) &gt;= 0) {
          id = COFFEE_ALIAS_MAP[id];
        }
        tag = (function() {
          switch (id) {
            case &#039;!&#039;:
              return &#039;UNARY&#039;;
            case &#039;==&#039;:
            case &#039;!=&#039;:
              return &#039;COMPARE&#039;;
            case &#039;&amp;&amp;&#039;:
            case &#039;||&#039;:
              return &#039;LOGIC&#039;;
            case &#039;true&#039;:
            case &#039;false&#039;:
              return &#039;BOOL&#039;;
            case &#039;break&#039;:
            case &#039;continue&#039;:
              return &#039;STATEMENT&#039;;
            default:
              return tag;
          }
        })();
      }
      this.token(tag, id);
      if (colon) {
        this.token(&#039;:&#039;, &#039;:&#039;);
      }
      return input.length;
    };

    Lexer.prototype.numberToken = function() {
      var binaryLiteral, lexedLength, match, number, octalLiteral;
      if (!(match = NUMBER.exec(this.chunk))) {
        return 0;
      }
      number = match[0];
      if (/^0[BOX]/.test(number)) {
        this.error(&quot;radix prefix &#039;&quot; + number + &quot;&#039; must be lowercase&quot;);
      } else if (/E/.test(number) &amp;&amp; !/^0x/.test(number)) {
        this.error(&quot;exponential notation &#039;&quot; + number + &quot;&#039; must be indicated with a lowercase &#039;e&#039;&quot;);
      } else if (/^0\d*[89]/.test(number)) {
        this.error(&quot;decimal literal &#039;&quot; + number + &quot;&#039; must not be prefixed with &#039;0&#039;&quot;);
      } else if (/^0\d+/.test(number)) {
        this.error(&quot;octal literal &#039;&quot; + number + &quot;&#039; must be prefixed with &#039;0o&#039;&quot;);
      }
      lexedLength = number.length;
      if (octalLiteral = /^0o([0-7]+)/.exec(number)) {
        number = &#039;0x&#039; + (parseInt(octalLiteral[1], 8)).toString(16);
      }
      if (binaryLiteral = /^0b([01]+)/.exec(number)) {
        number = &#039;0x&#039; + (parseInt(binaryLiteral[1], 2)).toString(16);
      }
      this.token(&#039;NUMBER&#039;, number);
      return lexedLength;
    };

    Lexer.prototype.stringToken = function() {
      var match, octalEsc, string;
      switch (this.chunk.charAt(0)) {
        case &quot;&#039;&quot;:
          if (!(match = SIMPLESTR.exec(this.chunk))) {
            return 0;
          }
          this.token(&#039;STRING&#039;, (string = match[0]).replace(MULTILINER, &#039;\\\n&#039;));
          break;
        case &#039;&quot;&#039;:
          if (!(string = this.balancedString(this.chunk, &#039;&quot;&#039;))) {
            return 0;
          }
          if (0 &lt; string.indexOf(&#039;#{&#039;, 1)) {
            this.interpolateString(string.slice(1, -1));
          } else {
            this.token(&#039;STRING&#039;, this.escapeLines(string));
          }
          break;
        default:
          return 0;
      }
      if (octalEsc = /^(?:\\.|[^\\])*\\(?:0[0-7]|[1-7])/.test(string)) {
        this.error(&quot;octal escape sequences &quot; + string + &quot; are not allowed&quot;);
      }
      this.line += count(string, &#039;\n&#039;);
      return string.length;
    };

    Lexer.prototype.heredocToken = function() {
      var doc, heredoc, match, quote;
      if (!(match = HEREDOC.exec(this.chunk))) {
        return 0;
      }
      heredoc = match[0];
      quote = heredoc.charAt(0);
      doc = this.sanitizeHeredoc(match[2], {
        quote: quote,
        indent: null
      });
      if (quote === &#039;&quot;&#039; &amp;&amp; 0 &lt;= doc.indexOf(&#039;#{&#039;)) {
        this.interpolateString(doc, {
          heredoc: true
        });
      } else {
        this.token(&#039;STRING&#039;, this.makeString(doc, quote, true));
      }
      this.line += count(heredoc, &#039;\n&#039;);
      return heredoc.length;
    };

    Lexer.prototype.commentToken = function() {
      var comment, here, match;
      if (!(match = this.chunk.match(COMMENT))) {
        return 0;
      }
      comment = match[0], here = match[1];
      if (here) {
        this.token(&#039;HERECOMMENT&#039;, this.sanitizeHeredoc(here, {
          herecomment: true,
          indent: Array(this.indent + 1).join(&#039; &#039;)
        }));
      }
      this.line += count(comment, &#039;\n&#039;);
      return comment.length;
    };

    Lexer.prototype.jsToken = function() {
      var match, script;
      if (!(this.chunk.charAt(0) === &#039;`&#039; &amp;&amp; (match = JSTOKEN.exec(this.chunk)))) {
        return 0;
      }
      this.token(&#039;JS&#039;, (script = match[0]).slice(1, -1));
      return script.length;
    };

    Lexer.prototype.regexToken = function() {
      var flags, length, match, prev, regex, _ref2, _ref3;
      if (this.chunk.charAt(0) !== &#039;/&#039;) {
        return 0;
      }
      if (match = HEREGEX.exec(this.chunk)) {
        length = this.heregexToken(match);
        this.line += count(match[0], &#039;\n&#039;);
        return length;
      }
      prev = last(this.tokens);
      if (prev &amp;&amp; (_ref2 = prev[0], __indexOf.call((prev.spaced ? NOT_REGEX : NOT_SPACED_REGEX), _ref2) &gt;= 0)) {
        return 0;
      }
      if (!(match = REGEX.exec(this.chunk))) {
        return 0;
      }
      _ref3 = match, match = _ref3[0], regex = _ref3[1], flags = _ref3[2];
      if (regex.slice(0, 2) === &#039;/*&#039;) {
        this.error(&#039;regular expressions cannot begin with `*`&#039;);
      }
      if (regex === &#039;//&#039;) {
        regex = &#039;/(?:)/&#039;;
      }
      this.token(&#039;REGEX&#039;, &quot;&quot; + regex + flags);
      return match.length;
    };

    Lexer.prototype.heregexToken = function(match) {
      var body, flags, heregex, re, tag, tokens, value, _i, _len, _ref2, _ref3, _ref4, _ref5;
      heregex = match[0], body = match[1], flags = match[2];
      if (0 &gt; body.indexOf(&#039;#{&#039;)) {
        re = body.replace(HEREGEX_OMIT, &#039;&#039;).replace(/\//g, &#039;\\/&#039;);
        if (re.match(/^\*/)) {
          this.error(&#039;regular expressions cannot begin with `*`&#039;);
        }
        this.token(&#039;REGEX&#039;, &quot;/&quot; + (re || &#039;(?:)&#039;) + &quot;/&quot; + flags);
        return heregex.length;
      }
      this.token(&#039;IDENTIFIER&#039;, &#039;RegExp&#039;);
      this.tokens.push([&#039;CALL_START&#039;, &#039;(&#039;]);
      tokens = [];
      _ref2 = this.interpolateString(body, {
        regex: true
      });
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        _ref3 = _ref2[_i], tag = _ref3[0], value = _ref3[1];
        if (tag === &#039;TOKENS&#039;) {
          tokens.push.apply(tokens, value);
        } else {
          if (!(value = value.replace(HEREGEX_OMIT, &#039;&#039;))) {
            continue;
          }
          value = value.replace(/\\/g, &#039;\\\\&#039;);
          tokens.push([&#039;STRING&#039;, this.makeString(value, &#039;&quot;&#039;, true)]);
        }
        tokens.push([&#039;+&#039;, &#039;+&#039;]);
      }
      tokens.pop();
      if (((_ref4 = tokens[0]) != null ? _ref4[0] : void 0) !== &#039;STRING&#039;) {
        this.tokens.push([&#039;STRING&#039;, &#039;&quot;&quot;&#039;], [&#039;+&#039;, &#039;+&#039;]);
      }
      (_ref5 = this.tokens).push.apply(_ref5, tokens);
      if (flags) {
        this.tokens.push([&#039;,&#039;, &#039;,&#039;], [&#039;STRING&#039;, &#039;&quot;&#039; + flags + &#039;&quot;&#039;]);
      }
      this.token(&#039;)&#039;, &#039;)&#039;);
      return heregex.length;
    };

    Lexer.prototype.lineToken = function() {
      var diff, indent, match, noNewlines, prev, size;
      if (!(match = MULTI_DENT.exec(this.chunk))) {
        return 0;
      }
      indent = match[0];
      this.line += count(indent, &#039;\n&#039;);
      this.seenFor = false;
      prev = last(this.tokens, 1);
      size = indent.length - 1 - indent.lastIndexOf(&#039;\n&#039;);
      noNewlines = this.unfinished();
      if (size - this.indebt === this.indent) {
        if (noNewlines) {
          this.suppressNewlines();
        } else {
          this.newlineToken();
        }
        return indent.length;
      }
      if (size &gt; this.indent) {
        if (noNewlines) {
          this.indebt = size - this.indent;
          this.suppressNewlines();
          return indent.length;
        }
        diff = size - this.indent + this.outdebt;
        this.token(&#039;INDENT&#039;, diff);
        this.indents.push(diff);
        this.ends.push(&#039;OUTDENT&#039;);
        this.outdebt = this.indebt = 0;
      } else {
        this.indebt = 0;
        this.outdentToken(this.indent - size, noNewlines);
      }
      this.indent = size;
      return indent.length;
    };

    Lexer.prototype.outdentToken = function(moveOut, noNewlines) {
      var dent, len;
      while (moveOut &gt; 0) {
        len = this.indents.length - 1;
        if (this.indents[len] === void 0) {
          moveOut = 0;
        } else if (this.indents[len] === this.outdebt) {
          moveOut -= this.outdebt;
          this.outdebt = 0;
        } else if (this.indents[len] &lt; this.outdebt) {
          this.outdebt -= this.indents[len];
          moveOut -= this.indents[len];
        } else {
          dent = this.indents.pop() - this.outdebt;
          moveOut -= dent;
          this.outdebt = 0;
          this.pair(&#039;OUTDENT&#039;);
          this.token(&#039;OUTDENT&#039;, dent);
        }
      }
      if (dent) {
        this.outdebt -= moveOut;
      }
      while (this.value() === &#039;;&#039;) {
        this.tokens.pop();
      }
      if (!(this.tag() === &#039;TERMINATOR&#039; || noNewlines)) {
        this.token(&#039;TERMINATOR&#039;, &#039;\n&#039;);
      }
      return this;
    };

    Lexer.prototype.whitespaceToken = function() {
      var match, nline, prev;
      if (!((match = WHITESPACE.exec(this.chunk)) || (nline = this.chunk.charAt(0) === &#039;\n&#039;))) {
        return 0;
      }
      prev = last(this.tokens);
      if (prev) {
        prev[match ? &#039;spaced&#039; : &#039;newLine&#039;] = true;
      }
      if (match) {
        return match[0].length;
      } else {
        return 0;
      }
    };

    Lexer.prototype.newlineToken = function() {
      while (this.value() === &#039;;&#039;) {
        this.tokens.pop();
      }
      if (this.tag() !== &#039;TERMINATOR&#039;) {
        this.token(&#039;TERMINATOR&#039;, &#039;\n&#039;);
      }
      return this;
    };

    Lexer.prototype.suppressNewlines = function() {
      if (this.value() === &#039;\\&#039;) {
        this.tokens.pop();
      }
      return this;
    };

    Lexer.prototype.literalToken = function() {
      var match, prev, tag, value, _ref2, _ref3, _ref4, _ref5;
      if (match = OPERATOR.exec(this.chunk)) {
        value = match[0];
        if (CODE.test(value)) {
          this.tagParameters();
        }
      } else {
        value = this.chunk.charAt(0);
      }
      tag = value;
      prev = last(this.tokens);
      if (value === &#039;=&#039; &amp;&amp; prev) {
        if (!prev[1].reserved &amp;&amp; (_ref2 = prev[1], __indexOf.call(JS_FORBIDDEN, _ref2) &gt;= 0)) {
          this.error(&quot;reserved word \&quot;&quot; + (this.value()) + &quot;\&quot; can&#039;t be assigned&quot;);
        }
        if ((_ref3 = prev[1]) === &#039;||&#039; || _ref3 === &#039;&amp;&amp;&#039;) {
          prev[0] = &#039;COMPOUND_ASSIGN&#039;;
          prev[1] += &#039;=&#039;;
          return value.length;
        }
      }
      if (value === &#039;;&#039;) {
        this.seenFor = false;
        tag = &#039;TERMINATOR&#039;;
      } else if (__indexOf.call(MATH, value) &gt;= 0) {
        tag = &#039;MATH&#039;;
      } else if (__indexOf.call(COMPARE, value) &gt;= 0) {
        tag = &#039;COMPARE&#039;;
      } else if (__indexOf.call(COMPOUND_ASSIGN, value) &gt;= 0) {
        tag = &#039;COMPOUND_ASSIGN&#039;;
      } else if (__indexOf.call(UNARY, value) &gt;= 0) {
        tag = &#039;UNARY&#039;;
      } else if (__indexOf.call(SHIFT, value) &gt;= 0) {
        tag = &#039;SHIFT&#039;;
      } else if (__indexOf.call(LOGIC, value) &gt;= 0 || value === &#039;?&#039; &amp;&amp; (prev != null ? prev.spaced : void 0)) {
        tag = &#039;LOGIC&#039;;
      } else if (prev &amp;&amp; !prev.spaced) {
        if (value === &#039;(&#039; &amp;&amp; (_ref4 = prev[0], __indexOf.call(CALLABLE, _ref4) &gt;= 0)) {
          if (prev[0] === &#039;?&#039;) {
            prev[0] = &#039;FUNC_EXIST&#039;;
          }
          tag = &#039;CALL_START&#039;;
        } else if (value === &#039;[&#039; &amp;&amp; (_ref5 = prev[0], __indexOf.call(INDEXABLE, _ref5) &gt;= 0)) {
          tag = &#039;INDEX_START&#039;;
          switch (prev[0]) {
            case &#039;?&#039;:
              prev[0] = &#039;INDEX_SOAK&#039;;
          }
        }
      }
      switch (value) {
        case &#039;(&#039;:
        case &#039;{&#039;:
        case &#039;[&#039;:
          this.ends.push(INVERSES[value]);
          break;
        case &#039;)&#039;:
        case &#039;}&#039;:
        case &#039;]&#039;:
          this.pair(value);
      }
      this.token(tag, value);
      return value.length;
    };

    Lexer.prototype.sanitizeHeredoc = function(doc, options) {
      var attempt, herecomment, indent, match, _ref2;
      indent = options.indent, herecomment = options.herecomment;
      if (herecomment) {
        if (HEREDOC_ILLEGAL.test(doc)) {
          this.error(&quot;block comment cannot contain \&quot;*/\&quot;, starting&quot;);
        }
        if (doc.indexOf(&#039;\n&#039;) &lt;= 0) {
          return doc;
        }
      } else {
        while (match = HEREDOC_INDENT.exec(doc)) {
          attempt = match[1];
          if (indent === null || (0 &lt; (_ref2 = attempt.length) &amp;&amp; _ref2 &lt; indent.length)) {
            indent = attempt;
          }
        }
      }
      if (indent) {
        doc = doc.replace(RegExp(&quot;\\n&quot; + indent, &quot;g&quot;), &#039;\n&#039;);
      }
      if (!herecomment) {
        doc = doc.replace(/^\n/, &#039;&#039;);
      }
      return doc;
    };

    Lexer.prototype.tagParameters = function() {
      var i, stack, tok, tokens;
      if (this.tag() !== &#039;)&#039;) {
        return this;
      }
      stack = [];
      tokens = this.tokens;
      i = tokens.length;
      tokens[--i][0] = &#039;PARAM_END&#039;;
      while (tok = tokens[--i]) {
        switch (tok[0]) {
          case &#039;)&#039;:
            stack.push(tok);
            break;
          case &#039;(&#039;:
          case &#039;CALL_START&#039;:
            if (stack.length) {
              stack.pop();
            } else if (tok[0] === &#039;(&#039;) {
              tok[0] = &#039;PARAM_START&#039;;
              return this;
            } else {
              return this;
            }
        }
      }
      return this;
    };

    Lexer.prototype.closeIndentation = function() {
      return this.outdentToken(this.indent);
    };

    Lexer.prototype.balancedString = function(str, end) {
      var continueCount, i, letter, match, prev, stack, _i, _ref2;
      continueCount = 0;
      stack = [end];
      for (i = _i = 1, _ref2 = str.length; 1 &lt;= _ref2 ? _i &lt; _ref2 : _i &gt; _ref2; i = 1 &lt;= _ref2 ? ++_i : --_i) {
        if (continueCount) {
          --continueCount;
          continue;
        }
        switch (letter = str.charAt(i)) {
          case &#039;\\&#039;:
            ++continueCount;
            continue;
          case end:
            stack.pop();
            if (!stack.length) {
              return str.slice(0, i + 1 || 9e9);
            }
            end = stack[stack.length - 1];
            continue;
        }
        if (end === &#039;}&#039; &amp;&amp; (letter === &#039;&quot;&#039; || letter === &quot;&#039;&quot;)) {
          stack.push(end = letter);
        } else if (end === &#039;}&#039; &amp;&amp; letter === &#039;/&#039; &amp;&amp; (match = HEREGEX.exec(str.slice(i)) || REGEX.exec(str.slice(i)))) {
          continueCount += match[0].length - 1;
        } else if (end === &#039;}&#039; &amp;&amp; letter === &#039;{&#039;) {
          stack.push(end = &#039;}&#039;);
        } else if (end === &#039;&quot;&#039; &amp;&amp; prev === &#039;#&#039; &amp;&amp; letter === &#039;{&#039;) {
          stack.push(end = &#039;}&#039;);
        }
        prev = letter;
      }
      return this.error(&quot;missing &quot; + (stack.pop()) + &quot;, starting&quot;);
    };

    Lexer.prototype.interpolateString = function(str, options) {
      var expr, heredoc, i, inner, interpolated, len, letter, nested, pi, regex, tag, tokens, value, _i, _len, _ref2, _ref3, _ref4;
      if (options == null) {
        options = {};
      }
      heredoc = options.heredoc, regex = options.regex;
      tokens = [];
      pi = 0;
      i = -1;
      while (letter = str.charAt(i += 1)) {
        if (letter === &#039;\\&#039;) {
          i += 1;
          continue;
        }
        if (!(letter === &#039;#&#039; &amp;&amp; str.charAt(i + 1) === &#039;{&#039; &amp;&amp; (expr = this.balancedString(str.slice(i + 1), &#039;}&#039;)))) {
          continue;
        }
        if (pi &lt; i) {
          tokens.push([&#039;NEOSTRING&#039;, str.slice(pi, i)]);
        }
        inner = expr.slice(1, -1);
        if (inner.length) {
          nested = new Lexer().tokenize(inner, {
            line: this.line,
            rewrite: false
          });
          nested.pop();
          if (((_ref2 = nested[0]) != null ? _ref2[0] : void 0) === &#039;TERMINATOR&#039;) {
            nested.shift();
          }
          if (len = nested.length) {
            if (len &gt; 1) {
              nested.unshift([&#039;(&#039;, &#039;(&#039;, this.line]);
              nested.push([&#039;)&#039;, &#039;)&#039;, this.line]);
            }
            tokens.push([&#039;TOKENS&#039;, nested]);
          }
        }
        i += expr.length;
        pi = i + 1;
      }
      if ((i &gt; pi &amp;&amp; pi &lt; str.length)) {
        tokens.push([&#039;NEOSTRING&#039;, str.slice(pi)]);
      }
      if (regex) {
        return tokens;
      }
      if (!tokens.length) {
        return this.token(&#039;STRING&#039;, &#039;&quot;&quot;&#039;);
      }
      if (tokens[0][0] !== &#039;NEOSTRING&#039;) {
        tokens.unshift([&#039;&#039;, &#039;&#039;]);
      }
      if (interpolated = tokens.length &gt; 1) {
        this.token(&#039;(&#039;, &#039;(&#039;);
      }
      for (i = _i = 0, _len = tokens.length; _i &lt; _len; i = ++_i) {
        _ref3 = tokens[i], tag = _ref3[0], value = _ref3[1];
        if (i) {
          this.token(&#039;+&#039;, &#039;+&#039;);
        }
        if (tag === &#039;TOKENS&#039;) {
          (_ref4 = this.tokens).push.apply(_ref4, value);
        } else {
          this.token(&#039;STRING&#039;, this.makeString(value, &#039;&quot;&#039;, heredoc));
        }
      }
      if (interpolated) {
        this.token(&#039;)&#039;, &#039;)&#039;);
      }
      return tokens;
    };

    Lexer.prototype.pair = function(tag) {
      var size, wanted;
      if (tag !== (wanted = last(this.ends))) {
        if (&#039;OUTDENT&#039; !== wanted) {
          this.error(&quot;unmatched &quot; + tag);
        }
        this.indent -= size = last(this.indents);
        this.outdentToken(size, true);
        return this.pair(tag);
      }
      return this.ends.pop();
    };

    Lexer.prototype.token = function(tag, value) {
      return this.tokens.push([tag, value, this.line]);
    };

    Lexer.prototype.tag = function(index, tag) {
      var tok;
      return (tok = last(this.tokens, index)) &amp;&amp; (tag ? tok[0] = tag : tok[0]);
    };

    Lexer.prototype.value = function(index, val) {
      var tok;
      return (tok = last(this.tokens, index)) &amp;&amp; (val ? tok[1] = val : tok[1]);
    };

    Lexer.prototype.unfinished = function() {
      var _ref2;
      return LINE_CONTINUER.test(this.chunk) || ((_ref2 = this.tag()) === &#039;\\&#039; || _ref2 === &#039;.&#039; || _ref2 === &#039;?.&#039; || _ref2 === &#039;UNARY&#039; || _ref2 === &#039;MATH&#039; || _ref2 === &#039;+&#039; || _ref2 === &#039;-&#039; || _ref2 === &#039;SHIFT&#039; || _ref2 === &#039;RELATION&#039; || _ref2 === &#039;COMPARE&#039; || _ref2 === &#039;LOGIC&#039; || _ref2 === &#039;THROW&#039; || _ref2 === &#039;EXTENDS&#039;);
    };

    Lexer.prototype.escapeLines = function(str, heredoc) {
      return str.replace(MULTILINER, heredoc ? &#039;\\n&#039; : &#039;&#039;);
    };

    Lexer.prototype.makeString = function(body, quote, heredoc) {
      if (!body) {
        return quote + quote;
      }
      body = body.replace(/\\([\s\S])/g, function(match, contents) {
        if (contents === &#039;\n&#039; || contents === quote) {
          return contents;
        } else {
          return match;
        }
      });
      body = body.replace(RegExp(&quot;&quot; + quote, &quot;g&quot;), &#039;\\$&amp;&#039;);
      return quote + this.escapeLines(body, heredoc) + quote;
    };

    Lexer.prototype.error = function(message) {
      throw SyntaxError(&quot;&quot; + message + &quot; on line &quot; + (this.line + 1));
    };

    return Lexer;

  })();

  JS_KEYWORDS = [&#039;true&#039;, &#039;false&#039;, &#039;null&#039;, &#039;this&#039;, &#039;new&#039;, &#039;delete&#039;, &#039;typeof&#039;, &#039;in&#039;, &#039;instanceof&#039;, &#039;return&#039;, &#039;throw&#039;, &#039;break&#039;, &#039;continue&#039;, &#039;debugger&#039;, &#039;if&#039;, &#039;else&#039;, &#039;switch&#039;, &#039;for&#039;, &#039;while&#039;, &#039;do&#039;, &#039;try&#039;, &#039;catch&#039;, &#039;finally&#039;, &#039;class&#039;, &#039;extends&#039;, &#039;super&#039;];

  COFFEE_KEYWORDS = [&#039;undefined&#039;, &#039;then&#039;, &#039;unless&#039;, &#039;until&#039;, &#039;loop&#039;, &#039;of&#039;, &#039;by&#039;, &#039;when&#039;];

  COFFEE_ALIAS_MAP = {
    and: &#039;&amp;&amp;&#039;,
    or: &#039;||&#039;,
    is: &#039;==&#039;,
    isnt: &#039;!=&#039;,
    not: &#039;!&#039;,
    yes: &#039;true&#039;,
    no: &#039;false&#039;,
    on: &#039;true&#039;,
    off: &#039;false&#039;
  };

  COFFEE_ALIASES = (function() {
    var _results;
    _results = [];
    for (key in COFFEE_ALIAS_MAP) {
      _results.push(key);
    }
    return _results;
  })();

  COFFEE_KEYWORDS = COFFEE_KEYWORDS.concat(COFFEE_ALIASES);

  RESERVED = [&#039;case&#039;, &#039;default&#039;, &#039;function&#039;, &#039;var&#039;, &#039;void&#039;, &#039;with&#039;, &#039;const&#039;, &#039;let&#039;, &#039;enum&#039;, &#039;export&#039;, &#039;import&#039;, &#039;native&#039;, &#039;__hasProp&#039;, &#039;__extends&#039;, &#039;__slice&#039;, &#039;__bind&#039;, &#039;__indexOf&#039;, &#039;implements&#039;, &#039;interface&#039;, &#039;let&#039;, &#039;package&#039;, &#039;private&#039;, &#039;protected&#039;, &#039;public&#039;, &#039;static&#039;, &#039;yield&#039;];

  STRICT_PROSCRIBED = [&#039;arguments&#039;, &#039;eval&#039;];

  JS_FORBIDDEN = JS_KEYWORDS.concat(RESERVED).concat(STRICT_PROSCRIBED);

  exports.RESERVED = RESERVED.concat(JS_KEYWORDS).concat(COFFEE_KEYWORDS).concat(STRICT_PROSCRIBED);

  exports.STRICT_PROSCRIBED = STRICT_PROSCRIBED;

  IDENTIFIER = /^([$A-Za-z_\x7f-\uffff][$\w\x7f-\uffff]*)([^\n\S]*:(?!:))?/;

  NUMBER = /^0b[01]+|^0o[0-7]+|^0x[\da-f]+|^\d*\.?\d+(?:e[+-]?\d+)?/i;

  HEREDOC = /^(&quot;&quot;&quot;|&#039;&#039;&#039;)([\s\S]*?)(?:\n[^\n\S]*)?\1/;

  OPERATOR = /^(?:[-=]&gt;|[-+*\/%&lt;&gt;&amp;|^!?=]=|&gt;&gt;&gt;=?|([-+:])\1|([&amp;|&lt;&gt;])\2=?|\?\.|\.{2,3})/;

  WHITESPACE = /^[^\n\S]+/;

  COMMENT = /^###([^#][\s\S]*?)(?:###[^\n\S]*|(?:###)?$)|^(?:\s*#(?!##[^#]).*)+/;

  CODE = /^[-=]&gt;/;

  MULTI_DENT = /^(?:\n[^\n\S]*)+/;

  SIMPLESTR = /^&#039;[^\\&#039;]*(?:\\.[^\\&#039;]*)*&#039;/;

  JSTOKEN = /^`[^\\`]*(?:\\.[^\\`]*)*`/;

  REGEX = /^(\/(?![\s=])[^[\/\n\\]*(?:(?:\\[\s\S]|\[[^\]\n\\]*(?:\\[\s\S][^\]\n\\]*)*])[^[\/\n\\]*)*\/)([imgy]{0,4})(?!\w)/;

  HEREGEX = /^\/{3}([\s\S]+?)\/{3}([imgy]{0,4})(?!\w)/;

  HEREGEX_OMIT = /\s+(?:#.*)?/g;

  MULTILINER = /\n/g;

  HEREDOC_INDENT = /\n+([^\n\S]*)/g;

  HEREDOC_ILLEGAL = /\*\//;

  LINE_CONTINUER = /^\s*(?:,|\??\.(?![.\d])|::)/;

  TRAILING_SPACES = /\s+$/;

  COMPOUND_ASSIGN = [&#039;-=&#039;, &#039;+=&#039;, &#039;/=&#039;, &#039;*=&#039;, &#039;%=&#039;, &#039;||=&#039;, &#039;&amp;&amp;=&#039;, &#039;?=&#039;, &#039;&lt;&lt;=&#039;, &#039;&gt;&gt;=&#039;, &#039;&gt;&gt;&gt;=&#039;, &#039;&amp;=&#039;, &#039;^=&#039;, &#039;|=&#039;];

  UNARY = [&#039;!&#039;, &#039;~&#039;, &#039;NEW&#039;, &#039;TYPEOF&#039;, &#039;DELETE&#039;, &#039;DO&#039;];

  LOGIC = [&#039;&amp;&amp;&#039;, &#039;||&#039;, &#039;&amp;&#039;, &#039;|&#039;, &#039;^&#039;];

  SHIFT = [&#039;&lt;&lt;&#039;, &#039;&gt;&gt;&#039;, &#039;&gt;&gt;&gt;&#039;];

  COMPARE = [&#039;==&#039;, &#039;!=&#039;, &#039;&lt;&#039;, &#039;&gt;&#039;, &#039;&lt;=&#039;, &#039;&gt;=&#039;];

  MATH = [&#039;*&#039;, &#039;/&#039;, &#039;%&#039;];

  RELATION = [&#039;IN&#039;, &#039;OF&#039;, &#039;INSTANCEOF&#039;];

  BOOL = [&#039;TRUE&#039;, &#039;FALSE&#039;];

  NOT_REGEX = [&#039;NUMBER&#039;, &#039;REGEX&#039;, &#039;BOOL&#039;, &#039;NULL&#039;, &#039;UNDEFINED&#039;, &#039;++&#039;, &#039;--&#039;, &#039;]&#039;];

  NOT_SPACED_REGEX = NOT_REGEX.concat(&#039;)&#039;, &#039;}&#039;, &#039;THIS&#039;, &#039;IDENTIFIER&#039;, &#039;STRING&#039;);

  CALLABLE = [&#039;IDENTIFIER&#039;, &#039;STRING&#039;, &#039;REGEX&#039;, &#039;)&#039;, &#039;]&#039;, &#039;}&#039;, &#039;?&#039;, &#039;::&#039;, &#039;@&#039;, &#039;THIS&#039;, &#039;SUPER&#039;];

  INDEXABLE = CALLABLE.concat(&#039;NUMBER&#039;, &#039;BOOL&#039;, &#039;NULL&#039;, &#039;UNDEFINED&#039;);

  LINE_BREAK = [&#039;INDENT&#039;, &#039;OUTDENT&#039;, &#039;TERMINATOR&#039;];

}).call(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
