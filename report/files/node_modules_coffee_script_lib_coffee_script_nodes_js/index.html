<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/coffee-script/lib/coffee-script/nodes.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/coffee-script/lib/coffee-script/nodes.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.24</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">2985</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">256.50</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">49.55</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Generated by CoffeeScript 1.3.3
(function() {
  var Access, Arr, Assign, Base, Block, Call, Class, Closure, Code, Comment, Existence, Extends, For, IDENTIFIER, IDENTIFIER_STR, IS_STRING, If, In, Index, LEVEL_ACCESS, LEVEL_COND, LEVEL_LIST, LEVEL_OP, LEVEL_PAREN, LEVEL_TOP, Literal, METHOD_DEF, NEGATE, NO, Obj, Op, Param, Parens, RESERVED, Range, Return, SIMPLENUM, STRICT_PROSCRIBED, Scope, Slice, Splat, Switch, TAB, THIS, Throw, Try, UTILITIES, Value, While, YES, compact, del, ends, extend, flatten, last, merge, multident, starts, unfoldSoak, utility, _ref, _ref1,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; };

  Scope = require(&#039;./scope&#039;).Scope;

  _ref = require(&#039;./lexer&#039;), RESERVED = _ref.RESERVED, STRICT_PROSCRIBED = _ref.STRICT_PROSCRIBED;

  _ref1 = require(&#039;./helpers&#039;), compact = _ref1.compact, flatten = _ref1.flatten, extend = _ref1.extend, merge = _ref1.merge, del = _ref1.del, starts = _ref1.starts, ends = _ref1.ends, last = _ref1.last;

  exports.extend = extend;

  YES = function() {
    return true;
  };

  NO = function() {
    return false;
  };

  THIS = function() {
    return this;
  };

  NEGATE = function() {
    this.negated = !this.negated;
    return this;
  };

  exports.Base = Base = (function() {

    function Base() {}

    Base.prototype.compile = function(o, lvl) {
      var node;
      o = extend({}, o);
      if (lvl) {
        o.level = lvl;
      }
      node = this.unfoldSoak(o) || this;
      node.tab = o.indent;
      if (o.level === LEVEL_TOP || !node.isStatement(o)) {
        return node.compileNode(o);
      } else {
        return node.compileClosure(o);
      }
    };

    Base.prototype.compileClosure = function(o) {
      if (this.jumps()) {
        throw SyntaxError(&#039;cannot use a pure statement in an expression.&#039;);
      }
      o.sharedScope = true;
      return Closure.wrap(this).compileNode(o);
    };

    Base.prototype.cache = function(o, level, reused) {
      var ref, sub;
      if (!this.isComplex()) {
        ref = level ? this.compile(o, level) : this;
        return [ref, ref];
      } else {
        ref = new Literal(reused || o.scope.freeVariable(&#039;ref&#039;));
        sub = new Assign(ref, this);
        if (level) {
          return [sub.compile(o, level), ref.value];
        } else {
          return [sub, ref];
        }
      }
    };

    Base.prototype.compileLoopReference = function(o, name) {
      var src, tmp;
      src = tmp = this.compile(o, LEVEL_LIST);
      if (!((-Infinity &lt; +src &amp;&amp; +src &lt; Infinity) || IDENTIFIER.test(src) &amp;&amp; o.scope.check(src, true))) {
        src = &quot;&quot; + (tmp = o.scope.freeVariable(name)) + &quot; = &quot; + src;
      }
      return [src, tmp];
    };

    Base.prototype.makeReturn = function(res) {
      var me;
      me = this.unwrapAll();
      if (res) {
        return new Call(new Literal(&quot;&quot; + res + &quot;.push&quot;), [me]);
      } else {
        return new Return(me);
      }
    };

    Base.prototype.contains = function(pred) {
      var contains;
      contains = false;
      this.traverseChildren(false, function(node) {
        if (pred(node)) {
          contains = true;
          return false;
        }
      });
      return contains;
    };

    Base.prototype.containsType = function(type) {
      return this instanceof type || this.contains(function(node) {
        return node instanceof type;
      });
    };

    Base.prototype.lastNonComment = function(list) {
      var i;
      i = list.length;
      while (i--) {
        if (!(list[i] instanceof Comment)) {
          return list[i];
        }
      }
      return null;
    };

    Base.prototype.toString = function(idt, name) {
      var tree;
      if (idt == null) {
        idt = &#039;&#039;;
      }
      if (name == null) {
        name = this.constructor.name;
      }
      tree = &#039;\n&#039; + idt + name;
      if (this.soak) {
        tree += &#039;?&#039;;
      }
      this.eachChild(function(node) {
        return tree += node.toString(idt + TAB);
      });
      return tree;
    };

    Base.prototype.eachChild = function(func) {
      var attr, child, _i, _j, _len, _len1, _ref2, _ref3;
      if (!this.children) {
        return this;
      }
      _ref2 = this.children;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        attr = _ref2[_i];
        if (this[attr]) {
          _ref3 = flatten([this[attr]]);
          for (_j = 0, _len1 = _ref3.length; _j &lt; _len1; _j++) {
            child = _ref3[_j];
            if (func(child) === false) {
              return this;
            }
          }
        }
      }
      return this;
    };

    Base.prototype.traverseChildren = function(crossScope, func) {
      return this.eachChild(function(child) {
        if (func(child) === false) {
          return false;
        }
        return child.traverseChildren(crossScope, func);
      });
    };

    Base.prototype.invert = function() {
      return new Op(&#039;!&#039;, this);
    };

    Base.prototype.unwrapAll = function() {
      var node;
      node = this;
      while (node !== (node = node.unwrap())) {
        continue;
      }
      return node;
    };

    Base.prototype.children = [];

    Base.prototype.isStatement = NO;

    Base.prototype.jumps = NO;

    Base.prototype.isComplex = YES;

    Base.prototype.isChainable = NO;

    Base.prototype.isAssignable = NO;

    Base.prototype.unwrap = THIS;

    Base.prototype.unfoldSoak = NO;

    Base.prototype.assigns = NO;

    return Base;

  })();

  exports.Block = Block = (function(_super) {

    __extends(Block, _super);

    function Block(nodes) {
      this.expressions = compact(flatten(nodes || []));
    }

    Block.prototype.children = [&#039;expressions&#039;];

    Block.prototype.push = function(node) {
      this.expressions.push(node);
      return this;
    };

    Block.prototype.pop = function() {
      return this.expressions.pop();
    };

    Block.prototype.unshift = function(node) {
      this.expressions.unshift(node);
      return this;
    };

    Block.prototype.unwrap = function() {
      if (this.expressions.length === 1) {
        return this.expressions[0];
      } else {
        return this;
      }
    };

    Block.prototype.isEmpty = function() {
      return !this.expressions.length;
    };

    Block.prototype.isStatement = function(o) {
      var exp, _i, _len, _ref2;
      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        exp = _ref2[_i];
        if (exp.isStatement(o)) {
          return true;
        }
      }
      return false;
    };

    Block.prototype.jumps = function(o) {
      var exp, _i, _len, _ref2;
      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        exp = _ref2[_i];
        if (exp.jumps(o)) {
          return exp;
        }
      }
    };

    Block.prototype.makeReturn = function(res) {
      var expr, len;
      len = this.expressions.length;
      while (len--) {
        expr = this.expressions[len];
        if (!(expr instanceof Comment)) {
          this.expressions[len] = expr.makeReturn(res);
          if (expr instanceof Return &amp;&amp; !expr.expression) {
            this.expressions.splice(len, 1);
          }
          break;
        }
      }
      return this;
    };

    Block.prototype.compile = function(o, level) {
      if (o == null) {
        o = {};
      }
      if (o.scope) {
        return Block.__super__.compile.call(this, o, level);
      } else {
        return this.compileRoot(o);
      }
    };

    Block.prototype.compileNode = function(o) {
      var code, codes, node, top, _i, _len, _ref2;
      this.tab = o.indent;
      top = o.level === LEVEL_TOP;
      codes = [];
      _ref2 = this.expressions;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        node = _ref2[_i];
        node = node.unwrapAll();
        node = node.unfoldSoak(o) || node;
        if (node instanceof Block) {
          codes.push(node.compileNode(o));
        } else if (top) {
          node.front = true;
          code = node.compile(o);
          if (!node.isStatement(o)) {
            code = &quot;&quot; + this.tab + code + &quot;;&quot;;
            if (node instanceof Literal) {
              code = &quot;&quot; + code + &quot;\n&quot;;
            }
          }
          codes.push(code);
        } else {
          codes.push(node.compile(o, LEVEL_LIST));
        }
      }
      if (top) {
        if (this.spaced) {
          return &quot;\n&quot; + (codes.join(&#039;\n\n&#039;)) + &quot;\n&quot;;
        } else {
          return codes.join(&#039;\n&#039;);
        }
      }
      code = codes.join(&#039;, &#039;) || &#039;void 0&#039;;
      if (codes.length &gt; 1 &amp;&amp; o.level &gt;= LEVEL_LIST) {
        return &quot;(&quot; + code + &quot;)&quot;;
      } else {
        return code;
      }
    };

    Block.prototype.compileRoot = function(o) {
      var code, exp, i, prelude, preludeExps, rest;
      o.indent = o.bare ? &#039;&#039; : TAB;
      o.scope = new Scope(null, this, null);
      o.level = LEVEL_TOP;
      this.spaced = true;
      prelude = &quot;&quot;;
      if (!o.bare) {
        preludeExps = (function() {
          var _i, _len, _ref2, _results;
          _ref2 = this.expressions;
          _results = [];
          for (i = _i = 0, _len = _ref2.length; _i &lt; _len; i = ++_i) {
            exp = _ref2[i];
            if (!(exp.unwrap() instanceof Comment)) {
              break;
            }
            _results.push(exp);
          }
          return _results;
        }).call(this);
        rest = this.expressions.slice(preludeExps.length);
        this.expressions = preludeExps;
        if (preludeExps.length) {
          prelude = &quot;&quot; + (this.compileNode(merge(o, {
            indent: &#039;&#039;
          }))) + &quot;\n&quot;;
        }
        this.expressions = rest;
      }
      code = this.compileWithDeclarations(o);
      if (o.bare) {
        return code;
      }
      return &quot;&quot; + prelude + &quot;(function() {\n&quot; + code + &quot;\n}).call(this);\n&quot;;
    };

    Block.prototype.compileWithDeclarations = function(o) {
      var assigns, code, declars, exp, i, post, rest, scope, spaced, _i, _len, _ref2, _ref3, _ref4;
      code = post = &#039;&#039;;
      _ref2 = this.expressions;
      for (i = _i = 0, _len = _ref2.length; _i &lt; _len; i = ++_i) {
        exp = _ref2[i];
        exp = exp.unwrap();
        if (!(exp instanceof Comment || exp instanceof Literal)) {
          break;
        }
      }
      o = merge(o, {
        level: LEVEL_TOP
      });
      if (i) {
        rest = this.expressions.splice(i, 9e9);
        _ref3 = [this.spaced, false], spaced = _ref3[0], this.spaced = _ref3[1];
        _ref4 = [this.compileNode(o), spaced], code = _ref4[0], this.spaced = _ref4[1];
        this.expressions = rest;
      }
      post = this.compileNode(o);
      scope = o.scope;
      if (scope.expressions === this) {
        declars = o.scope.hasDeclarations();
        assigns = scope.hasAssignments;
        if (declars || assigns) {
          if (i) {
            code += &#039;\n&#039;;
          }
          code += &quot;&quot; + this.tab + &quot;var &quot;;
          if (declars) {
            code += scope.declaredVariables().join(&#039;, &#039;);
          }
          if (assigns) {
            if (declars) {
              code += &quot;,\n&quot; + (this.tab + TAB);
            }
            code += scope.assignedVariables().join(&quot;,\n&quot; + (this.tab + TAB));
          }
          code += &#039;;\n&#039;;
        }
      }
      return code + post;
    };

    Block.wrap = function(nodes) {
      if (nodes.length === 1 &amp;&amp; nodes[0] instanceof Block) {
        return nodes[0];
      }
      return new Block(nodes);
    };

    return Block;

  })(Base);

  exports.Literal = Literal = (function(_super) {

    __extends(Literal, _super);

    function Literal(value) {
      this.value = value;
    }

    Literal.prototype.makeReturn = function() {
      if (this.isStatement()) {
        return this;
      } else {
        return Literal.__super__.makeReturn.apply(this, arguments);
      }
    };

    Literal.prototype.isAssignable = function() {
      return IDENTIFIER.test(this.value);
    };

    Literal.prototype.isStatement = function() {
      var _ref2;
      return (_ref2 = this.value) === &#039;break&#039; || _ref2 === &#039;continue&#039; || _ref2 === &#039;debugger&#039;;
    };

    Literal.prototype.isComplex = NO;

    Literal.prototype.assigns = function(name) {
      return name === this.value;
    };

    Literal.prototype.jumps = function(o) {
      if (this.value === &#039;break&#039; &amp;&amp; !((o != null ? o.loop : void 0) || (o != null ? o.block : void 0))) {
        return this;
      }
      if (this.value === &#039;continue&#039; &amp;&amp; !(o != null ? o.loop : void 0)) {
        return this;
      }
    };

    Literal.prototype.compileNode = function(o) {
      var code, _ref2;
      code = this.value === &#039;this&#039; ? ((_ref2 = o.scope.method) != null ? _ref2.bound : void 0) ? o.scope.method.context : this.value : this.value.reserved ? &quot;\&quot;&quot; + this.value + &quot;\&quot;&quot; : this.value;
      if (this.isStatement()) {
        return &quot;&quot; + this.tab + code + &quot;;&quot;;
      } else {
        return code;
      }
    };

    Literal.prototype.toString = function() {
      return &#039; &quot;&#039; + this.value + &#039;&quot;&#039;;
    };

    return Literal;

  })(Base);

  exports.Undefined = (function(_super) {

    __extends(Undefined, _super);

    function Undefined() {
      return Undefined.__super__.constructor.apply(this, arguments);
    }

    Undefined.prototype.isAssignable = NO;

    Undefined.prototype.isComplex = NO;

    Undefined.prototype.compileNode = function(o) {
      if (o.level &gt;= LEVEL_ACCESS) {
        return &#039;(void 0)&#039;;
      } else {
        return &#039;void 0&#039;;
      }
    };

    return Undefined;

  })(Base);

  exports.Null = (function(_super) {

    __extends(Null, _super);

    function Null() {
      return Null.__super__.constructor.apply(this, arguments);
    }

    Null.prototype.isAssignable = NO;

    Null.prototype.isComplex = NO;

    Null.prototype.compileNode = function() {
      return &quot;null&quot;;
    };

    return Null;

  })(Base);

  exports.Bool = (function(_super) {

    __extends(Bool, _super);

    Bool.prototype.isAssignable = NO;

    Bool.prototype.isComplex = NO;

    Bool.prototype.compileNode = function() {
      return this.val;
    };

    function Bool(val) {
      this.val = val;
    }

    return Bool;

  })(Base);

  exports.Return = Return = (function(_super) {

    __extends(Return, _super);

    function Return(expr) {
      if (expr &amp;&amp; !expr.unwrap().isUndefined) {
        this.expression = expr;
      }
    }

    Return.prototype.children = [&#039;expression&#039;];

    Return.prototype.isStatement = YES;

    Return.prototype.makeReturn = THIS;

    Return.prototype.jumps = THIS;

    Return.prototype.compile = function(o, level) {
      var expr, _ref2;
      expr = (_ref2 = this.expression) != null ? _ref2.makeReturn() : void 0;
      if (expr &amp;&amp; !(expr instanceof Return)) {
        return expr.compile(o, level);
      } else {
        return Return.__super__.compile.call(this, o, level);
      }
    };

    Return.prototype.compileNode = function(o) {
      return this.tab + (&quot;return&quot; + [this.expression ? &quot; &quot; + (this.expression.compile(o, LEVEL_PAREN)) : void 0] + &quot;;&quot;);
    };

    return Return;

  })(Base);

  exports.Value = Value = (function(_super) {

    __extends(Value, _super);

    function Value(base, props, tag) {
      if (!props &amp;&amp; base instanceof Value) {
        return base;
      }
      this.base = base;
      this.properties = props || [];
      if (tag) {
        this[tag] = true;
      }
      return this;
    }

    Value.prototype.children = [&#039;base&#039;, &#039;properties&#039;];

    Value.prototype.add = function(props) {
      this.properties = this.properties.concat(props);
      return this;
    };

    Value.prototype.hasProperties = function() {
      return !!this.properties.length;
    };

    Value.prototype.isArray = function() {
      return !this.properties.length &amp;&amp; this.base instanceof Arr;
    };

    Value.prototype.isComplex = function() {
      return this.hasProperties() || this.base.isComplex();
    };

    Value.prototype.isAssignable = function() {
      return this.hasProperties() || this.base.isAssignable();
    };

    Value.prototype.isSimpleNumber = function() {
      return this.base instanceof Literal &amp;&amp; SIMPLENUM.test(this.base.value);
    };

    Value.prototype.isString = function() {
      return this.base instanceof Literal &amp;&amp; IS_STRING.test(this.base.value);
    };

    Value.prototype.isAtomic = function() {
      var node, _i, _len, _ref2;
      _ref2 = this.properties.concat(this.base);
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        node = _ref2[_i];
        if (node.soak || node instanceof Call) {
          return false;
        }
      }
      return true;
    };

    Value.prototype.isStatement = function(o) {
      return !this.properties.length &amp;&amp; this.base.isStatement(o);
    };

    Value.prototype.assigns = function(name) {
      return !this.properties.length &amp;&amp; this.base.assigns(name);
    };

    Value.prototype.jumps = function(o) {
      return !this.properties.length &amp;&amp; this.base.jumps(o);
    };

    Value.prototype.isObject = function(onlyGenerated) {
      if (this.properties.length) {
        return false;
      }
      return (this.base instanceof Obj) &amp;&amp; (!onlyGenerated || this.base.generated);
    };

    Value.prototype.isSplice = function() {
      return last(this.properties) instanceof Slice;
    };

    Value.prototype.unwrap = function() {
      if (this.properties.length) {
        return this;
      } else {
        return this.base;
      }
    };

    Value.prototype.cacheReference = function(o) {
      var base, bref, name, nref;
      name = last(this.properties);
      if (this.properties.length &lt; 2 &amp;&amp; !this.base.isComplex() &amp;&amp; !(name != null ? name.isComplex() : void 0)) {
        return [this, this];
      }
      base = new Value(this.base, this.properties.slice(0, -1));
      if (base.isComplex()) {
        bref = new Literal(o.scope.freeVariable(&#039;base&#039;));
        base = new Value(new Parens(new Assign(bref, base)));
      }
      if (!name) {
        return [base, bref];
      }
      if (name.isComplex()) {
        nref = new Literal(o.scope.freeVariable(&#039;name&#039;));
        name = new Index(new Assign(nref, name.index));
        nref = new Index(nref);
      }
      return [base.add(name), new Value(bref || base.base, [nref || name])];
    };

    Value.prototype.compileNode = function(o) {
      var code, prop, props, _i, _len;
      this.base.front = this.front;
      props = this.properties;
      code = this.base.compile(o, props.length ? LEVEL_ACCESS : null);
      if ((this.base instanceof Parens || props.length) &amp;&amp; SIMPLENUM.test(code)) {
        code = &quot;&quot; + code + &quot;.&quot;;
      }
      for (_i = 0, _len = props.length; _i &lt; _len; _i++) {
        prop = props[_i];
        code += prop.compile(o);
      }
      return code;
    };

    Value.prototype.unfoldSoak = function(o) {
      var result,
        _this = this;
      if (this.unfoldedSoak != null) {
        return this.unfoldedSoak;
      }
      result = (function() {
        var fst, i, ifn, prop, ref, snd, _i, _len, _ref2;
        if (ifn = _this.base.unfoldSoak(o)) {
          Array.prototype.push.apply(ifn.body.properties, _this.properties);
          return ifn;
        }
        _ref2 = _this.properties;
        for (i = _i = 0, _len = _ref2.length; _i &lt; _len; i = ++_i) {
          prop = _ref2[i];
          if (!prop.soak) {
            continue;
          }
          prop.soak = false;
          fst = new Value(_this.base, _this.properties.slice(0, i));
          snd = new Value(_this.base, _this.properties.slice(i));
          if (fst.isComplex()) {
            ref = new Literal(o.scope.freeVariable(&#039;ref&#039;));
            fst = new Parens(new Assign(ref, fst));
            snd.base = ref;
          }
          return new If(new Existence(fst), snd, {
            soak: true
          });
        }
        return null;
      })();
      return this.unfoldedSoak = result || false;
    };

    return Value;

  })(Base);

  exports.Comment = Comment = (function(_super) {

    __extends(Comment, _super);

    function Comment(comment) {
      this.comment = comment;
    }

    Comment.prototype.isStatement = YES;

    Comment.prototype.makeReturn = THIS;

    Comment.prototype.compileNode = function(o, level) {
      var code;
      code = &#039;/*&#039; + multident(this.comment, this.tab) + (&quot;\n&quot; + this.tab + &quot;*/\n&quot;);
      if ((level || o.level) === LEVEL_TOP) {
        code = o.indent + code;
      }
      return code;
    };

    return Comment;

  })(Base);

  exports.Call = Call = (function(_super) {

    __extends(Call, _super);

    function Call(variable, args, soak) {
      this.args = args != null ? args : [];
      this.soak = soak;
      this.isNew = false;
      this.isSuper = variable === &#039;super&#039;;
      this.variable = this.isSuper ? null : variable;
    }

    Call.prototype.children = [&#039;variable&#039;, &#039;args&#039;];

    Call.prototype.newInstance = function() {
      var base, _ref2;
      base = ((_ref2 = this.variable) != null ? _ref2.base : void 0) || this.variable;
      if (base instanceof Call &amp;&amp; !base.isNew) {
        base.newInstance();
      } else {
        this.isNew = true;
      }
      return this;
    };

    Call.prototype.superReference = function(o) {
      var accesses, method, name;
      method = o.scope.namedMethod();
      if (!method) {
        throw SyntaxError(&#039;cannot call super outside of a function.&#039;);
      }
      name = method.name;
      if (name == null) {
        throw SyntaxError(&#039;cannot call super on an anonymous function.&#039;);
      }
      if (method.klass) {
        accesses = [new Access(new Literal(&#039;__super__&#039;))];
        if (method[&quot;static&quot;]) {
          accesses.push(new Access(new Literal(&#039;constructor&#039;)));
        }
        accesses.push(new Access(new Literal(name)));
        return (new Value(new Literal(method.klass), accesses)).compile(o);
      } else {
        return &quot;&quot; + name + &quot;.__super__.constructor&quot;;
      }
    };

    Call.prototype.superThis = function(o) {
      var method;
      method = o.scope.method;
      return (method &amp;&amp; !method.klass &amp;&amp; method.context) || &quot;this&quot;;
    };

    Call.prototype.unfoldSoak = function(o) {
      var call, ifn, left, list, rite, _i, _len, _ref2, _ref3;
      if (this.soak) {
        if (this.variable) {
          if (ifn = unfoldSoak(o, this, &#039;variable&#039;)) {
            return ifn;
          }
          _ref2 = new Value(this.variable).cacheReference(o), left = _ref2[0], rite = _ref2[1];
        } else {
          left = new Literal(this.superReference(o));
          rite = new Value(left);
        }
        rite = new Call(rite, this.args);
        rite.isNew = this.isNew;
        left = new Literal(&quot;typeof &quot; + (left.compile(o)) + &quot; === \&quot;function\&quot;&quot;);
        return new If(left, new Value(rite), {
          soak: true
        });
      }
      call = this;
      list = [];
      while (true) {
        if (call.variable instanceof Call) {
          list.push(call);
          call = call.variable;
          continue;
        }
        if (!(call.variable instanceof Value)) {
          break;
        }
        list.push(call);
        if (!((call = call.variable.base) instanceof Call)) {
          break;
        }
      }
      _ref3 = list.reverse();
      for (_i = 0, _len = _ref3.length; _i &lt; _len; _i++) {
        call = _ref3[_i];
        if (ifn) {
          if (call.variable instanceof Call) {
            call.variable = ifn;
          } else {
            call.variable.base = ifn;
          }
        }
        ifn = unfoldSoak(o, call, &#039;variable&#039;);
      }
      return ifn;
    };

    Call.prototype.filterImplicitObjects = function(list) {
      var node, nodes, obj, prop, properties, _i, _j, _len, _len1, _ref2;
      nodes = [];
      for (_i = 0, _len = list.length; _i &lt; _len; _i++) {
        node = list[_i];
        if (!((typeof node.isObject === &quot;function&quot; ? node.isObject() : void 0) &amp;&amp; node.base.generated)) {
          nodes.push(node);
          continue;
        }
        obj = null;
        _ref2 = node.base.properties;
        for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) {
          prop = _ref2[_j];
          if (prop instanceof Assign || prop instanceof Comment) {
            if (!obj) {
              nodes.push(obj = new Obj(properties = [], true));
            }
            properties.push(prop);
          } else {
            nodes.push(prop);
            obj = null;
          }
        }
      }
      return nodes;
    };

    Call.prototype.compileNode = function(o) {
      var arg, args, code, _ref2;
      if ((_ref2 = this.variable) != null) {
        _ref2.front = this.front;
      }
      if (code = Splat.compileSplattedArray(o, this.args, true)) {
        return this.compileSplat(o, code);
      }
      args = this.filterImplicitObjects(this.args);
      args = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = args.length; _i &lt; _len; _i++) {
          arg = args[_i];
          _results.push(arg.compile(o, LEVEL_LIST));
        }
        return _results;
      })()).join(&#039;, &#039;);
      if (this.isSuper) {
        return this.superReference(o) + (&quot;.call(&quot; + (this.superThis(o)) + (args &amp;&amp; &#039;, &#039; + args) + &quot;)&quot;);
      } else {
        return (this.isNew ? &#039;new &#039; : &#039;&#039;) + this.variable.compile(o, LEVEL_ACCESS) + (&quot;(&quot; + args + &quot;)&quot;);
      }
    };

    Call.prototype.compileSuper = function(args, o) {
      return &quot;&quot; + (this.superReference(o)) + &quot;.call(&quot; + (this.superThis(o)) + (args.length ? &#039;, &#039; : &#039;&#039;) + args + &quot;)&quot;;
    };

    Call.prototype.compileSplat = function(o, splatArgs) {
      var base, fun, idt, name, ref;
      if (this.isSuper) {
        return &quot;&quot; + (this.superReference(o)) + &quot;.apply(&quot; + (this.superThis(o)) + &quot;, &quot; + splatArgs + &quot;)&quot;;
      }
      if (this.isNew) {
        idt = this.tab + TAB;
        return &quot;(function(func, args, ctor) {\n&quot; + idt + &quot;ctor.prototype = func.prototype;\n&quot; + idt + &quot;var child = new ctor, result = func.apply(child, args), t = typeof result;\n&quot; + idt + &quot;return t == \&quot;object\&quot; || t == \&quot;function\&quot; ? result || child : child;\n&quot; + this.tab + &quot;})(&quot; + (this.variable.compile(o, LEVEL_LIST)) + &quot;, &quot; + splatArgs + &quot;, function(){})&quot;;
      }
      base = new Value(this.variable);
      if ((name = base.properties.pop()) &amp;&amp; base.isComplex()) {
        ref = o.scope.freeVariable(&#039;ref&#039;);
        fun = &quot;(&quot; + ref + &quot; = &quot; + (base.compile(o, LEVEL_LIST)) + &quot;)&quot; + (name.compile(o));
      } else {
        fun = base.compile(o, LEVEL_ACCESS);
        if (SIMPLENUM.test(fun)) {
          fun = &quot;(&quot; + fun + &quot;)&quot;;
        }
        if (name) {
          ref = fun;
          fun += name.compile(o);
        } else {
          ref = &#039;null&#039;;
        }
      }
      return &quot;&quot; + fun + &quot;.apply(&quot; + ref + &quot;, &quot; + splatArgs + &quot;)&quot;;
    };

    return Call;

  })(Base);

  exports.Extends = Extends = (function(_super) {

    __extends(Extends, _super);

    function Extends(child, parent) {
      this.child = child;
      this.parent = parent;
    }

    Extends.prototype.children = [&#039;child&#039;, &#039;parent&#039;];

    Extends.prototype.compile = function(o) {
      return new Call(new Value(new Literal(utility(&#039;extends&#039;))), [this.child, this.parent]).compile(o);
    };

    return Extends;

  })(Base);

  exports.Access = Access = (function(_super) {

    __extends(Access, _super);

    function Access(name, tag) {
      this.name = name;
      this.name.asKey = true;
      this.soak = tag === &#039;soak&#039;;
    }

    Access.prototype.children = [&#039;name&#039;];

    Access.prototype.compile = function(o) {
      var name;
      name = this.name.compile(o);
      if (IDENTIFIER.test(name)) {
        return &quot;.&quot; + name;
      } else {
        return &quot;[&quot; + name + &quot;]&quot;;
      }
    };

    Access.prototype.isComplex = NO;

    return Access;

  })(Base);

  exports.Index = Index = (function(_super) {

    __extends(Index, _super);

    function Index(index) {
      this.index = index;
    }

    Index.prototype.children = [&#039;index&#039;];

    Index.prototype.compile = function(o) {
      return &quot;[&quot; + (this.index.compile(o, LEVEL_PAREN)) + &quot;]&quot;;
    };

    Index.prototype.isComplex = function() {
      return this.index.isComplex();
    };

    return Index;

  })(Base);

  exports.Range = Range = (function(_super) {

    __extends(Range, _super);

    Range.prototype.children = [&#039;from&#039;, &#039;to&#039;];

    function Range(from, to, tag) {
      this.from = from;
      this.to = to;
      this.exclusive = tag === &#039;exclusive&#039;;
      this.equals = this.exclusive ? &#039;&#039; : &#039;=&#039;;
    }

    Range.prototype.compileVariables = function(o) {
      var step, _ref2, _ref3, _ref4, _ref5;
      o = merge(o, {
        top: true
      });
      _ref2 = this.from.cache(o, LEVEL_LIST), this.fromC = _ref2[0], this.fromVar = _ref2[1];
      _ref3 = this.to.cache(o, LEVEL_LIST), this.toC = _ref3[0], this.toVar = _ref3[1];
      if (step = del(o, &#039;step&#039;)) {
        _ref4 = step.cache(o, LEVEL_LIST), this.step = _ref4[0], this.stepVar = _ref4[1];
      }
      _ref5 = [this.fromVar.match(SIMPLENUM), this.toVar.match(SIMPLENUM)], this.fromNum = _ref5[0], this.toNum = _ref5[1];
      if (this.stepVar) {
        return this.stepNum = this.stepVar.match(SIMPLENUM);
      }
    };

    Range.prototype.compileNode = function(o) {
      var cond, condPart, from, gt, idx, idxName, known, lt, namedIndex, stepPart, to, varPart, _ref2, _ref3;
      if (!this.fromVar) {
        this.compileVariables(o);
      }
      if (!o.index) {
        return this.compileArray(o);
      }
      known = this.fromNum &amp;&amp; this.toNum;
      idx = del(o, &#039;index&#039;);
      idxName = del(o, &#039;name&#039;);
      namedIndex = idxName &amp;&amp; idxName !== idx;
      varPart = &quot;&quot; + idx + &quot; = &quot; + this.fromC;
      if (this.toC !== this.toVar) {
        varPart += &quot;, &quot; + this.toC;
      }
      if (this.step !== this.stepVar) {
        varPart += &quot;, &quot; + this.step;
      }
      _ref2 = [&quot;&quot; + idx + &quot; &lt;&quot; + this.equals, &quot;&quot; + idx + &quot; &gt;&quot; + this.equals], lt = _ref2[0], gt = _ref2[1];
      condPart = this.stepNum ? +this.stepNum &gt; 0 ? &quot;&quot; + lt + &quot; &quot; + this.toVar : &quot;&quot; + gt + &quot; &quot; + this.toVar : known ? ((_ref3 = [+this.fromNum, +this.toNum], from = _ref3[0], to = _ref3[1], _ref3), from &lt;= to ? &quot;&quot; + lt + &quot; &quot; + to : &quot;&quot; + gt + &quot; &quot; + to) : (cond = &quot;&quot; + this.fromVar + &quot; &lt;= &quot; + this.toVar, &quot;&quot; + cond + &quot; ? &quot; + lt + &quot; &quot; + this.toVar + &quot; : &quot; + gt + &quot; &quot; + this.toVar);
      stepPart = this.stepVar ? &quot;&quot; + idx + &quot; += &quot; + this.stepVar : known ? namedIndex ? from &lt;= to ? &quot;++&quot; + idx : &quot;--&quot; + idx : from &lt;= to ? &quot;&quot; + idx + &quot;++&quot; : &quot;&quot; + idx + &quot;--&quot; : namedIndex ? &quot;&quot; + cond + &quot; ? ++&quot; + idx + &quot; : --&quot; + idx : &quot;&quot; + cond + &quot; ? &quot; + idx + &quot;++ : &quot; + idx + &quot;--&quot;;
      if (namedIndex) {
        varPart = &quot;&quot; + idxName + &quot; = &quot; + varPart;
      }
      if (namedIndex) {
        stepPart = &quot;&quot; + idxName + &quot; = &quot; + stepPart;
      }
      return &quot;&quot; + varPart + &quot;; &quot; + condPart + &quot;; &quot; + stepPart;
    };

    Range.prototype.compileArray = function(o) {
      var args, body, cond, hasArgs, i, idt, post, pre, range, result, vars, _i, _ref2, _ref3, _results;
      if (this.fromNum &amp;&amp; this.toNum &amp;&amp; Math.abs(this.fromNum - this.toNum) &lt;= 20) {
        range = (function() {
          _results = [];
          for (var _i = _ref2 = +this.fromNum, _ref3 = +this.toNum; _ref2 &lt;= _ref3 ? _i &lt;= _ref3 : _i &gt;= _ref3; _ref2 &lt;= _ref3 ? _i++ : _i--){ _results.push(_i); }
          return _results;
        }).apply(this);
        if (this.exclusive) {
          range.pop();
        }
        return &quot;[&quot; + (range.join(&#039;, &#039;)) + &quot;]&quot;;
      }
      idt = this.tab + TAB;
      i = o.scope.freeVariable(&#039;i&#039;);
      result = o.scope.freeVariable(&#039;results&#039;);
      pre = &quot;\n&quot; + idt + result + &quot; = [];&quot;;
      if (this.fromNum &amp;&amp; this.toNum) {
        o.index = i;
        body = this.compileNode(o);
      } else {
        vars = (&quot;&quot; + i + &quot; = &quot; + this.fromC) + (this.toC !== this.toVar ? &quot;, &quot; + this.toC : &#039;&#039;);
        cond = &quot;&quot; + this.fromVar + &quot; &lt;= &quot; + this.toVar;
        body = &quot;var &quot; + vars + &quot;; &quot; + cond + &quot; ? &quot; + i + &quot; &lt;&quot; + this.equals + &quot; &quot; + this.toVar + &quot; : &quot; + i + &quot; &gt;&quot; + this.equals + &quot; &quot; + this.toVar + &quot;; &quot; + cond + &quot; ? &quot; + i + &quot;++ : &quot; + i + &quot;--&quot;;
      }
      post = &quot;{ &quot; + result + &quot;.push(&quot; + i + &quot;); }\n&quot; + idt + &quot;return &quot; + result + &quot;;\n&quot; + o.indent;
      hasArgs = function(node) {
        return node != null ? node.contains(function(n) {
          return n instanceof Literal &amp;&amp; n.value === &#039;arguments&#039; &amp;&amp; !n.asKey;
        }) : void 0;
      };
      if (hasArgs(this.from) || hasArgs(this.to)) {
        args = &#039;, arguments&#039;;
      }
      return &quot;(function() {&quot; + pre + &quot;\n&quot; + idt + &quot;for (&quot; + body + &quot;)&quot; + post + &quot;}).apply(this&quot; + (args != null ? args : &#039;&#039;) + &quot;)&quot;;
    };

    return Range;

  })(Base);

  exports.Slice = Slice = (function(_super) {

    __extends(Slice, _super);

    Slice.prototype.children = [&#039;range&#039;];

    function Slice(range) {
      this.range = range;
      Slice.__super__.constructor.call(this);
    }

    Slice.prototype.compileNode = function(o) {
      var compiled, from, fromStr, to, toStr, _ref2;
      _ref2 = this.range, to = _ref2.to, from = _ref2.from;
      fromStr = from &amp;&amp; from.compile(o, LEVEL_PAREN) || &#039;0&#039;;
      compiled = to &amp;&amp; to.compile(o, LEVEL_PAREN);
      if (to &amp;&amp; !(!this.range.exclusive &amp;&amp; +compiled === -1)) {
        toStr = &#039;, &#039; + (this.range.exclusive ? compiled : SIMPLENUM.test(compiled) ? &quot;&quot; + (+compiled + 1) : (compiled = to.compile(o, LEVEL_ACCESS), &quot;&quot; + compiled + &quot; + 1 || 9e9&quot;));
      }
      return &quot;.slice(&quot; + fromStr + (toStr || &#039;&#039;) + &quot;)&quot;;
    };

    return Slice;

  })(Base);

  exports.Obj = Obj = (function(_super) {

    __extends(Obj, _super);

    function Obj(props, generated) {
      this.generated = generated != null ? generated : false;
      this.objects = this.properties = props || [];
    }

    Obj.prototype.children = [&#039;properties&#039;];

    Obj.prototype.compileNode = function(o) {
      var i, idt, indent, join, lastNoncom, node, obj, prop, propName, propNames, props, _i, _j, _len, _len1, _ref2;
      props = this.properties;
      propNames = [];
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        prop = _ref2[_i];
        if (prop.isComplex()) {
          prop = prop.variable;
        }
        if (prop != null) {
          propName = prop.unwrapAll().value.toString();
          if (__indexOf.call(propNames, propName) &gt;= 0) {
            throw SyntaxError(&quot;multiple object literal properties named \&quot;&quot; + propName + &quot;\&quot;&quot;);
          }
          propNames.push(propName);
        }
      }
      if (!props.length) {
        return (this.front ? &#039;({})&#039; : &#039;{}&#039;);
      }
      if (this.generated) {
        for (_j = 0, _len1 = props.length; _j &lt; _len1; _j++) {
          node = props[_j];
          if (node instanceof Value) {
            throw new Error(&#039;cannot have an implicit value in an implicit object&#039;);
          }
        }
      }
      idt = o.indent += TAB;
      lastNoncom = this.lastNonComment(this.properties);
      props = (function() {
        var _k, _len2, _results;
        _results = [];
        for (i = _k = 0, _len2 = props.length; _k &lt; _len2; i = ++_k) {
          prop = props[i];
          join = i === props.length - 1 ? &#039;&#039; : prop === lastNoncom || prop instanceof Comment ? &#039;\n&#039; : &#039;,\n&#039;;
          indent = prop instanceof Comment ? &#039;&#039; : idt;
          if (prop instanceof Value &amp;&amp; prop[&quot;this&quot;]) {
            prop = new Assign(prop.properties[0].name, prop, &#039;object&#039;);
          }
          if (!(prop instanceof Comment)) {
            if (!(prop instanceof Assign)) {
              prop = new Assign(prop, prop, &#039;object&#039;);
            }
            (prop.variable.base || prop.variable).asKey = true;
          }
          _results.push(indent + prop.compile(o, LEVEL_TOP) + join);
        }
        return _results;
      })();
      props = props.join(&#039;&#039;);
      obj = &quot;{&quot; + (props &amp;&amp; &#039;\n&#039; + props + &#039;\n&#039; + this.tab) + &quot;}&quot;;
      if (this.front) {
        return &quot;(&quot; + obj + &quot;)&quot;;
      } else {
        return obj;
      }
    };

    Obj.prototype.assigns = function(name) {
      var prop, _i, _len, _ref2;
      _ref2 = this.properties;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        prop = _ref2[_i];
        if (prop.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    return Obj;

  })(Base);

  exports.Arr = Arr = (function(_super) {

    __extends(Arr, _super);

    function Arr(objs) {
      this.objects = objs || [];
    }

    Arr.prototype.children = [&#039;objects&#039;];

    Arr.prototype.filterImplicitObjects = Call.prototype.filterImplicitObjects;

    Arr.prototype.compileNode = function(o) {
      var code, obj, objs;
      if (!this.objects.length) {
        return &#039;[]&#039;;
      }
      o.indent += TAB;
      objs = this.filterImplicitObjects(this.objects);
      if (code = Splat.compileSplattedArray(o, objs)) {
        return code;
      }
      code = ((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = objs.length; _i &lt; _len; _i++) {
          obj = objs[_i];
          _results.push(obj.compile(o, LEVEL_LIST));
        }
        return _results;
      })()).join(&#039;, &#039;);
      if (code.indexOf(&#039;\n&#039;) &gt;= 0) {
        return &quot;[\n&quot; + o.indent + code + &quot;\n&quot; + this.tab + &quot;]&quot;;
      } else {
        return &quot;[&quot; + code + &quot;]&quot;;
      }
    };

    Arr.prototype.assigns = function(name) {
      var obj, _i, _len, _ref2;
      _ref2 = this.objects;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        obj = _ref2[_i];
        if (obj.assigns(name)) {
          return true;
        }
      }
      return false;
    };

    return Arr;

  })(Base);

  exports.Class = Class = (function(_super) {

    __extends(Class, _super);

    function Class(variable, parent, body) {
      this.variable = variable;
      this.parent = parent;
      this.body = body != null ? body : new Block;
      this.boundFuncs = [];
      this.body.classBody = true;
    }

    Class.prototype.children = [&#039;variable&#039;, &#039;parent&#039;, &#039;body&#039;];

    Class.prototype.determineName = function() {
      var decl, tail;
      if (!this.variable) {
        return null;
      }
      decl = (tail = last(this.variable.properties)) ? tail instanceof Access &amp;&amp; tail.name.value : this.variable.base.value;
      if (__indexOf.call(STRICT_PROSCRIBED, decl) &gt;= 0) {
        throw SyntaxError(&quot;variable name may not be &quot; + decl);
      }
      return decl &amp;&amp; (decl = IDENTIFIER.test(decl) &amp;&amp; decl);
    };

    Class.prototype.setContext = function(name) {
      return this.body.traverseChildren(false, function(node) {
        if (node.classBody) {
          return false;
        }
        if (node instanceof Literal &amp;&amp; node.value === &#039;this&#039;) {
          return node.value = name;
        } else if (node instanceof Code) {
          node.klass = name;
          if (node.bound) {
            return node.context = name;
          }
        }
      });
    };

    Class.prototype.addBoundFunctions = function(o) {
      var bvar, lhs, _i, _len, _ref2, _results;
      if (this.boundFuncs.length) {
        _ref2 = this.boundFuncs;
        _results = [];
        for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
          bvar = _ref2[_i];
          lhs = (new Value(new Literal(&quot;this&quot;), [new Access(bvar)])).compile(o);
          _results.push(this.ctor.body.unshift(new Literal(&quot;&quot; + lhs + &quot; = &quot; + (utility(&#039;bind&#039;)) + &quot;(&quot; + lhs + &quot;, this)&quot;)));
        }
        return _results;
      }
    };

    Class.prototype.addProperties = function(node, name, o) {
      var assign, base, exprs, func, props;
      props = node.base.properties.slice(0);
      exprs = (function() {
        var _results;
        _results = [];
        while (assign = props.shift()) {
          if (assign instanceof Assign) {
            base = assign.variable.base;
            delete assign.context;
            func = assign.value;
            if (base.value === &#039;constructor&#039;) {
              if (this.ctor) {
                throw new Error(&#039;cannot define more than one constructor in a class&#039;);
              }
              if (func.bound) {
                throw new Error(&#039;cannot define a constructor as a bound function&#039;);
              }
              if (func instanceof Code) {
                assign = this.ctor = func;
              } else {
                this.externalCtor = o.scope.freeVariable(&#039;class&#039;);
                assign = new Assign(new Literal(this.externalCtor), func);
              }
            } else {
              if (assign.variable[&quot;this&quot;]) {
                func[&quot;static&quot;] = true;
                if (func.bound) {
                  func.context = name;
                }
              } else {
                assign.variable = new Value(new Literal(name), [new Access(new Literal(&#039;prototype&#039;)), new Access(base)]);
                if (func instanceof Code &amp;&amp; func.bound) {
                  this.boundFuncs.push(base);
                  func.bound = false;
                }
              }
            }
          }
          _results.push(assign);
        }
        return _results;
      }).call(this);
      return compact(exprs);
    };

    Class.prototype.walkBody = function(name, o) {
      var _this = this;
      return this.traverseChildren(false, function(child) {
        var exps, i, node, _i, _len, _ref2;
        if (child instanceof Class) {
          return false;
        }
        if (child instanceof Block) {
          _ref2 = exps = child.expressions;
          for (i = _i = 0, _len = _ref2.length; _i &lt; _len; i = ++_i) {
            node = _ref2[i];
            if (node instanceof Value &amp;&amp; node.isObject(true)) {
              exps[i] = _this.addProperties(node, name, o);
            }
          }
          return child.expressions = exps = flatten(exps);
        }
      });
    };

    Class.prototype.hoistDirectivePrologue = function() {
      var expressions, index, node;
      index = 0;
      expressions = this.body.expressions;
      while ((node = expressions[index]) &amp;&amp; node instanceof Comment || node instanceof Value &amp;&amp; node.isString()) {
        ++index;
      }
      return this.directives = expressions.splice(0, index);
    };

    Class.prototype.ensureConstructor = function(name) {
      if (!this.ctor) {
        this.ctor = new Code;
        if (this.parent) {
          this.ctor.body.push(new Literal(&quot;&quot; + name + &quot;.__super__.constructor.apply(this, arguments)&quot;));
        }
        if (this.externalCtor) {
          this.ctor.body.push(new Literal(&quot;&quot; + this.externalCtor + &quot;.apply(this, arguments)&quot;));
        }
        this.ctor.body.makeReturn();
        this.body.expressions.unshift(this.ctor);
      }
      this.ctor.ctor = this.ctor.name = name;
      this.ctor.klass = null;
      return this.ctor.noReturn = true;
    };

    Class.prototype.compileNode = function(o) {
      var call, decl, klass, lname, name, params, _ref2;
      decl = this.determineName();
      name = decl || &#039;_Class&#039;;
      if (name.reserved) {
        name = &quot;_&quot; + name;
      }
      lname = new Literal(name);
      this.hoistDirectivePrologue();
      this.setContext(name);
      this.walkBody(name, o);
      this.ensureConstructor(name);
      this.body.spaced = true;
      if (!(this.ctor instanceof Code)) {
        this.body.expressions.unshift(this.ctor);
      }
      this.body.expressions.push(lname);
      (_ref2 = this.body.expressions).unshift.apply(_ref2, this.directives);
      this.addBoundFunctions(o);
      call = Closure.wrap(this.body);
      if (this.parent) {
        this.superClass = new Literal(o.scope.freeVariable(&#039;super&#039;, false));
        this.body.expressions.unshift(new Extends(lname, this.superClass));
        call.args.push(this.parent);
        params = call.variable.params || call.variable.base.params;
        params.push(new Param(this.superClass));
      }
      klass = new Parens(call, true);
      if (this.variable) {
        klass = new Assign(this.variable, klass);
      }
      return klass.compile(o);
    };

    return Class;

  })(Base);

  exports.Assign = Assign = (function(_super) {

    __extends(Assign, _super);

    function Assign(variable, value, context, options) {
      var forbidden, name, _ref2;
      this.variable = variable;
      this.value = value;
      this.context = context;
      this.param = options &amp;&amp; options.param;
      this.subpattern = options &amp;&amp; options.subpattern;
      forbidden = (_ref2 = (name = this.variable.unwrapAll().value), __indexOf.call(STRICT_PROSCRIBED, _ref2) &gt;= 0);
      if (forbidden &amp;&amp; this.context !== &#039;object&#039;) {
        throw SyntaxError(&quot;variable name may not be \&quot;&quot; + name + &quot;\&quot;&quot;);
      }
    }

    Assign.prototype.children = [&#039;variable&#039;, &#039;value&#039;];

    Assign.prototype.isStatement = function(o) {
      return (o != null ? o.level : void 0) === LEVEL_TOP &amp;&amp; (this.context != null) &amp;&amp; __indexOf.call(this.context, &quot;?&quot;) &gt;= 0;
    };

    Assign.prototype.assigns = function(name) {
      return this[this.context === &#039;object&#039; ? &#039;value&#039; : &#039;variable&#039;].assigns(name);
    };

    Assign.prototype.unfoldSoak = function(o) {
      return unfoldSoak(o, this, &#039;variable&#039;);
    };

    Assign.prototype.compileNode = function(o) {
      var isValue, match, name, val, varBase, _ref2, _ref3, _ref4, _ref5;
      if (isValue = this.variable instanceof Value) {
        if (this.variable.isArray() || this.variable.isObject()) {
          return this.compilePatternMatch(o);
        }
        if (this.variable.isSplice()) {
          return this.compileSplice(o);
        }
        if ((_ref2 = this.context) === &#039;||=&#039; || _ref2 === &#039;&amp;&amp;=&#039; || _ref2 === &#039;?=&#039;) {
          return this.compileConditional(o);
        }
      }
      name = this.variable.compile(o, LEVEL_LIST);
      if (!this.context) {
        if (!(varBase = this.variable.unwrapAll()).isAssignable()) {
          throw SyntaxError(&quot;\&quot;&quot; + (this.variable.compile(o)) + &quot;\&quot; cannot be assigned.&quot;);
        }
        if (!(typeof varBase.hasProperties === &quot;function&quot; ? varBase.hasProperties() : void 0)) {
          if (this.param) {
            o.scope.add(name, &#039;var&#039;);
          } else {
            o.scope.find(name);
          }
        }
      }
      if (this.value instanceof Code &amp;&amp; (match = METHOD_DEF.exec(name))) {
        if (match[1]) {
          this.value.klass = match[1];
        }
        this.value.name = (_ref3 = (_ref4 = (_ref5 = match[2]) != null ? _ref5 : match[3]) != null ? _ref4 : match[4]) != null ? _ref3 : match[5];
      }
      val = this.value.compile(o, LEVEL_LIST);
      if (this.context === &#039;object&#039;) {
        return &quot;&quot; + name + &quot;: &quot; + val;
      }
      val = name + (&quot; &quot; + (this.context || &#039;=&#039;) + &quot; &quot;) + val;
      if (o.level &lt;= LEVEL_LIST) {
        return val;
      } else {
        return &quot;(&quot; + val + &quot;)&quot;;
      }
    };

    Assign.prototype.compilePatternMatch = function(o) {
      var acc, assigns, code, i, idx, isObject, ivar, name, obj, objects, olen, ref, rest, splat, top, val, value, vvar, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      top = o.level === LEVEL_TOP;
      value = this.value;
      objects = this.variable.base.objects;
      if (!(olen = objects.length)) {
        code = value.compile(o);
        if (o.level &gt;= LEVEL_OP) {
          return &quot;(&quot; + code + &quot;)&quot;;
        } else {
          return code;
        }
      }
      isObject = this.variable.isObject();
      if (top &amp;&amp; olen === 1 &amp;&amp; !((obj = objects[0]) instanceof Splat)) {
        if (obj instanceof Assign) {
          _ref2 = obj, (_ref3 = _ref2.variable, idx = _ref3.base), obj = _ref2.value;
        } else {
          if (obj.base instanceof Parens) {
            _ref4 = new Value(obj.unwrapAll()).cacheReference(o), obj = _ref4[0], idx = _ref4[1];
          } else {
            idx = isObject ? obj[&quot;this&quot;] ? obj.properties[0].name : obj : new Literal(0);
          }
        }
        acc = IDENTIFIER.test(idx.unwrap().value || 0);
        value = new Value(value);
        value.properties.push(new (acc ? Access : Index)(idx));
        if (_ref5 = obj.unwrap().value, __indexOf.call(RESERVED, _ref5) &gt;= 0) {
          throw new SyntaxError(&quot;assignment to a reserved word: &quot; + (obj.compile(o)) + &quot; = &quot; + (value.compile(o)));
        }
        return new Assign(obj, value, null, {
          param: this.param
        }).compile(o, LEVEL_TOP);
      }
      vvar = value.compile(o, LEVEL_LIST);
      assigns = [];
      splat = false;
      if (!IDENTIFIER.test(vvar) || this.variable.assigns(vvar)) {
        assigns.push(&quot;&quot; + (ref = o.scope.freeVariable(&#039;ref&#039;)) + &quot; = &quot; + vvar);
        vvar = ref;
      }
      for (i = _i = 0, _len = objects.length; _i &lt; _len; i = ++_i) {
        obj = objects[i];
        idx = i;
        if (isObject) {
          if (obj instanceof Assign) {
            _ref6 = obj, (_ref7 = _ref6.variable, idx = _ref7.base), obj = _ref6.value;
          } else {
            if (obj.base instanceof Parens) {
              _ref8 = new Value(obj.unwrapAll()).cacheReference(o), obj = _ref8[0], idx = _ref8[1];
            } else {
              idx = obj[&quot;this&quot;] ? obj.properties[0].name : obj;
            }
          }
        }
        if (!splat &amp;&amp; obj instanceof Splat) {
          name = obj.name.unwrap().value;
          obj = obj.unwrap();
          val = &quot;&quot; + olen + &quot; &lt;= &quot; + vvar + &quot;.length ? &quot; + (utility(&#039;slice&#039;)) + &quot;.call(&quot; + vvar + &quot;, &quot; + i;
          if (rest = olen - i - 1) {
            ivar = o.scope.freeVariable(&#039;i&#039;);
            val += &quot;, &quot; + ivar + &quot; = &quot; + vvar + &quot;.length - &quot; + rest + &quot;) : (&quot; + ivar + &quot; = &quot; + i + &quot;, [])&quot;;
          } else {
            val += &quot;) : []&quot;;
          }
          val = new Literal(val);
          splat = &quot;&quot; + ivar + &quot;++&quot;;
        } else {
          name = obj.unwrap().value;
          if (obj instanceof Splat) {
            obj = obj.name.compile(o);
            throw new SyntaxError(&quot;multiple splats are disallowed in an assignment: &quot; + obj + &quot;...&quot;);
          }
          if (typeof idx === &#039;number&#039;) {
            idx = new Literal(splat || idx);
            acc = false;
          } else {
            acc = isObject &amp;&amp; IDENTIFIER.test(idx.unwrap().value || 0);
          }
          val = new Value(new Literal(vvar), [new (acc ? Access : Index)(idx)]);
        }
        if ((name != null) &amp;&amp; __indexOf.call(RESERVED, name) &gt;= 0) {
          throw new SyntaxError(&quot;assignment to a reserved word: &quot; + (obj.compile(o)) + &quot; = &quot; + (val.compile(o)));
        }
        assigns.push(new Assign(obj, val, null, {
          param: this.param,
          subpattern: true
        }).compile(o, LEVEL_LIST));
      }
      if (!(top || this.subpattern)) {
        assigns.push(vvar);
      }
      code = assigns.join(&#039;, &#039;);
      if (o.level &lt; LEVEL_LIST) {
        return code;
      } else {
        return &quot;(&quot; + code + &quot;)&quot;;
      }
    };

    Assign.prototype.compileConditional = function(o) {
      var left, right, _ref2;
      _ref2 = this.variable.cacheReference(o), left = _ref2[0], right = _ref2[1];
      if (!left.properties.length &amp;&amp; left.base instanceof Literal &amp;&amp; left.base.value !== &quot;this&quot; &amp;&amp; !o.scope.check(left.base.value)) {
        throw new Error(&quot;the variable \&quot;&quot; + left.base.value + &quot;\&quot; can&#039;t be assigned with &quot; + this.context + &quot; because it has not been defined.&quot;);
      }
      if (__indexOf.call(this.context, &quot;?&quot;) &gt;= 0) {
        o.isExistentialEquals = true;
      }
      return new Op(this.context.slice(0, -1), left, new Assign(right, this.value, &#039;=&#039;)).compile(o);
    };

    Assign.prototype.compileSplice = function(o) {
      var code, exclusive, from, fromDecl, fromRef, name, to, valDef, valRef, _ref2, _ref3, _ref4;
      _ref2 = this.variable.properties.pop().range, from = _ref2.from, to = _ref2.to, exclusive = _ref2.exclusive;
      name = this.variable.compile(o);
      _ref3 = (from != null ? from.cache(o, LEVEL_OP) : void 0) || [&#039;0&#039;, &#039;0&#039;], fromDecl = _ref3[0], fromRef = _ref3[1];
      if (to) {
        if ((from != null ? from.isSimpleNumber() : void 0) &amp;&amp; to.isSimpleNumber()) {
          to = +to.compile(o) - +fromRef;
          if (!exclusive) {
            to += 1;
          }
        } else {
          to = to.compile(o, LEVEL_ACCESS) + &#039; - &#039; + fromRef;
          if (!exclusive) {
            to += &#039; + 1&#039;;
          }
        }
      } else {
        to = &quot;9e9&quot;;
      }
      _ref4 = this.value.cache(o, LEVEL_LIST), valDef = _ref4[0], valRef = _ref4[1];
      code = &quot;[].splice.apply(&quot; + name + &quot;, [&quot; + fromDecl + &quot;, &quot; + to + &quot;].concat(&quot; + valDef + &quot;)), &quot; + valRef;
      if (o.level &gt; LEVEL_TOP) {
        return &quot;(&quot; + code + &quot;)&quot;;
      } else {
        return code;
      }
    };

    return Assign;

  })(Base);

  exports.Code = Code = (function(_super) {

    __extends(Code, _super);

    function Code(params, body, tag) {
      this.params = params || [];
      this.body = body || new Block;
      this.bound = tag === &#039;boundfunc&#039;;
      if (this.bound) {
        this.context = &#039;_this&#039;;
      }
    }

    Code.prototype.children = [&#039;params&#039;, &#039;body&#039;];

    Code.prototype.isStatement = function() {
      return !!this.ctor;
    };

    Code.prototype.jumps = NO;

    Code.prototype.compileNode = function(o) {
      var code, exprs, i, idt, lit, name, p, param, params, ref, splats, uniqs, val, wasEmpty, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _len5, _m, _n, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8;
      o.scope = new Scope(o.scope, this.body, this);
      o.scope.shared = del(o, &#039;sharedScope&#039;);
      o.indent += TAB;
      delete o.bare;
      delete o.isExistentialEquals;
      params = [];
      exprs = [];
      _ref2 = this.paramNames();
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        name = _ref2[_i];
        if (!o.scope.check(name)) {
          o.scope.parameter(name);
        }
      }
      _ref3 = this.params;
      for (_j = 0, _len1 = _ref3.length; _j &lt; _len1; _j++) {
        param = _ref3[_j];
        if (!param.splat) {
          continue;
        }
        _ref4 = this.params;
        for (_k = 0, _len2 = _ref4.length; _k &lt; _len2; _k++) {
          p = _ref4[_k].name;
          if (p[&quot;this&quot;]) {
            p = p.properties[0].name;
          }
          if (p.value) {
            o.scope.add(p.value, &#039;var&#039;, true);
          }
        }
        splats = new Assign(new Value(new Arr((function() {
          var _l, _len3, _ref5, _results;
          _ref5 = this.params;
          _results = [];
          for (_l = 0, _len3 = _ref5.length; _l &lt; _len3; _l++) {
            p = _ref5[_l];
            _results.push(p.asReference(o));
          }
          return _results;
        }).call(this))), new Value(new Literal(&#039;arguments&#039;)));
        break;
      }
      _ref5 = this.params;
      for (_l = 0, _len3 = _ref5.length; _l &lt; _len3; _l++) {
        param = _ref5[_l];
        if (param.isComplex()) {
          val = ref = param.asReference(o);
          if (param.value) {
            val = new Op(&#039;?&#039;, ref, param.value);
          }
          exprs.push(new Assign(new Value(param.name), val, &#039;=&#039;, {
            param: true
          }));
        } else {
          ref = param;
          if (param.value) {
            lit = new Literal(ref.name.value + &#039; == null&#039;);
            val = new Assign(new Value(param.name), param.value, &#039;=&#039;);
            exprs.push(new If(lit, val));
          }
        }
        if (!splats) {
          params.push(ref);
        }
      }
      wasEmpty = this.body.isEmpty();
      if (splats) {
        exprs.unshift(splats);
      }
      if (exprs.length) {
        (_ref6 = this.body.expressions).unshift.apply(_ref6, exprs);
      }
      for (i = _m = 0, _len4 = params.length; _m &lt; _len4; i = ++_m) {
        p = params[i];
        o.scope.parameter(params[i] = p.compile(o));
      }
      uniqs = [];
      _ref7 = this.paramNames();
      for (_n = 0, _len5 = _ref7.length; _n &lt; _len5; _n++) {
        name = _ref7[_n];
        if (__indexOf.call(uniqs, name) &gt;= 0) {
          throw SyntaxError(&quot;multiple parameters named &#039;&quot; + name + &quot;&#039;&quot;);
        }
        uniqs.push(name);
      }
      if (!(wasEmpty || this.noReturn)) {
        this.body.makeReturn();
      }
      if (this.bound) {
        if ((_ref8 = o.scope.parent.method) != null ? _ref8.bound : void 0) {
          this.bound = this.context = o.scope.parent.method.context;
        } else if (!this[&quot;static&quot;]) {
          o.scope.parent.assign(&#039;_this&#039;, &#039;this&#039;);
        }
      }
      idt = o.indent;
      code = &#039;function&#039;;
      if (this.ctor) {
        code += &#039; &#039; + this.name;
      }
      code += &#039;(&#039; + params.join(&#039;, &#039;) + &#039;) {&#039;;
      if (!this.body.isEmpty()) {
        code += &quot;\n&quot; + (this.body.compileWithDeclarations(o)) + &quot;\n&quot; + this.tab;
      }
      code += &#039;}&#039;;
      if (this.ctor) {
        return this.tab + code;
      }
      if (this.front || (o.level &gt;= LEVEL_ACCESS)) {
        return &quot;(&quot; + code + &quot;)&quot;;
      } else {
        return code;
      }
    };

    Code.prototype.paramNames = function() {
      var names, param, _i, _len, _ref2;
      names = [];
      _ref2 = this.params;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        param = _ref2[_i];
        names.push.apply(names, param.names());
      }
      return names;
    };

    Code.prototype.traverseChildren = function(crossScope, func) {
      if (crossScope) {
        return Code.__super__.traverseChildren.call(this, crossScope, func);
      }
    };

    return Code;

  })(Base);

  exports.Param = Param = (function(_super) {

    __extends(Param, _super);

    function Param(name, value, splat) {
      var _ref2;
      this.name = name;
      this.value = value;
      this.splat = splat;
      if (_ref2 = (name = this.name.unwrapAll().value), __indexOf.call(STRICT_PROSCRIBED, _ref2) &gt;= 0) {
        throw SyntaxError(&quot;parameter name \&quot;&quot; + name + &quot;\&quot; is not allowed&quot;);
      }
    }

    Param.prototype.children = [&#039;name&#039;, &#039;value&#039;];

    Param.prototype.compile = function(o) {
      return this.name.compile(o, LEVEL_LIST);
    };

    Param.prototype.asReference = function(o) {
      var node;
      if (this.reference) {
        return this.reference;
      }
      node = this.name;
      if (node[&quot;this&quot;]) {
        node = node.properties[0].name;
        if (node.value.reserved) {
          node = new Literal(o.scope.freeVariable(node.value));
        }
      } else if (node.isComplex()) {
        node = new Literal(o.scope.freeVariable(&#039;arg&#039;));
      }
      node = new Value(node);
      if (this.splat) {
        node = new Splat(node);
      }
      return this.reference = node;
    };

    Param.prototype.isComplex = function() {
      return this.name.isComplex();
    };

    Param.prototype.names = function(name) {
      var atParam, names, obj, _i, _len, _ref2;
      if (name == null) {
        name = this.name;
      }
      atParam = function(obj) {
        var value;
        value = obj.properties[0].name.value;
        if (value.reserved) {
          return [];
        } else {
          return [value];
        }
      };
      if (name instanceof Literal) {
        return [name.value];
      }
      if (name instanceof Value) {
        return atParam(name);
      }
      names = [];
      _ref2 = name.objects;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        obj = _ref2[_i];
        if (obj instanceof Assign) {
          names.push(obj.value.unwrap().value);
        } else if (obj instanceof Splat) {
          names.push(obj.name.unwrap().value);
        } else if (obj instanceof Value) {
          if (obj.isArray() || obj.isObject()) {
            names.push.apply(names, this.names(obj.base));
          } else if (obj[&quot;this&quot;]) {
            names.push.apply(names, atParam(obj));
          } else {
            names.push(obj.base.value);
          }
        } else {
          throw SyntaxError(&quot;illegal parameter &quot; + (obj.compile()));
        }
      }
      return names;
    };

    return Param;

  })(Base);

  exports.Splat = Splat = (function(_super) {

    __extends(Splat, _super);

    Splat.prototype.children = [&#039;name&#039;];

    Splat.prototype.isAssignable = YES;

    function Splat(name) {
      this.name = name.compile ? name : new Literal(name);
    }

    Splat.prototype.assigns = function(name) {
      return this.name.assigns(name);
    };

    Splat.prototype.compile = function(o) {
      if (this.index != null) {
        return this.compileParam(o);
      } else {
        return this.name.compile(o);
      }
    };

    Splat.prototype.unwrap = function() {
      return this.name;
    };

    Splat.compileSplattedArray = function(o, list, apply) {
      var args, base, code, i, index, node, _i, _len;
      index = -1;
      while ((node = list[++index]) &amp;&amp; !(node instanceof Splat)) {
        continue;
      }
      if (index &gt;= list.length) {
        return &#039;&#039;;
      }
      if (list.length === 1) {
        code = list[0].compile(o, LEVEL_LIST);
        if (apply) {
          return code;
        }
        return &quot;&quot; + (utility(&#039;slice&#039;)) + &quot;.call(&quot; + code + &quot;)&quot;;
      }
      args = list.slice(index);
      for (i = _i = 0, _len = args.length; _i &lt; _len; i = ++_i) {
        node = args[i];
        code = node.compile(o, LEVEL_LIST);
        args[i] = node instanceof Splat ? &quot;&quot; + (utility(&#039;slice&#039;)) + &quot;.call(&quot; + code + &quot;)&quot; : &quot;[&quot; + code + &quot;]&quot;;
      }
      if (index === 0) {
        return args[0] + (&quot;.concat(&quot; + (args.slice(1).join(&#039;, &#039;)) + &quot;)&quot;);
      }
      base = (function() {
        var _j, _len1, _ref2, _results;
        _ref2 = list.slice(0, index);
        _results = [];
        for (_j = 0, _len1 = _ref2.length; _j &lt; _len1; _j++) {
          node = _ref2[_j];
          _results.push(node.compile(o, LEVEL_LIST));
        }
        return _results;
      })();
      return &quot;[&quot; + (base.join(&#039;, &#039;)) + &quot;].concat(&quot; + (args.join(&#039;, &#039;)) + &quot;)&quot;;
    };

    return Splat;

  })(Base);

  exports.While = While = (function(_super) {

    __extends(While, _super);

    function While(condition, options) {
      this.condition = (options != null ? options.invert : void 0) ? condition.invert() : condition;
      this.guard = options != null ? options.guard : void 0;
    }

    While.prototype.children = [&#039;condition&#039;, &#039;guard&#039;, &#039;body&#039;];

    While.prototype.isStatement = YES;

    While.prototype.makeReturn = function(res) {
      if (res) {
        return While.__super__.makeReturn.apply(this, arguments);
      } else {
        this.returns = !this.jumps({
          loop: true
        });
        return this;
      }
    };

    While.prototype.addBody = function(body) {
      this.body = body;
      return this;
    };

    While.prototype.jumps = function() {
      var expressions, node, _i, _len;
      expressions = this.body.expressions;
      if (!expressions.length) {
        return false;
      }
      for (_i = 0, _len = expressions.length; _i &lt; _len; _i++) {
        node = expressions[_i];
        if (node.jumps({
          loop: true
        })) {
          return node;
        }
      }
      return false;
    };

    While.prototype.compileNode = function(o) {
      var body, code, rvar, set;
      o.indent += TAB;
      set = &#039;&#039;;
      body = this.body;
      if (body.isEmpty()) {
        body = &#039;&#039;;
      } else {
        if (this.returns) {
          body.makeReturn(rvar = o.scope.freeVariable(&#039;results&#039;));
          set = &quot;&quot; + this.tab + rvar + &quot; = [];\n&quot;;
        }
        if (this.guard) {
          if (body.expressions.length &gt; 1) {
            body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal(&quot;continue&quot;)));
          } else {
            if (this.guard) {
              body = Block.wrap([new If(this.guard, body)]);
            }
          }
        }
        body = &quot;\n&quot; + (body.compile(o, LEVEL_TOP)) + &quot;\n&quot; + this.tab;
      }
      code = set + this.tab + (&quot;while (&quot; + (this.condition.compile(o, LEVEL_PAREN)) + &quot;) {&quot; + body + &quot;}&quot;);
      if (this.returns) {
        code += &quot;\n&quot; + this.tab + &quot;return &quot; + rvar + &quot;;&quot;;
      }
      return code;
    };

    return While;

  })(Base);

  exports.Op = Op = (function(_super) {
    var CONVERSIONS, INVERSIONS;

    __extends(Op, _super);

    function Op(op, first, second, flip) {
      if (op === &#039;in&#039;) {
        return new In(first, second);
      }
      if (op === &#039;do&#039;) {
        return this.generateDo(first);
      }
      if (op === &#039;new&#039;) {
        if (first instanceof Call &amp;&amp; !first[&quot;do&quot;] &amp;&amp; !first.isNew) {
          return first.newInstance();
        }
        if (first instanceof Code &amp;&amp; first.bound || first[&quot;do&quot;]) {
          first = new Parens(first);
        }
      }
      this.operator = CONVERSIONS[op] || op;
      this.first = first;
      this.second = second;
      this.flip = !!flip;
      return this;
    }

    CONVERSIONS = {
      &#039;==&#039;: &#039;===&#039;,
      &#039;!=&#039;: &#039;!==&#039;,
      &#039;of&#039;: &#039;in&#039;
    };

    INVERSIONS = {
      &#039;!==&#039;: &#039;===&#039;,
      &#039;===&#039;: &#039;!==&#039;
    };

    Op.prototype.children = [&#039;first&#039;, &#039;second&#039;];

    Op.prototype.isSimpleNumber = NO;

    Op.prototype.isUnary = function() {
      return !this.second;
    };

    Op.prototype.isComplex = function() {
      var _ref2;
      return !(this.isUnary() &amp;&amp; ((_ref2 = this.operator) === &#039;+&#039; || _ref2 === &#039;-&#039;)) || this.first.isComplex();
    };

    Op.prototype.isChainable = function() {
      var _ref2;
      return (_ref2 = this.operator) === &#039;&lt;&#039; || _ref2 === &#039;&gt;&#039; || _ref2 === &#039;&gt;=&#039; || _ref2 === &#039;&lt;=&#039; || _ref2 === &#039;===&#039; || _ref2 === &#039;!==&#039;;
    };

    Op.prototype.invert = function() {
      var allInvertable, curr, fst, op, _ref2;
      if (this.isChainable() &amp;&amp; this.first.isChainable()) {
        allInvertable = true;
        curr = this;
        while (curr &amp;&amp; curr.operator) {
          allInvertable &amp;&amp; (allInvertable = curr.operator in INVERSIONS);
          curr = curr.first;
        }
        if (!allInvertable) {
          return new Parens(this).invert();
        }
        curr = this;
        while (curr &amp;&amp; curr.operator) {
          curr.invert = !curr.invert;
          curr.operator = INVERSIONS[curr.operator];
          curr = curr.first;
        }
        return this;
      } else if (op = INVERSIONS[this.operator]) {
        this.operator = op;
        if (this.first.unwrap() instanceof Op) {
          this.first.invert();
        }
        return this;
      } else if (this.second) {
        return new Parens(this).invert();
      } else if (this.operator === &#039;!&#039; &amp;&amp; (fst = this.first.unwrap()) instanceof Op &amp;&amp; ((_ref2 = fst.operator) === &#039;!&#039; || _ref2 === &#039;in&#039; || _ref2 === &#039;instanceof&#039;)) {
        return fst;
      } else {
        return new Op(&#039;!&#039;, this);
      }
    };

    Op.prototype.unfoldSoak = function(o) {
      var _ref2;
      return ((_ref2 = this.operator) === &#039;++&#039; || _ref2 === &#039;--&#039; || _ref2 === &#039;delete&#039;) &amp;&amp; unfoldSoak(o, this, &#039;first&#039;);
    };

    Op.prototype.generateDo = function(exp) {
      var call, func, param, passedParams, ref, _i, _len, _ref2;
      passedParams = [];
      func = exp instanceof Assign &amp;&amp; (ref = exp.value.unwrap()) instanceof Code ? ref : exp;
      _ref2 = func.params || [];
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        param = _ref2[_i];
        if (param.value) {
          passedParams.push(param.value);
          delete param.value;
        } else {
          passedParams.push(param);
        }
      }
      call = new Call(exp, passedParams);
      call[&quot;do&quot;] = true;
      return call;
    };

    Op.prototype.compileNode = function(o) {
      var code, isChain, _ref2, _ref3;
      isChain = this.isChainable() &amp;&amp; this.first.isChainable();
      if (!isChain) {
        this.first.front = this.front;
      }
      if (this.operator === &#039;delete&#039; &amp;&amp; o.scope.check(this.first.unwrapAll().value)) {
        throw SyntaxError(&#039;delete operand may not be argument or var&#039;);
      }
      if (((_ref2 = this.operator) === &#039;--&#039; || _ref2 === &#039;++&#039;) &amp;&amp; (_ref3 = this.first.unwrapAll().value, __indexOf.call(STRICT_PROSCRIBED, _ref3) &gt;= 0)) {
        throw SyntaxError(&#039;prefix increment/decrement may not have eval or arguments operand&#039;);
      }
      if (this.isUnary()) {
        return this.compileUnary(o);
      }
      if (isChain) {
        return this.compileChain(o);
      }
      if (this.operator === &#039;?&#039;) {
        return this.compileExistence(o);
      }
      code = this.first.compile(o, LEVEL_OP) + &#039; &#039; + this.operator + &#039; &#039; + this.second.compile(o, LEVEL_OP);
      if (o.level &lt;= LEVEL_OP) {
        return code;
      } else {
        return &quot;(&quot; + code + &quot;)&quot;;
      }
    };

    Op.prototype.compileChain = function(o) {
      var code, fst, shared, _ref2;
      _ref2 = this.first.second.cache(o), this.first.second = _ref2[0], shared = _ref2[1];
      fst = this.first.compile(o, LEVEL_OP);
      code = &quot;&quot; + fst + &quot; &quot; + (this.invert ? &#039;&amp;&amp;&#039; : &#039;||&#039;) + &quot; &quot; + (shared.compile(o)) + &quot; &quot; + this.operator + &quot; &quot; + (this.second.compile(o, LEVEL_OP));
      return &quot;(&quot; + code + &quot;)&quot;;
    };

    Op.prototype.compileExistence = function(o) {
      var fst, ref;
      if (this.first.isComplex()) {
        ref = new Literal(o.scope.freeVariable(&#039;ref&#039;));
        fst = new Parens(new Assign(ref, this.first));
      } else {
        fst = this.first;
        ref = fst;
      }
      return new If(new Existence(fst), ref, {
        type: &#039;if&#039;
      }).addElse(this.second).compile(o);
    };

    Op.prototype.compileUnary = function(o) {
      var op, parts, plusMinus;
      if (o.level &gt;= LEVEL_ACCESS) {
        return (new Parens(this)).compile(o);
      }
      parts = [op = this.operator];
      plusMinus = op === &#039;+&#039; || op === &#039;-&#039;;
      if ((op === &#039;new&#039; || op === &#039;typeof&#039; || op === &#039;delete&#039;) || plusMinus &amp;&amp; this.first instanceof Op &amp;&amp; this.first.operator === op) {
        parts.push(&#039; &#039;);
      }
      if ((plusMinus &amp;&amp; this.first instanceof Op) || (op === &#039;new&#039; &amp;&amp; this.first.isStatement(o))) {
        this.first = new Parens(this.first);
      }
      parts.push(this.first.compile(o, LEVEL_OP));
      if (this.flip) {
        parts.reverse();
      }
      return parts.join(&#039;&#039;);
    };

    Op.prototype.toString = function(idt) {
      return Op.__super__.toString.call(this, idt, this.constructor.name + &#039; &#039; + this.operator);
    };

    return Op;

  })(Base);

  exports.In = In = (function(_super) {

    __extends(In, _super);

    function In(object, array) {
      this.object = object;
      this.array = array;
    }

    In.prototype.children = [&#039;object&#039;, &#039;array&#039;];

    In.prototype.invert = NEGATE;

    In.prototype.compileNode = function(o) {
      var hasSplat, obj, _i, _len, _ref2;
      if (this.array instanceof Value &amp;&amp; this.array.isArray()) {
        _ref2 = this.array.base.objects;
        for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
          obj = _ref2[_i];
          if (!(obj instanceof Splat)) {
            continue;
          }
          hasSplat = true;
          break;
        }
        if (!hasSplat) {
          return this.compileOrTest(o);
        }
      }
      return this.compileLoopTest(o);
    };

    In.prototype.compileOrTest = function(o) {
      var cmp, cnj, i, item, ref, sub, tests, _ref2, _ref3;
      if (this.array.base.objects.length === 0) {
        return &quot;&quot; + (!!this.negated);
      }
      _ref2 = this.object.cache(o, LEVEL_OP), sub = _ref2[0], ref = _ref2[1];
      _ref3 = this.negated ? [&#039; !== &#039;, &#039; &amp;&amp; &#039;] : [&#039; === &#039;, &#039; || &#039;], cmp = _ref3[0], cnj = _ref3[1];
      tests = (function() {
        var _i, _len, _ref4, _results;
        _ref4 = this.array.base.objects;
        _results = [];
        for (i = _i = 0, _len = _ref4.length; _i &lt; _len; i = ++_i) {
          item = _ref4[i];
          _results.push((i ? ref : sub) + cmp + item.compile(o, LEVEL_ACCESS));
        }
        return _results;
      }).call(this);
      tests = tests.join(cnj);
      if (o.level &lt; LEVEL_OP) {
        return tests;
      } else {
        return &quot;(&quot; + tests + &quot;)&quot;;
      }
    };

    In.prototype.compileLoopTest = function(o) {
      var code, ref, sub, _ref2;
      _ref2 = this.object.cache(o, LEVEL_LIST), sub = _ref2[0], ref = _ref2[1];
      code = utility(&#039;indexOf&#039;) + (&quot;.call(&quot; + (this.array.compile(o, LEVEL_LIST)) + &quot;, &quot; + ref + &quot;) &quot;) + (this.negated ? &#039;&lt; 0&#039; : &#039;&gt;= 0&#039;);
      if (sub === ref) {
        return code;
      }
      code = sub + &#039;, &#039; + code;
      if (o.level &lt; LEVEL_LIST) {
        return code;
      } else {
        return &quot;(&quot; + code + &quot;)&quot;;
      }
    };

    In.prototype.toString = function(idt) {
      return In.__super__.toString.call(this, idt, this.constructor.name + (this.negated ? &#039;!&#039; : &#039;&#039;));
    };

    return In;

  })(Base);

  exports.Try = Try = (function(_super) {

    __extends(Try, _super);

    function Try(attempt, error, recovery, ensure) {
      this.attempt = attempt;
      this.error = error;
      this.recovery = recovery;
      this.ensure = ensure;
    }

    Try.prototype.children = [&#039;attempt&#039;, &#039;recovery&#039;, &#039;ensure&#039;];

    Try.prototype.isStatement = YES;

    Try.prototype.jumps = function(o) {
      var _ref2;
      return this.attempt.jumps(o) || ((_ref2 = this.recovery) != null ? _ref2.jumps(o) : void 0);
    };

    Try.prototype.makeReturn = function(res) {
      if (this.attempt) {
        this.attempt = this.attempt.makeReturn(res);
      }
      if (this.recovery) {
        this.recovery = this.recovery.makeReturn(res);
      }
      return this;
    };

    Try.prototype.compileNode = function(o) {
      var catchPart, ensurePart, errorPart, tryPart;
      o.indent += TAB;
      errorPart = this.error ? &quot; (&quot; + (this.error.compile(o)) + &quot;) &quot; : &#039; &#039;;
      tryPart = this.attempt.compile(o, LEVEL_TOP);
      catchPart = (function() {
        var _ref2;
        if (this.recovery) {
          if (_ref2 = this.error.value, __indexOf.call(STRICT_PROSCRIBED, _ref2) &gt;= 0) {
            throw SyntaxError(&quot;catch variable may not be \&quot;&quot; + this.error.value + &quot;\&quot;&quot;);
          }
          if (!o.scope.check(this.error.value)) {
            o.scope.add(this.error.value, &#039;param&#039;);
          }
          return &quot; catch&quot; + errorPart + &quot;{\n&quot; + (this.recovery.compile(o, LEVEL_TOP)) + &quot;\n&quot; + this.tab + &quot;}&quot;;
        } else if (!(this.ensure || this.recovery)) {
          return &#039; catch (_error) {}&#039;;
        }
      }).call(this);
      ensurePart = this.ensure ? &quot; finally {\n&quot; + (this.ensure.compile(o, LEVEL_TOP)) + &quot;\n&quot; + this.tab + &quot;}&quot; : &#039;&#039;;
      return &quot;&quot; + this.tab + &quot;try {\n&quot; + tryPart + &quot;\n&quot; + this.tab + &quot;}&quot; + (catchPart || &#039;&#039;) + ensurePart;
    };

    return Try;

  })(Base);

  exports.Throw = Throw = (function(_super) {

    __extends(Throw, _super);

    function Throw(expression) {
      this.expression = expression;
    }

    Throw.prototype.children = [&#039;expression&#039;];

    Throw.prototype.isStatement = YES;

    Throw.prototype.jumps = NO;

    Throw.prototype.makeReturn = THIS;

    Throw.prototype.compileNode = function(o) {
      return this.tab + (&quot;throw &quot; + (this.expression.compile(o)) + &quot;;&quot;);
    };

    return Throw;

  })(Base);

  exports.Existence = Existence = (function(_super) {

    __extends(Existence, _super);

    function Existence(expression) {
      this.expression = expression;
    }

    Existence.prototype.children = [&#039;expression&#039;];

    Existence.prototype.invert = NEGATE;

    Existence.prototype.compileNode = function(o) {
      var cmp, cnj, code, _ref2;
      this.expression.front = this.front;
      code = this.expression.compile(o, LEVEL_OP);
      if (IDENTIFIER.test(code) &amp;&amp; !o.scope.check(code)) {
        _ref2 = this.negated ? [&#039;===&#039;, &#039;||&#039;] : [&#039;!==&#039;, &#039;&amp;&amp;&#039;], cmp = _ref2[0], cnj = _ref2[1];
        code = &quot;typeof &quot; + code + &quot; &quot; + cmp + &quot; \&quot;undefined\&quot; &quot; + cnj + &quot; &quot; + code + &quot; &quot; + cmp + &quot; null&quot;;
      } else {
        code = &quot;&quot; + code + &quot; &quot; + (this.negated ? &#039;==&#039; : &#039;!=&#039;) + &quot; null&quot;;
      }
      if (o.level &lt;= LEVEL_COND) {
        return code;
      } else {
        return &quot;(&quot; + code + &quot;)&quot;;
      }
    };

    return Existence;

  })(Base);

  exports.Parens = Parens = (function(_super) {

    __extends(Parens, _super);

    function Parens(body) {
      this.body = body;
    }

    Parens.prototype.children = [&#039;body&#039;];

    Parens.prototype.unwrap = function() {
      return this.body;
    };

    Parens.prototype.isComplex = function() {
      return this.body.isComplex();
    };

    Parens.prototype.compileNode = function(o) {
      var bare, code, expr;
      expr = this.body.unwrap();
      if (expr instanceof Value &amp;&amp; expr.isAtomic()) {
        expr.front = this.front;
        return expr.compile(o);
      }
      code = expr.compile(o, LEVEL_PAREN);
      bare = o.level &lt; LEVEL_OP &amp;&amp; (expr instanceof Op || expr instanceof Call || (expr instanceof For &amp;&amp; expr.returns));
      if (bare) {
        return code;
      } else {
        return &quot;(&quot; + code + &quot;)&quot;;
      }
    };

    return Parens;

  })(Base);

  exports.For = For = (function(_super) {

    __extends(For, _super);

    function For(body, source) {
      var _ref2;
      this.source = source.source, this.guard = source.guard, this.step = source.step, this.name = source.name, this.index = source.index;
      this.body = Block.wrap([body]);
      this.own = !!source.own;
      this.object = !!source.object;
      if (this.object) {
        _ref2 = [this.index, this.name], this.name = _ref2[0], this.index = _ref2[1];
      }
      if (this.index instanceof Value) {
        throw SyntaxError(&#039;index cannot be a pattern matching expression&#039;);
      }
      this.range = this.source instanceof Value &amp;&amp; this.source.base instanceof Range &amp;&amp; !this.source.properties.length;
      this.pattern = this.name instanceof Value;
      if (this.range &amp;&amp; this.index) {
        throw SyntaxError(&#039;indexes do not apply to range loops&#039;);
      }
      if (this.range &amp;&amp; this.pattern) {
        throw SyntaxError(&#039;cannot pattern match over range loops&#039;);
      }
      this.returns = false;
    }

    For.prototype.children = [&#039;body&#039;, &#039;source&#039;, &#039;guard&#039;, &#039;step&#039;];

    For.prototype.compileNode = function(o) {
      var body, defPart, forPart, forVarPart, guardPart, idt1, index, ivar, kvar, kvarAssign, lastJumps, lvar, name, namePart, ref, resultPart, returnResult, rvar, scope, source, stepPart, stepvar, svar, varPart, _ref2;
      body = Block.wrap([this.body]);
      lastJumps = (_ref2 = last(body.expressions)) != null ? _ref2.jumps() : void 0;
      if (lastJumps &amp;&amp; lastJumps instanceof Return) {
        this.returns = false;
      }
      source = this.range ? this.source.base : this.source;
      scope = o.scope;
      name = this.name &amp;&amp; this.name.compile(o, LEVEL_LIST);
      index = this.index &amp;&amp; this.index.compile(o, LEVEL_LIST);
      if (name &amp;&amp; !this.pattern) {
        scope.find(name);
      }
      if (index) {
        scope.find(index);
      }
      if (this.returns) {
        rvar = scope.freeVariable(&#039;results&#039;);
      }
      ivar = (this.object &amp;&amp; index) || scope.freeVariable(&#039;i&#039;);
      kvar = (this.range &amp;&amp; name) || index || ivar;
      kvarAssign = kvar !== ivar ? &quot;&quot; + kvar + &quot; = &quot; : &quot;&quot;;
      if (this.step &amp;&amp; !this.range) {
        stepvar = scope.freeVariable(&quot;step&quot;);
      }
      if (this.pattern) {
        name = ivar;
      }
      varPart = &#039;&#039;;
      guardPart = &#039;&#039;;
      defPart = &#039;&#039;;
      idt1 = this.tab + TAB;
      if (this.range) {
        forPart = source.compile(merge(o, {
          index: ivar,
          name: name,
          step: this.step
        }));
      } else {
        svar = this.source.compile(o, LEVEL_LIST);
        if ((name || this.own) &amp;&amp; !IDENTIFIER.test(svar)) {
          defPart = &quot;&quot; + this.tab + (ref = scope.freeVariable(&#039;ref&#039;)) + &quot; = &quot; + svar + &quot;;\n&quot;;
          svar = ref;
        }
        if (name &amp;&amp; !this.pattern) {
          namePart = &quot;&quot; + name + &quot; = &quot; + svar + &quot;[&quot; + kvar + &quot;]&quot;;
        }
        if (!this.object) {
          lvar = scope.freeVariable(&#039;len&#039;);
          forVarPart = &quot;&quot; + kvarAssign + ivar + &quot; = 0, &quot; + lvar + &quot; = &quot; + svar + &quot;.length&quot;;
          if (this.step) {
            forVarPart += &quot;, &quot; + stepvar + &quot; = &quot; + (this.step.compile(o, LEVEL_OP));
          }
          stepPart = &quot;&quot; + kvarAssign + (this.step ? &quot;&quot; + ivar + &quot; += &quot; + stepvar : (kvar !== ivar ? &quot;++&quot; + ivar : &quot;&quot; + ivar + &quot;++&quot;));
          forPart = &quot;&quot; + forVarPart + &quot;; &quot; + ivar + &quot; &lt; &quot; + lvar + &quot;; &quot; + stepPart;
        }
      }
      if (this.returns) {
        resultPart = &quot;&quot; + this.tab + rvar + &quot; = [];\n&quot;;
        returnResult = &quot;\n&quot; + this.tab + &quot;return &quot; + rvar + &quot;;&quot;;
        body.makeReturn(rvar);
      }
      if (this.guard) {
        if (body.expressions.length &gt; 1) {
          body.expressions.unshift(new If((new Parens(this.guard)).invert(), new Literal(&quot;continue&quot;)));
        } else {
          if (this.guard) {
            body = Block.wrap([new If(this.guard, body)]);
          }
        }
      }
      if (this.pattern) {
        body.expressions.unshift(new Assign(this.name, new Literal(&quot;&quot; + svar + &quot;[&quot; + kvar + &quot;]&quot;)));
      }
      defPart += this.pluckDirectCall(o, body);
      if (namePart) {
        varPart = &quot;\n&quot; + idt1 + namePart + &quot;;&quot;;
      }
      if (this.object) {
        forPart = &quot;&quot; + kvar + &quot; in &quot; + svar;
        if (this.own) {
          guardPart = &quot;\n&quot; + idt1 + &quot;if (!&quot; + (utility(&#039;hasProp&#039;)) + &quot;.call(&quot; + svar + &quot;, &quot; + kvar + &quot;)) continue;&quot;;
        }
      }
      body = body.compile(merge(o, {
        indent: idt1
      }), LEVEL_TOP);
      if (body) {
        body = &#039;\n&#039; + body + &#039;\n&#039;;
      }
      return &quot;&quot; + defPart + (resultPart || &#039;&#039;) + this.tab + &quot;for (&quot; + forPart + &quot;) {&quot; + guardPart + varPart + body + this.tab + &quot;}&quot; + (returnResult || &#039;&#039;);
    };

    For.prototype.pluckDirectCall = function(o, body) {
      var base, defs, expr, fn, idx, ref, val, _i, _len, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      defs = &#039;&#039;;
      _ref2 = body.expressions;
      for (idx = _i = 0, _len = _ref2.length; _i &lt; _len; idx = ++_i) {
        expr = _ref2[idx];
        expr = expr.unwrapAll();
        if (!(expr instanceof Call)) {
          continue;
        }
        val = expr.variable.unwrapAll();
        if (!((val instanceof Code) || (val instanceof Value &amp;&amp; ((_ref3 = val.base) != null ? _ref3.unwrapAll() : void 0) instanceof Code &amp;&amp; val.properties.length === 1 &amp;&amp; ((_ref4 = (_ref5 = val.properties[0].name) != null ? _ref5.value : void 0) === &#039;call&#039; || _ref4 === &#039;apply&#039;)))) {
          continue;
        }
        fn = ((_ref6 = val.base) != null ? _ref6.unwrapAll() : void 0) || val;
        ref = new Literal(o.scope.freeVariable(&#039;fn&#039;));
        base = new Value(ref);
        if (val.base) {
          _ref7 = [base, val], val.base = _ref7[0], base = _ref7[1];
        }
        body.expressions[idx] = new Call(base, expr.args);
        defs += this.tab + new Assign(ref, fn).compile(o, LEVEL_TOP) + &#039;;\n&#039;;
      }
      return defs;
    };

    return For;

  })(While);

  exports.Switch = Switch = (function(_super) {

    __extends(Switch, _super);

    function Switch(subject, cases, otherwise) {
      this.subject = subject;
      this.cases = cases;
      this.otherwise = otherwise;
    }

    Switch.prototype.children = [&#039;subject&#039;, &#039;cases&#039;, &#039;otherwise&#039;];

    Switch.prototype.isStatement = YES;

    Switch.prototype.jumps = function(o) {
      var block, conds, _i, _len, _ref2, _ref3, _ref4;
      if (o == null) {
        o = {
          block: true
        };
      }
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        _ref3 = _ref2[_i], conds = _ref3[0], block = _ref3[1];
        if (block.jumps(o)) {
          return block;
        }
      }
      return (_ref4 = this.otherwise) != null ? _ref4.jumps(o) : void 0;
    };

    Switch.prototype.makeReturn = function(res) {
      var pair, _i, _len, _ref2, _ref3;
      _ref2 = this.cases;
      for (_i = 0, _len = _ref2.length; _i &lt; _len; _i++) {
        pair = _ref2[_i];
        pair[1].makeReturn(res);
      }
      if (res) {
        this.otherwise || (this.otherwise = new Block([new Literal(&#039;void 0&#039;)]));
      }
      if ((_ref3 = this.otherwise) != null) {
        _ref3.makeReturn(res);
      }
      return this;
    };

    Switch.prototype.compileNode = function(o) {
      var block, body, code, cond, conditions, expr, i, idt1, idt2, _i, _j, _len, _len1, _ref2, _ref3, _ref4, _ref5;
      idt1 = o.indent + TAB;
      idt2 = o.indent = idt1 + TAB;
      code = this.tab + (&quot;switch (&quot; + (((_ref2 = this.subject) != null ? _ref2.compile(o, LEVEL_PAREN) : void 0) || false) + &quot;) {\n&quot;);
      _ref3 = this.cases;
      for (i = _i = 0, _len = _ref3.length; _i &lt; _len; i = ++_i) {
        _ref4 = _ref3[i], conditions = _ref4[0], block = _ref4[1];
        _ref5 = flatten([conditions]);
        for (_j = 0, _len1 = _ref5.length; _j &lt; _len1; _j++) {
          cond = _ref5[_j];
          if (!this.subject) {
            cond = cond.invert();
          }
          code += idt1 + (&quot;case &quot; + (cond.compile(o, LEVEL_PAREN)) + &quot;:\n&quot;);
        }
        if (body = block.compile(o, LEVEL_TOP)) {
          code += body + &#039;\n&#039;;
        }
        if (i === this.cases.length - 1 &amp;&amp; !this.otherwise) {
          break;
        }
        expr = this.lastNonComment(block.expressions);
        if (expr instanceof Return || (expr instanceof Literal &amp;&amp; expr.jumps() &amp;&amp; expr.value !== &#039;debugger&#039;)) {
          continue;
        }
        code += idt2 + &#039;break;\n&#039;;
      }
      if (this.otherwise &amp;&amp; this.otherwise.expressions.length) {
        code += idt1 + (&quot;default:\n&quot; + (this.otherwise.compile(o, LEVEL_TOP)) + &quot;\n&quot;);
      }
      return code + this.tab + &#039;}&#039;;
    };

    return Switch;

  })(Base);

  exports.If = If = (function(_super) {

    __extends(If, _super);

    function If(condition, body, options) {
      this.body = body;
      if (options == null) {
        options = {};
      }
      this.condition = options.type === &#039;unless&#039; ? condition.invert() : condition;
      this.elseBody = null;
      this.isChain = false;
      this.soak = options.soak;
    }

    If.prototype.children = [&#039;condition&#039;, &#039;body&#039;, &#039;elseBody&#039;];

    If.prototype.bodyNode = function() {
      var _ref2;
      return (_ref2 = this.body) != null ? _ref2.unwrap() : void 0;
    };

    If.prototype.elseBodyNode = function() {
      var _ref2;
      return (_ref2 = this.elseBody) != null ? _ref2.unwrap() : void 0;
    };

    If.prototype.addElse = function(elseBody) {
      if (this.isChain) {
        this.elseBodyNode().addElse(elseBody);
      } else {
        this.isChain = elseBody instanceof If;
        this.elseBody = this.ensureBlock(elseBody);
      }
      return this;
    };

    If.prototype.isStatement = function(o) {
      var _ref2;
      return (o != null ? o.level : void 0) === LEVEL_TOP || this.bodyNode().isStatement(o) || ((_ref2 = this.elseBodyNode()) != null ? _ref2.isStatement(o) : void 0);
    };

    If.prototype.jumps = function(o) {
      var _ref2;
      return this.body.jumps(o) || ((_ref2 = this.elseBody) != null ? _ref2.jumps(o) : void 0);
    };

    If.prototype.compileNode = function(o) {
      if (this.isStatement(o)) {
        return this.compileStatement(o);
      } else {
        return this.compileExpression(o);
      }
    };

    If.prototype.makeReturn = function(res) {
      if (res) {
        this.elseBody || (this.elseBody = new Block([new Literal(&#039;void 0&#039;)]));
      }
      this.body &amp;&amp; (this.body = new Block([this.body.makeReturn(res)]));
      this.elseBody &amp;&amp; (this.elseBody = new Block([this.elseBody.makeReturn(res)]));
      return this;
    };

    If.prototype.ensureBlock = function(node) {
      if (node instanceof Block) {
        return node;
      } else {
        return new Block([node]);
      }
    };

    If.prototype.compileStatement = function(o) {
      var body, child, cond, exeq, ifPart;
      child = del(o, &#039;chainChild&#039;);
      exeq = del(o, &#039;isExistentialEquals&#039;);
      if (exeq) {
        return new If(this.condition.invert(), this.elseBodyNode(), {
          type: &#039;if&#039;
        }).compile(o);
      }
      cond = this.condition.compile(o, LEVEL_PAREN);
      o.indent += TAB;
      body = this.ensureBlock(this.body);
      ifPart = &quot;if (&quot; + cond + &quot;) {\n&quot; + (body.compile(o)) + &quot;\n&quot; + this.tab + &quot;}&quot;;
      if (!child) {
        ifPart = this.tab + ifPart;
      }
      if (!this.elseBody) {
        return ifPart;
      }
      return ifPart + &#039; else &#039; + (this.isChain ? (o.indent = this.tab, o.chainChild = true, this.elseBody.unwrap().compile(o, LEVEL_TOP)) : &quot;{\n&quot; + (this.elseBody.compile(o, LEVEL_TOP)) + &quot;\n&quot; + this.tab + &quot;}&quot;);
    };

    If.prototype.compileExpression = function(o) {
      var alt, body, code, cond;
      cond = this.condition.compile(o, LEVEL_COND);
      body = this.bodyNode().compile(o, LEVEL_LIST);
      alt = this.elseBodyNode() ? this.elseBodyNode().compile(o, LEVEL_LIST) : &#039;void 0&#039;;
      code = &quot;&quot; + cond + &quot; ? &quot; + body + &quot; : &quot; + alt;
      if (o.level &gt;= LEVEL_COND) {
        return &quot;(&quot; + code + &quot;)&quot;;
      } else {
        return code;
      }
    };

    If.prototype.unfoldSoak = function() {
      return this.soak &amp;&amp; this;
    };

    return If;

  })(Base);

  Closure = {
    wrap: function(expressions, statement, noReturn) {
      var args, call, func, mentionsArgs, meth;
      if (expressions.jumps()) {
        return expressions;
      }
      func = new Code([], Block.wrap([expressions]));
      args = [];
      if ((mentionsArgs = expressions.contains(this.literalArgs)) || expressions.contains(this.literalThis)) {
        meth = new Literal(mentionsArgs ? &#039;apply&#039; : &#039;call&#039;);
        args = [new Literal(&#039;this&#039;)];
        if (mentionsArgs) {
          args.push(new Literal(&#039;arguments&#039;));
        }
        func = new Value(func, [new Access(meth)]);
      }
      func.noReturn = noReturn;
      call = new Call(func, args);
      if (statement) {
        return Block.wrap([call]);
      } else {
        return call;
      }
    },
    literalArgs: function(node) {
      return node instanceof Literal &amp;&amp; node.value === &#039;arguments&#039; &amp;&amp; !node.asKey;
    },
    literalThis: function(node) {
      return (node instanceof Literal &amp;&amp; node.value === &#039;this&#039; &amp;&amp; !node.asKey) || (node instanceof Code &amp;&amp; node.bound) || (node instanceof Call &amp;&amp; node.isSuper);
    }
  };

  unfoldSoak = function(o, parent, name) {
    var ifn;
    if (!(ifn = parent[name].unfoldSoak(o))) {
      return;
    }
    parent[name] = ifn.body;
    ifn.body = new Value(parent);
    return ifn;
  };

  UTILITIES = {
    &quot;extends&quot;: function() {
      return &quot;function(child, parent) { for (var key in parent) { if (&quot; + (utility(&#039;hasProp&#039;)) + &quot;.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; }&quot;;
    },
    bind: function() {
      return &#039;function(fn, me){ return function(){ return fn.apply(me, arguments); }; }&#039;;
    },
    indexOf: function() {
      return &quot;[].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; }&quot;;
    },
    hasProp: function() {
      return &#039;{}.hasOwnProperty&#039;;
    },
    slice: function() {
      return &#039;[].slice&#039;;
    }
  };

  LEVEL_TOP = 1;

  LEVEL_PAREN = 2;

  LEVEL_LIST = 3;

  LEVEL_COND = 4;

  LEVEL_OP = 5;

  LEVEL_ACCESS = 6;

  TAB = &#039;  &#039;;

  IDENTIFIER_STR = &quot;[$A-Za-z_\\x7f-\\uffff][$\\w\\x7f-\\uffff]*&quot;;

  IDENTIFIER = RegExp(&quot;^&quot; + IDENTIFIER_STR + &quot;$&quot;);

  SIMPLENUM = /^[+-]?\d+$/;

  METHOD_DEF = RegExp(&quot;^(?:(&quot; + IDENTIFIER_STR + &quot;)\\.prototype(?:\\.(&quot; + IDENTIFIER_STR + &quot;)|\\[(\&quot;(?:[^\\\\\&quot;\\r\\n]|\\\\.)*\&quot;|&#039;(?:[^\\\\&#039;\\r\\n]|\\\\.)*&#039;)\\]|\\[(0x[\\da-fA-F]+|\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\]))|(&quot; + IDENTIFIER_STR + &quot;)$&quot;);

  IS_STRING = /^[&#039;&quot;]/;

  utility = function(name) {
    var ref;
    ref = &quot;__&quot; + name;
    Scope.root.assign(ref, UTILITIES[name]());
    return ref;
  };

  multident = function(code, tab) {
    code = code.replace(/\n/g, &#039;$&amp;&#039; + tab);
    return code.replace(/\s+$/, &#039;&#039;);
  };

}).call(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
