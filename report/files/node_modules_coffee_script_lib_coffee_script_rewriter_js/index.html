<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/coffee-script/lib/coffee-script/rewriter.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/coffee-script/lib/coffee-script/rewriter.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">62.01</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">348</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">131.29</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.69</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// Generated by CoffeeScript 1.3.3
(function() {
  var BALANCED_PAIRS, EXPRESSION_CLOSE, EXPRESSION_END, EXPRESSION_START, IMPLICIT_BLOCK, IMPLICIT_CALL, IMPLICIT_END, IMPLICIT_FUNC, IMPLICIT_UNSPACED_CALL, INVERSES, LINEBREAKS, SINGLE_CLOSERS, SINGLE_LINERS, left, rite, _i, _len, _ref,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i &lt; l; i++) { if (i in this &amp;&amp; this[i] === item) return i; } return -1; },
    __slice = [].slice;

  exports.Rewriter = (function() {

    function Rewriter() {}

    Rewriter.prototype.rewrite = function(tokens) {
      this.tokens = tokens;
      this.removeLeadingNewlines();
      this.removeMidExpressionNewlines();
      this.closeOpenCalls();
      this.closeOpenIndexes();
      this.addImplicitIndentation();
      this.tagPostfixConditionals();
      this.addImplicitBraces();
      this.addImplicitParentheses();
      return this.tokens;
    };

    Rewriter.prototype.scanTokens = function(block) {
      var i, token, tokens;
      tokens = this.tokens;
      i = 0;
      while (token = tokens[i]) {
        i += block.call(this, token, i, tokens);
      }
      return true;
    };

    Rewriter.prototype.detectEnd = function(i, condition, action) {
      var levels, token, tokens, _ref, _ref1;
      tokens = this.tokens;
      levels = 0;
      while (token = tokens[i]) {
        if (levels === 0 &amp;&amp; condition.call(this, token, i)) {
          return action.call(this, token, i);
        }
        if (!token || levels &lt; 0) {
          return action.call(this, token, i - 1);
        }
        if (_ref = token[0], __indexOf.call(EXPRESSION_START, _ref) &gt;= 0) {
          levels += 1;
        } else if (_ref1 = token[0], __indexOf.call(EXPRESSION_END, _ref1) &gt;= 0) {
          levels -= 1;
        }
        i += 1;
      }
      return i - 1;
    };

    Rewriter.prototype.removeLeadingNewlines = function() {
      var i, tag, _i, _len, _ref;
      _ref = this.tokens;
      for (i = _i = 0, _len = _ref.length; _i &lt; _len; i = ++_i) {
        tag = _ref[i][0];
        if (tag !== &#039;TERMINATOR&#039;) {
          break;
        }
      }
      if (i) {
        return this.tokens.splice(0, i);
      }
    };

    Rewriter.prototype.removeMidExpressionNewlines = function() {
      return this.scanTokens(function(token, i, tokens) {
        var _ref;
        if (!(token[0] === &#039;TERMINATOR&#039; &amp;&amp; (_ref = this.tag(i + 1), __indexOf.call(EXPRESSION_CLOSE, _ref) &gt;= 0))) {
          return 1;
        }
        tokens.splice(i, 1);
        return 0;
      });
    };

    Rewriter.prototype.closeOpenCalls = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return ((_ref = token[0]) === &#039;)&#039; || _ref === &#039;CALL_END&#039;) || token[0] === &#039;OUTDENT&#039; &amp;&amp; this.tag(i - 1) === &#039;)&#039;;
      };
      action = function(token, i) {
        return this.tokens[token[0] === &#039;OUTDENT&#039; ? i - 1 : i][0] = &#039;CALL_END&#039;;
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === &#039;CALL_START&#039;) {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.closeOpenIndexes = function() {
      var action, condition;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === &#039;]&#039; || _ref === &#039;INDEX_END&#039;;
      };
      action = function(token, i) {
        return token[0] = &#039;INDEX_END&#039;;
      };
      return this.scanTokens(function(token, i) {
        if (token[0] === &#039;INDEX_START&#039;) {
          this.detectEnd(i + 1, condition, action);
        }
        return 1;
      });
    };

    Rewriter.prototype.addImplicitBraces = function() {
      var action, condition, sameLine, stack, start, startIndent, startIndex, startsLine;
      stack = [];
      start = null;
      startsLine = null;
      sameLine = true;
      startIndent = 0;
      startIndex = 0;
      condition = function(token, i) {
        var one, tag, three, two, _ref, _ref1;
        _ref = this.tokens.slice(i + 1, (i + 3) + 1 || 9e9), one = _ref[0], two = _ref[1], three = _ref[2];
        if (&#039;HERECOMMENT&#039; === (one != null ? one[0] : void 0)) {
          return false;
        }
        tag = token[0];
        if (__indexOf.call(LINEBREAKS, tag) &gt;= 0) {
          sameLine = false;
        }
        return (((tag === &#039;TERMINATOR&#039; || tag === &#039;OUTDENT&#039;) || (__indexOf.call(IMPLICIT_END, tag) &gt;= 0 &amp;&amp; sameLine &amp;&amp; !(i - startIndex === 1))) &amp;&amp; ((!startsLine &amp;&amp; this.tag(i - 1) !== &#039;,&#039;) || !((two != null ? two[0] : void 0) === &#039;:&#039; || (one != null ? one[0] : void 0) === &#039;@&#039; &amp;&amp; (three != null ? three[0] : void 0) === &#039;:&#039;))) || (tag === &#039;,&#039; &amp;&amp; one &amp;&amp; ((_ref1 = one[0]) !== &#039;IDENTIFIER&#039; &amp;&amp; _ref1 !== &#039;NUMBER&#039; &amp;&amp; _ref1 !== &#039;STRING&#039; &amp;&amp; _ref1 !== &#039;@&#039; &amp;&amp; _ref1 !== &#039;TERMINATOR&#039; &amp;&amp; _ref1 !== &#039;OUTDENT&#039;));
      };
      action = function(token, i) {
        var tok;
        tok = this.generate(&#039;}&#039;, &#039;}&#039;, token[2]);
        return this.tokens.splice(i, 0, tok);
      };
      return this.scanTokens(function(token, i, tokens) {
        var ago, idx, prevTag, tag, tok, value, _ref, _ref1;
        if (_ref = (tag = token[0]), __indexOf.call(EXPRESSION_START, _ref) &gt;= 0) {
          stack.push([(tag === &#039;INDENT&#039; &amp;&amp; this.tag(i - 1) === &#039;{&#039; ? &#039;{&#039; : tag), i]);
          return 1;
        }
        if (__indexOf.call(EXPRESSION_END, tag) &gt;= 0) {
          start = stack.pop();
          return 1;
        }
        if (!(tag === &#039;:&#039; &amp;&amp; ((ago = this.tag(i - 2)) === &#039;:&#039; || ((_ref1 = stack[stack.length - 1]) != null ? _ref1[0] : void 0) !== &#039;{&#039;))) {
          return 1;
        }
        sameLine = true;
        startIndex = i + 1;
        stack.push([&#039;{&#039;]);
        idx = ago === &#039;@&#039; ? i - 2 : i - 1;
        while (this.tag(idx - 2) === &#039;HERECOMMENT&#039;) {
          idx -= 2;
        }
        prevTag = this.tag(idx - 1);
        startsLine = !prevTag || (__indexOf.call(LINEBREAKS, prevTag) &gt;= 0);
        value = new String(&#039;{&#039;);
        value.generated = true;
        tok = this.generate(&#039;{&#039;, value, token[2]);
        tokens.splice(idx, 0, tok);
        this.detectEnd(i + 2, condition, action);
        return 2;
      });
    };

    Rewriter.prototype.addImplicitParentheses = function() {
      var action, condition, noCall, seenControl, seenSingle;
      noCall = seenSingle = seenControl = false;
      condition = function(token, i) {
        var post, tag, _ref, _ref1;
        tag = token[0];
        if (!seenSingle &amp;&amp; token.fromThen) {
          return true;
        }
        if (tag === &#039;IF&#039; || tag === &#039;ELSE&#039; || tag === &#039;CATCH&#039; || tag === &#039;-&gt;&#039; || tag === &#039;=&gt;&#039; || tag === &#039;CLASS&#039;) {
          seenSingle = true;
        }
        if (tag === &#039;IF&#039; || tag === &#039;ELSE&#039; || tag === &#039;SWITCH&#039; || tag === &#039;TRY&#039; || tag === &#039;=&#039;) {
          seenControl = true;
        }
        if ((tag === &#039;.&#039; || tag === &#039;?.&#039; || tag === &#039;::&#039;) &amp;&amp; this.tag(i - 1) === &#039;OUTDENT&#039;) {
          return true;
        }
        return !token.generated &amp;&amp; this.tag(i - 1) !== &#039;,&#039; &amp;&amp; (__indexOf.call(IMPLICIT_END, tag) &gt;= 0 || (tag === &#039;INDENT&#039; &amp;&amp; !seenControl)) &amp;&amp; (tag !== &#039;INDENT&#039; || (((_ref = this.tag(i - 2)) !== &#039;CLASS&#039; &amp;&amp; _ref !== &#039;EXTENDS&#039;) &amp;&amp; (_ref1 = this.tag(i - 1), __indexOf.call(IMPLICIT_BLOCK, _ref1) &lt; 0) &amp;&amp; !((post = this.tokens[i + 1]) &amp;&amp; post.generated &amp;&amp; post[0] === &#039;{&#039;)));
      };
      action = function(token, i) {
        return this.tokens.splice(i, 0, this.generate(&#039;CALL_END&#039;, &#039;)&#039;, token[2]));
      };
      return this.scanTokens(function(token, i, tokens) {
        var callObject, current, next, prev, tag, _ref, _ref1, _ref2;
        tag = token[0];
        if (tag === &#039;CLASS&#039; || tag === &#039;IF&#039; || tag === &#039;FOR&#039; || tag === &#039;WHILE&#039;) {
          noCall = true;
        }
        _ref = tokens.slice(i - 1, (i + 1) + 1 || 9e9), prev = _ref[0], current = _ref[1], next = _ref[2];
        callObject = !noCall &amp;&amp; tag === &#039;INDENT&#039; &amp;&amp; next &amp;&amp; next.generated &amp;&amp; next[0] === &#039;{&#039; &amp;&amp; prev &amp;&amp; (_ref1 = prev[0], __indexOf.call(IMPLICIT_FUNC, _ref1) &gt;= 0);
        seenSingle = false;
        seenControl = false;
        if (__indexOf.call(LINEBREAKS, tag) &gt;= 0) {
          noCall = false;
        }
        if (prev &amp;&amp; !prev.spaced &amp;&amp; tag === &#039;?&#039;) {
          token.call = true;
        }
        if (token.fromThen) {
          return 1;
        }
        if (!(callObject || (prev != null ? prev.spaced : void 0) &amp;&amp; (prev.call || (_ref2 = prev[0], __indexOf.call(IMPLICIT_FUNC, _ref2) &gt;= 0)) &amp;&amp; (__indexOf.call(IMPLICIT_CALL, tag) &gt;= 0 || !(token.spaced || token.newLine) &amp;&amp; __indexOf.call(IMPLICIT_UNSPACED_CALL, tag) &gt;= 0))) {
          return 1;
        }
        tokens.splice(i, 0, this.generate(&#039;CALL_START&#039;, &#039;(&#039;, token[2]));
        this.detectEnd(i + 1, condition, action);
        if (prev[0] === &#039;?&#039;) {
          prev[0] = &#039;FUNC_EXIST&#039;;
        }
        return 2;
      });
    };

    Rewriter.prototype.addImplicitIndentation = function() {
      var action, condition, indent, outdent, starter;
      starter = indent = outdent = null;
      condition = function(token, i) {
        var _ref;
        return token[1] !== &#039;;&#039; &amp;&amp; (_ref = token[0], __indexOf.call(SINGLE_CLOSERS, _ref) &gt;= 0) &amp;&amp; !(token[0] === &#039;ELSE&#039; &amp;&amp; (starter !== &#039;IF&#039; &amp;&amp; starter !== &#039;THEN&#039;));
      };
      action = function(token, i) {
        return this.tokens.splice((this.tag(i - 1) === &#039;,&#039; ? i - 1 : i), 0, outdent);
      };
      return this.scanTokens(function(token, i, tokens) {
        var tag, _ref, _ref1;
        tag = token[0];
        if (tag === &#039;TERMINATOR&#039; &amp;&amp; this.tag(i + 1) === &#039;THEN&#039;) {
          tokens.splice(i, 1);
          return 0;
        }
        if (tag === &#039;ELSE&#039; &amp;&amp; this.tag(i - 1) !== &#039;OUTDENT&#039;) {
          tokens.splice.apply(tokens, [i, 0].concat(__slice.call(this.indentation(token))));
          return 2;
        }
        if (tag === &#039;CATCH&#039; &amp;&amp; ((_ref = this.tag(i + 2)) === &#039;OUTDENT&#039; || _ref === &#039;TERMINATOR&#039; || _ref === &#039;FINALLY&#039;)) {
          tokens.splice.apply(tokens, [i + 2, 0].concat(__slice.call(this.indentation(token))));
          return 4;
        }
        if (__indexOf.call(SINGLE_LINERS, tag) &gt;= 0 &amp;&amp; this.tag(i + 1) !== &#039;INDENT&#039; &amp;&amp; !(tag === &#039;ELSE&#039; &amp;&amp; this.tag(i + 1) === &#039;IF&#039;)) {
          starter = tag;
          _ref1 = this.indentation(token, true), indent = _ref1[0], outdent = _ref1[1];
          if (starter === &#039;THEN&#039;) {
            indent.fromThen = true;
          }
          tokens.splice(i + 1, 0, indent);
          this.detectEnd(i + 2, condition, action);
          if (tag === &#039;THEN&#039;) {
            tokens.splice(i, 1);
          }
          return 1;
        }
        return 1;
      });
    };

    Rewriter.prototype.tagPostfixConditionals = function() {
      var action, condition, original;
      original = null;
      condition = function(token, i) {
        var _ref;
        return (_ref = token[0]) === &#039;TERMINATOR&#039; || _ref === &#039;INDENT&#039;;
      };
      action = function(token, i) {
        if (token[0] !== &#039;INDENT&#039; || (token.generated &amp;&amp; !token.fromThen)) {
          return original[0] = &#039;POST_&#039; + original[0];
        }
      };
      return this.scanTokens(function(token, i) {
        if (token[0] !== &#039;IF&#039;) {
          return 1;
        }
        original = token;
        this.detectEnd(i + 1, condition, action);
        return 1;
      });
    };

    Rewriter.prototype.indentation = function(token, implicit) {
      var indent, outdent;
      if (implicit == null) {
        implicit = false;
      }
      indent = [&#039;INDENT&#039;, 2, token[2]];
      outdent = [&#039;OUTDENT&#039;, 2, token[2]];
      if (implicit) {
        indent.generated = outdent.generated = true;
      }
      return [indent, outdent];
    };

    Rewriter.prototype.generate = function(tag, value, line) {
      var tok;
      tok = [tag, value, line];
      tok.generated = true;
      return tok;
    };

    Rewriter.prototype.tag = function(i) {
      var _ref;
      return (_ref = this.tokens[i]) != null ? _ref[0] : void 0;
    };

    return Rewriter;

  })();

  BALANCED_PAIRS = [[&#039;(&#039;, &#039;)&#039;], [&#039;[&#039;, &#039;]&#039;], [&#039;{&#039;, &#039;}&#039;], [&#039;INDENT&#039;, &#039;OUTDENT&#039;], [&#039;CALL_START&#039;, &#039;CALL_END&#039;], [&#039;PARAM_START&#039;, &#039;PARAM_END&#039;], [&#039;INDEX_START&#039;, &#039;INDEX_END&#039;]];

  exports.INVERSES = INVERSES = {};

  EXPRESSION_START = [];

  EXPRESSION_END = [];

  for (_i = 0, _len = BALANCED_PAIRS.length; _i &lt; _len; _i++) {
    _ref = BALANCED_PAIRS[_i], left = _ref[0], rite = _ref[1];
    EXPRESSION_START.push(INVERSES[rite] = left);
    EXPRESSION_END.push(INVERSES[left] = rite);
  }

  EXPRESSION_CLOSE = [&#039;CATCH&#039;, &#039;WHEN&#039;, &#039;ELSE&#039;, &#039;FINALLY&#039;].concat(EXPRESSION_END);

  IMPLICIT_FUNC = [&#039;IDENTIFIER&#039;, &#039;SUPER&#039;, &#039;)&#039;, &#039;CALL_END&#039;, &#039;]&#039;, &#039;INDEX_END&#039;, &#039;@&#039;, &#039;THIS&#039;];

  IMPLICIT_CALL = [&#039;IDENTIFIER&#039;, &#039;NUMBER&#039;, &#039;STRING&#039;, &#039;JS&#039;, &#039;REGEX&#039;, &#039;NEW&#039;, &#039;PARAM_START&#039;, &#039;CLASS&#039;, &#039;IF&#039;, &#039;TRY&#039;, &#039;SWITCH&#039;, &#039;THIS&#039;, &#039;BOOL&#039;, &#039;NULL&#039;, &#039;UNDEFINED&#039;, &#039;UNARY&#039;, &#039;SUPER&#039;, &#039;@&#039;, &#039;-&gt;&#039;, &#039;=&gt;&#039;, &#039;[&#039;, &#039;(&#039;, &#039;{&#039;, &#039;--&#039;, &#039;++&#039;];

  IMPLICIT_UNSPACED_CALL = [&#039;+&#039;, &#039;-&#039;];

  IMPLICIT_BLOCK = [&#039;-&gt;&#039;, &#039;=&gt;&#039;, &#039;{&#039;, &#039;[&#039;, &#039;,&#039;];

  IMPLICIT_END = [&#039;POST_IF&#039;, &#039;FOR&#039;, &#039;WHILE&#039;, &#039;UNTIL&#039;, &#039;WHEN&#039;, &#039;BY&#039;, &#039;LOOP&#039;, &#039;TERMINATOR&#039;];

  SINGLE_LINERS = [&#039;ELSE&#039;, &#039;-&gt;&#039;, &#039;=&gt;&#039;, &#039;TRY&#039;, &#039;FINALLY&#039;, &#039;THEN&#039;];

  SINGLE_CLOSERS = [&#039;TERMINATOR&#039;, &#039;CATCH&#039;, &#039;FINALLY&#039;, &#039;ELSE&#039;, &#039;OUTDENT&#039;, &#039;LEADING_WHEN&#039;];

  LINEBREAKS = [&#039;TERMINATOR&#039;, &#039;INDENT&#039;, &#039;OUTDENT&#039;];

}).call(this);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
