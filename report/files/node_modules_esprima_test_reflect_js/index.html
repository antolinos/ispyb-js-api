<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/esprima/test/reflect.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/esprima/test/reflect.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.26</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">405</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">49.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">10.52</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">// This is modified from Mozilla Reflect.parse test suite (the file is located
// at js/src/tests/js1_8_5/extensions/reflect-parse.js in the source tree).
//
// Some notable changes:
//   * Removed unsupported features (destructuring, let, comprehensions...).
//   * Removed tests for E4X (ECMAScript for XML).
//   * Removed everything related to builder.
//   * Enclosed every &#039;Pattern&#039; construct with a scope.
//   * Tweaked some expected tree to remove generator field.
//   * Removed the test for bug 632030 and bug 632024.

/* -*- Mode: C++; tab-width: 8; indent-tabs-mode: nil; c-basic-offset: 4 -*- */
/*
 * Any copyright is dedicated to the Public Domain.
 * http://creativecommons.org/licenses/publicdomain/
 */

(function (exports) {

function testReflect(Reflect, Pattern) {

function program(elts) { return Pattern({ type: &quot;Program&quot;, body: elts }) }
function exprStmt(expr) { return Pattern({ type: &quot;ExpressionStatement&quot;, expression: expr }) }
function throwStmt(expr) { return Pattern({ type: &quot;ThrowStatement&quot;, argument: expr }) }
function returnStmt(expr) { return Pattern({ type: &quot;ReturnStatement&quot;, argument: expr }) }
function yieldExpr(expr) { return Pattern({ type: &quot;YieldExpression&quot;, argument: expr }) }
function lit(val) { return Pattern({ type: &quot;Literal&quot;, value: val }) }
var thisExpr = Pattern({ type: &quot;ThisExpression&quot; });
function funDecl(id, params, body) { return Pattern({ type: &quot;FunctionDeclaration&quot;,
                                             id: id,
                                             params: params,
                                             defaults: [],
                                             body: body,
                                             rest: null,
                                             generator: false,
                                             expression: false
                                             }) }
function genFunDecl(id, params, body) { return Pattern({ type: &quot;FunctionDeclaration&quot;,
                                                id: id,
                                                params: params,
                                                defaults: [],
                                                body: body,
                                                rest: null,
                                                generator: false,
                                                expression: false
                                                }) }
function declarator(id, init) { return Pattern({ type: &quot;VariableDeclarator&quot;, id: id, init: init }) }
function varDecl(decls) { return Pattern({ type: &quot;VariableDeclaration&quot;, declarations: decls, kind: &quot;var&quot; }) }
function letDecl(decls) { return Pattern({ type: &quot;VariableDeclaration&quot;, declarations: decls, kind: &quot;let&quot; }) }
function constDecl(decls) { return Pattern({ type: &quot;VariableDeclaration&quot;, declarations: decls, kind: &quot;const&quot; }) }
function ident(name) { return Pattern({ type: &quot;Identifier&quot;, name: name }) }
function dotExpr(obj, id) { return Pattern({ type: &quot;MemberExpression&quot;, computed: false, object: obj, property: id }) }
function memExpr(obj, id) { return Pattern({ type: &quot;MemberExpression&quot;, computed: true, object: obj, property: id }) }
function forStmt(init, test, update, body) { return Pattern({ type: &quot;ForStatement&quot;, init: init, test: test, update: update, body: body }) }
function forInStmt(lhs, rhs, body) { return Pattern({ type: &quot;ForInStatement&quot;, left: lhs, right: rhs, body: body, each: false }) }
function forEachInStmt(lhs, rhs, body) { return Pattern({ type: &quot;ForInStatement&quot;, left: lhs, right: rhs, body: body, each: true }) }
function breakStmt(lab) { return Pattern({ type: &quot;BreakStatement&quot;, label: lab }) }
function continueStmt(lab) { return Pattern({ type: &quot;ContinueStatement&quot;, label: lab }) }
function blockStmt(body) { return Pattern({ type: &quot;BlockStatement&quot;, body: body }) }
var emptyStmt = Pattern({ type: &quot;EmptyStatement&quot; });
function ifStmt(test, cons, alt) { return Pattern({ type: &quot;IfStatement&quot;, test: test, alternate: alt, consequent: cons }) }
function labStmt(lab, stmt) { return Pattern({ type: &quot;LabeledStatement&quot;, label: lab, body: stmt }) }
function withStmt(obj, stmt) { return Pattern({ type: &quot;WithStatement&quot;, object: obj, body: stmt }) }
function whileStmt(test, stmt) { return Pattern({ type: &quot;WhileStatement&quot;, test: test, body: stmt }) }
function doStmt(stmt, test) { return Pattern({ type: &quot;DoWhileStatement&quot;, test: test, body: stmt }) }
function switchStmt(disc, cases) { return Pattern({ type: &quot;SwitchStatement&quot;, discriminant: disc, cases: cases }) }
function caseClause(test, stmts) { return Pattern({ type: &quot;SwitchCase&quot;, test: test, consequent: stmts }) }
function defaultClause(stmts) { return Pattern({ type: &quot;SwitchCase&quot;, test: null, consequent: stmts }) }
function catchClause(id, guard, body) { if (guard) { return Pattern({ type: &quot;GuardedCatchClause&quot;, param: id, guard: guard, body: body }) } else { return Pattern({ type: &quot;CatchClause&quot;, param: id, body: body }) } }
function tryStmt(body, guarded, catches, fin) { return Pattern({ type: &quot;TryStatement&quot;, block: body, guardedHandlers: guarded, handlers: catches, finalizer: fin }) }
function letStmt(head, body) { return Pattern({ type: &quot;LetStatement&quot;, head: head, body: body }) }
function funExpr(id, args, body, gen) { return Pattern({ type: &quot;FunctionExpression&quot;,
                                                id: id,
                                                params: args,
                                                defaults: [],
                                                body: body,
                                                rest: null,
                                                generator: false,
                                                expression: false
                                                }) }
function genFunExpr(id, args, body) { return Pattern({ type: &quot;FunctionExpression&quot;,
                                              id: id,
                                              params: args,
                                              defaults: [],
                                              body: body,
                                              rest: null,
                                              generator: false,
                                              expression: false
                                              }) }

function unExpr(op, arg) { return Pattern({ type: &quot;UnaryExpression&quot;, operator: op, argument: arg, prefix: true }) }
function binExpr(op, left, right) { return Pattern({ type: &quot;BinaryExpression&quot;, operator: op, left: left, right: right }) }
function aExpr(op, left, right) { return Pattern({ type: &quot;AssignmentExpression&quot;, operator: op, left: left, right: right }) }
function updExpr(op, arg, prefix) { return Pattern({ type: &quot;UpdateExpression&quot;, operator: op, argument: arg, prefix: prefix }) }
function logExpr(op, left, right) { return Pattern({ type: &quot;LogicalExpression&quot;, operator: op, left: left, right: right }) }

function condExpr(test, cons, alt) { return Pattern({ type: &quot;ConditionalExpression&quot;, test: test, consequent: cons, alternate: alt }) }
function seqExpr(exprs) { return Pattern({ type: &quot;SequenceExpression&quot;, expressions: exprs }) }
function newExpr(callee, args) { return Pattern({ type: &quot;NewExpression&quot;, callee: callee, arguments: args }) }
function callExpr(callee, args) { return Pattern({ type: &quot;CallExpression&quot;, callee: callee, arguments: args }) }
function arrExpr(elts) { return Pattern({ type: &quot;ArrayExpression&quot;, elements: elts }) }
function objExpr(elts) { return Pattern({ type: &quot;ObjectExpression&quot;, properties: elts }) }
function objProp(key, value, kind) { return Pattern({ type: &quot;Property&quot;, key: key, value: value, kind: kind }) }

function arrPatt(elts) { return Pattern({ type: &quot;ArrayPattern&quot;, elements: elts }) }
function objPatt(elts) { return Pattern({ type: &quot;ObjectPattern&quot;, properties: elts }) }

function localSrc(src) { return &quot;(function(){ &quot; + src + &quot; })&quot; }
function localPatt(patt) { return program([exprStmt(funExpr(null, [], blockStmt([patt])))]) }
function blockSrc(src) { return &quot;(function(){ { &quot; + src + &quot; } })&quot; }
function blockPatt(patt) { return program([exprStmt(funExpr(null, [], blockStmt([blockStmt([patt])])))]) }

function assertBlockStmt(src, patt) {
    blockPatt(patt).assert(Reflect.parse(blockSrc(src)));
}

function assertBlockExpr(src, patt) {
    assertBlockStmt(src, exprStmt(patt));
}

function assertBlockDecl(src, patt, builder) {
    blockPatt(patt).assert(Reflect.parse(blockSrc(src), {builder: builder}));
}

function assertLocalStmt(src, patt) {
    localPatt(patt).assert(Reflect.parse(localSrc(src)));
}

function assertLocalExpr(src, patt) {
    assertLocalStmt(src, exprStmt(patt));
}

function assertLocalDecl(src, patt) {
    localPatt(patt).assert(Reflect.parse(localSrc(src)));
}

function assertGlobalStmt(src, patt, builder) {
    program([patt]).assert(Reflect.parse(src, {builder: builder}));
}

function assertGlobalExpr(src, patt, builder) {
    program([exprStmt(patt)]).assert(Reflect.parse(src, {builder: builder}));
    //assertStmt(src, exprStmt(patt));
}

function assertGlobalDecl(src, patt) {
    program([patt]).assert(Reflect.parse(src));
}

function assertProg(src, patt) {
    program(patt).assert(Reflect.parse(src));
}

function assertStmt(src, patt) {
    assertLocalStmt(src, patt);
    assertGlobalStmt(src, patt);
    assertBlockStmt(src, patt);
}

function assertExpr(src, patt) {
    assertLocalExpr(src, patt);
    assertGlobalExpr(src, patt);
    assertBlockExpr(src, patt);
}

function assertDecl(src, patt) {
    assertLocalDecl(src, patt);
    assertGlobalDecl(src, patt);
    assertBlockDecl(src, patt);
}

function assertError(src, errorType) {
    try {
        Reflect.parse(src);
    } catch (e) {
        return;
    }
    throw new Error(&quot;expected &quot; + errorType.name + &quot; for &quot; + uneval(src));
}


// general tests

// NB: These are useful but for now jit-test doesn&#039;t do I/O reliably.

//program(_).assert(Reflect.parse(snarf(&#039;data/flapjax.txt&#039;)));
//program(_).assert(Reflect.parse(snarf(&#039;data/jquery-1.4.2.txt&#039;)));
//program(_).assert(Reflect.parse(snarf(&#039;data/prototype.js&#039;)));
//program(_).assert(Reflect.parse(snarf(&#039;data/dojo.js.uncompressed.js&#039;)));
//program(_).assert(Reflect.parse(snarf(&#039;data/mootools-1.2.4-core-nc.js&#039;)));


// declarations

assertDecl(&quot;var x = 1, y = 2, z = 3&quot;,
           varDecl([declarator(ident(&quot;x&quot;), lit(1)),
                    declarator(ident(&quot;y&quot;), lit(2)),
                    declarator(ident(&quot;z&quot;), lit(3))]));
assertDecl(&quot;var x, y, z&quot;,
           varDecl([declarator(ident(&quot;x&quot;), null),
                    declarator(ident(&quot;y&quot;), null),
                    declarator(ident(&quot;z&quot;), null)]));
assertDecl(&quot;function foo() { }&quot;,
           funDecl(ident(&quot;foo&quot;), [], blockStmt([])));
assertDecl(&quot;function foo() { return 42 }&quot;,
           funDecl(ident(&quot;foo&quot;), [], blockStmt([returnStmt(lit(42))])));


// Bug 591437: rebound args have their defs turned into uses
assertDecl(&quot;function f(a) { function a() { } }&quot;,
           funDecl(ident(&quot;f&quot;), [ident(&quot;a&quot;)], blockStmt([funDecl(ident(&quot;a&quot;), [], blockStmt([]))])));
assertDecl(&quot;function f(a,b,c) { function b() { } }&quot;,
           funDecl(ident(&quot;f&quot;), [ident(&quot;a&quot;),ident(&quot;b&quot;),ident(&quot;c&quot;)], blockStmt([funDecl(ident(&quot;b&quot;), [], blockStmt([]))])));

// expressions

assertExpr(&quot;true&quot;, lit(true));
assertExpr(&quot;false&quot;, lit(false));
assertExpr(&quot;42&quot;, lit(42));
assertExpr(&quot;(/asdf/)&quot;, lit(/asdf/));
assertExpr(&quot;this&quot;, thisExpr);
assertExpr(&quot;foo&quot;, ident(&quot;foo&quot;));
assertExpr(&quot;foo.bar&quot;, dotExpr(ident(&quot;foo&quot;), ident(&quot;bar&quot;)));
assertExpr(&quot;foo[bar]&quot;, memExpr(ident(&quot;foo&quot;), ident(&quot;bar&quot;)));
assertExpr(&quot;(function(){})&quot;, funExpr(null, [], blockStmt([])));
assertExpr(&quot;(function f() {})&quot;, funExpr(ident(&quot;f&quot;), [], blockStmt([])));
assertExpr(&quot;(function f(x,y,z) {})&quot;, funExpr(ident(&quot;f&quot;), [ident(&quot;x&quot;),ident(&quot;y&quot;),ident(&quot;z&quot;)], blockStmt([])));
assertExpr(&quot;(++x)&quot;, updExpr(&quot;++&quot;, ident(&quot;x&quot;), true));
assertExpr(&quot;(x++)&quot;, updExpr(&quot;++&quot;, ident(&quot;x&quot;), false));
assertExpr(&quot;(+x)&quot;, unExpr(&quot;+&quot;, ident(&quot;x&quot;)));
assertExpr(&quot;(-x)&quot;, unExpr(&quot;-&quot;, ident(&quot;x&quot;)));
assertExpr(&quot;(!x)&quot;, unExpr(&quot;!&quot;, ident(&quot;x&quot;)));
assertExpr(&quot;(~x)&quot;, unExpr(&quot;~&quot;, ident(&quot;x&quot;)));
assertExpr(&quot;(delete x)&quot;, unExpr(&quot;delete&quot;, ident(&quot;x&quot;)));
assertExpr(&quot;(typeof x)&quot;, unExpr(&quot;typeof&quot;, ident(&quot;x&quot;)));
assertExpr(&quot;(void x)&quot;, unExpr(&quot;void&quot;, ident(&quot;x&quot;)));
assertExpr(&quot;(x == y)&quot;, binExpr(&quot;==&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x != y)&quot;, binExpr(&quot;!=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x === y)&quot;, binExpr(&quot;===&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x !== y)&quot;, binExpr(&quot;!==&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &lt; y)&quot;, binExpr(&quot;&lt;&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &lt;= y)&quot;, binExpr(&quot;&lt;=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &gt; y)&quot;, binExpr(&quot;&gt;&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &gt;= y)&quot;, binExpr(&quot;&gt;=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &lt;&lt; y)&quot;, binExpr(&quot;&lt;&lt;&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &gt;&gt; y)&quot;, binExpr(&quot;&gt;&gt;&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &gt;&gt;&gt; y)&quot;, binExpr(&quot;&gt;&gt;&gt;&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x + y)&quot;, binExpr(&quot;+&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(w + x + y + z)&quot;, binExpr(&quot;+&quot;, binExpr(&quot;+&quot;, binExpr(&quot;+&quot;, ident(&quot;w&quot;), ident(&quot;x&quot;)), ident(&quot;y&quot;)), ident(&quot;z&quot;)));
assertExpr(&quot;(x - y)&quot;, binExpr(&quot;-&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(w - x - y - z)&quot;, binExpr(&quot;-&quot;, binExpr(&quot;-&quot;, binExpr(&quot;-&quot;, ident(&quot;w&quot;), ident(&quot;x&quot;)), ident(&quot;y&quot;)), ident(&quot;z&quot;)));
assertExpr(&quot;(x * y)&quot;, binExpr(&quot;*&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x / y)&quot;, binExpr(&quot;/&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x % y)&quot;, binExpr(&quot;%&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x | y)&quot;, binExpr(&quot;|&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x ^ y)&quot;, binExpr(&quot;^&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &amp; y)&quot;, binExpr(&quot;&amp;&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x in y)&quot;, binExpr(&quot;in&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x instanceof y)&quot;, binExpr(&quot;instanceof&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x = y)&quot;, aExpr(&quot;=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x += y)&quot;, aExpr(&quot;+=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x -= y)&quot;, aExpr(&quot;-=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x *= y)&quot;, aExpr(&quot;*=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x /= y)&quot;, aExpr(&quot;/=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x %= y)&quot;, aExpr(&quot;%=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &lt;&lt;= y)&quot;, aExpr(&quot;&lt;&lt;=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &gt;&gt;= y)&quot;, aExpr(&quot;&gt;&gt;=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &gt;&gt;&gt;= y)&quot;, aExpr(&quot;&gt;&gt;&gt;=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x |= y)&quot;, aExpr(&quot;|=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x ^= y)&quot;, aExpr(&quot;^=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &amp;= y)&quot;, aExpr(&quot;&amp;=&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x || y)&quot;, logExpr(&quot;||&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(x &amp;&amp; y)&quot;, logExpr(&quot;&amp;&amp;&quot;, ident(&quot;x&quot;), ident(&quot;y&quot;)));
assertExpr(&quot;(w || x || y || z)&quot;, logExpr(&quot;||&quot;, logExpr(&quot;||&quot;, logExpr(&quot;||&quot;, ident(&quot;w&quot;), ident(&quot;x&quot;)), ident(&quot;y&quot;)), ident(&quot;z&quot;)))
assertExpr(&quot;(x ? y : z)&quot;, condExpr(ident(&quot;x&quot;), ident(&quot;y&quot;), ident(&quot;z&quot;)));
assertExpr(&quot;(x,y)&quot;, seqExpr([ident(&quot;x&quot;),ident(&quot;y&quot;)]))
assertExpr(&quot;(x,y,z)&quot;, seqExpr([ident(&quot;x&quot;),ident(&quot;y&quot;),ident(&quot;z&quot;)]))
assertExpr(&quot;(a,b,c,d,e,f,g)&quot;, seqExpr([ident(&quot;a&quot;),ident(&quot;b&quot;),ident(&quot;c&quot;),ident(&quot;d&quot;),ident(&quot;e&quot;),ident(&quot;f&quot;),ident(&quot;g&quot;)]));
assertExpr(&quot;(new Object)&quot;, newExpr(ident(&quot;Object&quot;), []));
assertExpr(&quot;(new Object())&quot;, newExpr(ident(&quot;Object&quot;), []));
assertExpr(&quot;(new Object(42))&quot;, newExpr(ident(&quot;Object&quot;), [lit(42)]));
assertExpr(&quot;(new Object(1,2,3))&quot;, newExpr(ident(&quot;Object&quot;), [lit(1),lit(2),lit(3)]));
assertExpr(&quot;(String())&quot;, callExpr(ident(&quot;String&quot;), []));
assertExpr(&quot;(String(42))&quot;, callExpr(ident(&quot;String&quot;), [lit(42)]));
assertExpr(&quot;(String(1,2,3))&quot;, callExpr(ident(&quot;String&quot;), [lit(1),lit(2),lit(3)]));
assertExpr(&quot;[]&quot;, arrExpr([]));
assertExpr(&quot;[1]&quot;, arrExpr([lit(1)]));
assertExpr(&quot;[1,2]&quot;, arrExpr([lit(1),lit(2)]));
assertExpr(&quot;[1,2,3]&quot;, arrExpr([lit(1),lit(2),lit(3)]));
assertExpr(&quot;[1,,2,3]&quot;, arrExpr([lit(1),,lit(2),lit(3)]));
assertExpr(&quot;[1,,,2,3]&quot;, arrExpr([lit(1),,,lit(2),lit(3)]));
assertExpr(&quot;[1,,,2,,3]&quot;, arrExpr([lit(1),,,lit(2),,lit(3)]));
assertExpr(&quot;[1,,,2,,,3]&quot;, arrExpr([lit(1),,,lit(2),,,lit(3)]));
assertExpr(&quot;[,1,2,3]&quot;, arrExpr([,lit(1),lit(2),lit(3)]));
assertExpr(&quot;[,,1,2,3]&quot;, arrExpr([,,lit(1),lit(2),lit(3)]));
assertExpr(&quot;[,,,1,2,3]&quot;, arrExpr([,,,lit(1),lit(2),lit(3)]));
assertExpr(&quot;[,,,1,2,3,]&quot;, arrExpr([,,,lit(1),lit(2),lit(3)]));
assertExpr(&quot;[,,,1,2,3,,]&quot;, arrExpr([,,,lit(1),lit(2),lit(3),undefined]));
assertExpr(&quot;[,,,1,2,3,,,]&quot;, arrExpr([,,,lit(1),lit(2),lit(3),undefined,undefined]));
assertExpr(&quot;[,,,,,]&quot;, arrExpr([undefined,undefined,undefined,undefined,undefined]));
assertExpr(&quot;({})&quot;, objExpr([]));
assertExpr(&quot;({x:1})&quot;, objExpr([objProp(ident(&quot;x&quot;), lit(1), &quot;init&quot;)]));
assertExpr(&quot;({x:1, y:2})&quot;, objExpr([objProp(ident(&quot;x&quot;), lit(1), &quot;init&quot;),
                                    objProp(ident(&quot;y&quot;), lit(2), &quot;init&quot;)]));
assertExpr(&quot;({x:1, y:2, z:3})&quot;, objExpr([objProp(ident(&quot;x&quot;), lit(1), &quot;init&quot;),
                                         objProp(ident(&quot;y&quot;), lit(2), &quot;init&quot;),
                                         objProp(ident(&quot;z&quot;), lit(3), &quot;init&quot;) ]));
assertExpr(&quot;({x:1, &#039;y&#039;:2, z:3})&quot;, objExpr([objProp(ident(&quot;x&quot;), lit(1), &quot;init&quot;),
                                           objProp(lit(&quot;y&quot;), lit(2), &quot;init&quot;),
                                           objProp(ident(&quot;z&quot;), lit(3), &quot;init&quot;) ]));
assertExpr(&quot;({&#039;x&#039;:1, &#039;y&#039;:2, z:3})&quot;, objExpr([objProp(lit(&quot;x&quot;), lit(1), &quot;init&quot;),
                                             objProp(lit(&quot;y&quot;), lit(2), &quot;init&quot;),
                                             objProp(ident(&quot;z&quot;), lit(3), &quot;init&quot;) ]));
assertExpr(&quot;({&#039;x&#039;:1, &#039;y&#039;:2, 3:3})&quot;, objExpr([objProp(lit(&quot;x&quot;), lit(1), &quot;init&quot;),
                                             objProp(lit(&quot;y&quot;), lit(2), &quot;init&quot;),
                                             objProp(lit(3), lit(3), &quot;init&quot;) ]));

// Bug 571617: eliminate constant-folding
assertExpr(&quot;2 + 3&quot;, binExpr(&quot;+&quot;, lit(2), lit(3)));

// Bug 632026: constant-folding
assertExpr(&quot;typeof(0?0:a)&quot;, unExpr(&quot;typeof&quot;, condExpr(lit(0), lit(0), ident(&quot;a&quot;))));

// Bug 632056: constant-folding
program([exprStmt(ident(&quot;f&quot;)),
         ifStmt(lit(1),
                funDecl(ident(&quot;f&quot;), [], blockStmt([])),
                null)]).assert(Reflect.parse(&quot;f; if (1) function f(){}&quot;));

// statements

assertStmt(&quot;throw 42&quot;, throwStmt(lit(42)));
assertStmt(&quot;for (;;) break&quot;, forStmt(null, null, null, breakStmt(null)));
assertStmt(&quot;for (x; y; z) break&quot;, forStmt(ident(&quot;x&quot;), ident(&quot;y&quot;), ident(&quot;z&quot;), breakStmt(null)));
assertStmt(&quot;for (var x; y; z) break&quot;, forStmt(varDecl([declarator(ident(&quot;x&quot;), null)]), ident(&quot;y&quot;), ident(&quot;z&quot;), breakStmt(null)));
assertStmt(&quot;for (var x = 42; y; z) break&quot;, forStmt(varDecl([declarator(ident(&quot;x&quot;), lit(42))]), ident(&quot;y&quot;), ident(&quot;z&quot;), breakStmt(null)));
assertStmt(&quot;for (x; ; z) break&quot;, forStmt(ident(&quot;x&quot;), null, ident(&quot;z&quot;), breakStmt(null)));
assertStmt(&quot;for (var x; ; z) break&quot;, forStmt(varDecl([declarator(ident(&quot;x&quot;), null)]), null, ident(&quot;z&quot;), breakStmt(null)));
assertStmt(&quot;for (var x = 42; ; z) break&quot;, forStmt(varDecl([declarator(ident(&quot;x&quot;), lit(42))]), null, ident(&quot;z&quot;), breakStmt(null)));
assertStmt(&quot;for (x; y; ) break&quot;, forStmt(ident(&quot;x&quot;), ident(&quot;y&quot;), null, breakStmt(null)));
assertStmt(&quot;for (var x; y; ) break&quot;, forStmt(varDecl([declarator(ident(&quot;x&quot;), null)]), ident(&quot;y&quot;), null, breakStmt(null)));
assertStmt(&quot;for (var x = 42; y; ) break&quot;, forStmt(varDecl([declarator(ident(&quot;x&quot;),lit(42))]), ident(&quot;y&quot;), null, breakStmt(null)));
assertStmt(&quot;for (var x in y) break&quot;, forInStmt(varDecl([declarator(ident(&quot;x&quot;),null)]), ident(&quot;y&quot;), breakStmt(null)));
assertStmt(&quot;for (x in y) break&quot;, forInStmt(ident(&quot;x&quot;), ident(&quot;y&quot;), breakStmt(null)));
assertStmt(&quot;{ }&quot;, blockStmt([]));
assertStmt(&quot;{ throw 1; throw 2; throw 3; }&quot;, blockStmt([ throwStmt(lit(1)), throwStmt(lit(2)), throwStmt(lit(3))]));
assertStmt(&quot;;&quot;, emptyStmt);
assertStmt(&quot;if (foo) throw 42;&quot;, ifStmt(ident(&quot;foo&quot;), throwStmt(lit(42)), null));
assertStmt(&quot;if (foo) throw 42; else true;&quot;, ifStmt(ident(&quot;foo&quot;), throwStmt(lit(42)), exprStmt(lit(true))));
assertStmt(&quot;if (foo) { throw 1; throw 2; throw 3; }&quot;,
           ifStmt(ident(&quot;foo&quot;),
                  blockStmt([throwStmt(lit(1)), throwStmt(lit(2)), throwStmt(lit(3))]),
                  null));
assertStmt(&quot;if (foo) { throw 1; throw 2; throw 3; } else true;&quot;,
           ifStmt(ident(&quot;foo&quot;),
                  blockStmt([throwStmt(lit(1)), throwStmt(lit(2)), throwStmt(lit(3))]),
                  exprStmt(lit(true))));
assertStmt(&quot;foo: for(;;) break foo;&quot;, labStmt(ident(&quot;foo&quot;), forStmt(null, null, null, breakStmt(ident(&quot;foo&quot;)))));
assertStmt(&quot;foo: for(;;) continue foo;&quot;, labStmt(ident(&quot;foo&quot;), forStmt(null, null, null, continueStmt(ident(&quot;foo&quot;)))));
assertStmt(&quot;with (obj) { }&quot;, withStmt(ident(&quot;obj&quot;), blockStmt([])));
assertStmt(&quot;with (obj) { obj; }&quot;, withStmt(ident(&quot;obj&quot;), blockStmt([exprStmt(ident(&quot;obj&quot;))])));
assertStmt(&quot;while (foo) { }&quot;, whileStmt(ident(&quot;foo&quot;), blockStmt([])));
assertStmt(&quot;while (foo) { foo; }&quot;, whileStmt(ident(&quot;foo&quot;), blockStmt([exprStmt(ident(&quot;foo&quot;))])));
assertStmt(&quot;do { } while (foo);&quot;, doStmt(blockStmt([]), ident(&quot;foo&quot;)));
assertStmt(&quot;do { foo; } while (foo)&quot;, doStmt(blockStmt([exprStmt(ident(&quot;foo&quot;))]), ident(&quot;foo&quot;)));
assertStmt(&quot;switch (foo) { case 1: 1; break; case 2: 2; break; default: 3; }&quot;,
           switchStmt(ident(&quot;foo&quot;),
                      [ caseClause(lit(1), [ exprStmt(lit(1)), breakStmt(null) ]),
                        caseClause(lit(2), [ exprStmt(lit(2)), breakStmt(null) ]),
                        defaultClause([ exprStmt(lit(3)) ]) ]));
assertStmt(&quot;switch (foo) { case 1: 1; break; case 2: 2; break; default: 3; case 42: 42; }&quot;,
           switchStmt(ident(&quot;foo&quot;),
                      [ caseClause(lit(1), [ exprStmt(lit(1)), breakStmt(null) ]),
                        caseClause(lit(2), [ exprStmt(lit(2)), breakStmt(null) ]),
                        defaultClause([ exprStmt(lit(3)) ]),
                        caseClause(lit(42), [ exprStmt(lit(42)) ]) ]));
assertStmt(&quot;try { } catch (e) { }&quot;,
           tryStmt(blockStmt([]),
                   [],
                   [ catchClause(ident(&quot;e&quot;), null, blockStmt([])) ],
                   null));
assertStmt(&quot;try { } catch (e) { } finally { }&quot;,
           tryStmt(blockStmt([]),
                   [],
                   [ catchClause(ident(&quot;e&quot;), null, blockStmt([])) ],
                   blockStmt([])));
assertStmt(&quot;try { } finally { }&quot;,
           tryStmt(blockStmt([]),
                   [],
                   [],
                   blockStmt([])));

// redeclarations (TOK_NAME nodes with lexdef)

assertStmt(&quot;function f() { function g() { } function g() { } }&quot;,
           funDecl(ident(&quot;f&quot;), [], blockStmt([funDecl(ident(&quot;g&quot;), [], blockStmt([])),
                                              funDecl(ident(&quot;g&quot;), [], blockStmt([]))])));

assertStmt(&quot;function f() { function g() { } function g() { return 42 } }&quot;,
           funDecl(ident(&quot;f&quot;), [], blockStmt([funDecl(ident(&quot;g&quot;), [], blockStmt([])),
                                              funDecl(ident(&quot;g&quot;), [], blockStmt([returnStmt(lit(42))]))])));

assertStmt(&quot;function f() { var x = 42; var x = 43; }&quot;,
           funDecl(ident(&quot;f&quot;), [], blockStmt([varDecl([declarator(ident(&quot;x&quot;),lit(42))]),
                                              varDecl([declarator(ident(&quot;x&quot;),lit(43))])])));

// getters and setters

 assertExpr(&quot;({ get x() { return 42 } })&quot;,
            objExpr([ objProp(ident(&quot;x&quot;),
                              funExpr(null, [], blockStmt([returnStmt(lit(42))])),
                              &quot;get&quot; ) ]));
 assertExpr(&quot;({ set x(v) { return 42 } })&quot;,
            objExpr([ objProp(ident(&quot;x&quot;),
                              funExpr(null, [ident(&quot;v&quot;)], blockStmt([returnStmt(lit(42))])),
                              &quot;set&quot; ) ]));

}

exports.testReflect = testReflect;

}(typeof exports === &#039;undefined&#039; ? this : exports));</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
