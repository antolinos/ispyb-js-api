<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/findup-sync/node_modules/lodash/dist/lodash.underscore.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/findup-sync/node_modules/lodash/dist/lodash.underscore.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">64.18</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">4970</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">225.54</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">21.42</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/**
 * @license
 * Lo-Dash 2.4.2 (Custom Build) &lt;https://lodash.com/&gt;
 * Build: `lodash underscore exports=&quot;amd,commonjs,global,node&quot; -o ./dist/lodash.underscore.js`
 * Copyright 2012-2013 The Dojo Foundation &lt;http://dojofoundation.org/&gt;
 * Based on Underscore.js 1.5.2 &lt;http://underscorejs.org/LICENSE&gt;
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors
 * Available under MIT license &lt;https://lodash.com/license&gt;
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre ES5 environments */
  var undefined;

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used internally to indicate various things */
  var indicatorObject = {};

  /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
  var keyPrefix = +new Date + &#039;&#039;;

  /** Used to match &quot;interpolate&quot; template delimiters */
  var reInterpolate = /&lt;%=([\s\S]+?)%&gt;/g;

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /[&#039;\n\r\t\u2028\u2029\\]/g;

  /** `Object#toString` result shortcuts */
  var argsClass = &#039;[object Arguments]&#039;,
      arrayClass = &#039;[object Array]&#039;,
      boolClass = &#039;[object Boolean]&#039;,
      dateClass = &#039;[object Date]&#039;,
      funcClass = &#039;[object Function]&#039;,
      numberClass = &#039;[object Number]&#039;,
      objectClass = &#039;[object Object]&#039;,
      regexpClass = &#039;[object RegExp]&#039;,
      stringClass = &#039;[object String]&#039;;

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    &#039;boolean&#039;: false,
    &#039;function&#039;: true,
    &#039;object&#039;: true,
    &#039;number&#039;: false,
    &#039;string&#039;: false,
    &#039;undefined&#039;: false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    &#039;\\&#039;: &#039;\\&#039;,
    &quot;&#039;&quot;: &quot;&#039;&quot;,
    &#039;\n&#039;: &#039;n&#039;,
    &#039;\r&#039;: &#039;r&#039;,
    &#039;\t&#039;: &#039;t&#039;,
    &#039;\u2028&#039;: &#039;u2028&#039;,
    &#039;\u2029&#039;: &#039;u2029&#039;
  };

  /** Used as a reference to the global object */
  var root = (objectTypes[typeof window] &amp;&amp; window) || this;

  /** Detect free variable `exports` */
  var freeExports = objectTypes[typeof exports] &amp;&amp; exports &amp;&amp; !exports.nodeType &amp;&amp; exports;

  /** Detect free variable `module` */
  var freeModule = objectTypes[typeof module] &amp;&amp; module &amp;&amp; !module.nodeType &amp;&amp; module;

  /** Detect the popular CommonJS extension `module.exports` */
  var moduleExports = freeModule &amp;&amp; freeModule.exports === freeExports &amp;&amp; freeExports;

  /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
  var freeGlobal = objectTypes[typeof global] &amp;&amp; global;
  if (freeGlobal &amp;&amp; (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal)) {
    root = freeGlobal;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches
   * or `fromIndex` constraints.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0;

    while (++index &lt; length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Used by `sortBy` to compare transformed `collection` elements, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ac = a.criteria,
        bc = b.criteria,
        index = -1,
        length = ac.length;

    while (++index &lt; length) {
      var value = ac[index],
          other = bc[index];

      if (value !== other) {
        if (value &gt; other || typeof value == &#039;undefined&#039;) {
          return 1;
        }
        if (value &lt; other || typeof other == &#039;undefined&#039;) {
          return -1;
        }
      }
    }
    // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
    // that causes it, under certain circumstances, to return the same value for
    // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
    //
    // This also ensures a stable sort in V8 and other engines.
    // See http://code.google.com/p/v8/issues/detail?id=90
    return a.index - b.index;
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return &#039;\\&#039; + stringEscapes[match];
  }

  /**
   * Slices the `collection` from the `start` index up to, but not including,
   * the `end` index.
   *
   * Note: This function is used instead of `Array#slice` to support node lists
   * in IE &lt; 9 and to ensure dense arrays are returned.
   *
   * @private
   * @param {Array|Object|string} collection The collection to slice.
   * @param {number} start The start index.
   * @param {number} end The end index.
   * @returns {Array} Returns the new array.
   */
  function slice(array, start, end) {
    start || (start = 0);
    if (typeof end == &#039;undefined&#039;) {
      end = array ? array.length : 0;
    }
    var index = -1,
        length = end - start || 0,
        result = Array(length &lt; 0 ? 0 : length);

    while (++index &lt; length) {
      result[index] = array[start + index];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Used for `Array` method references.
   *
   * Normally `Array.prototype` would suffice, however, using an array literal
   * avoids issues in Narwhal.
   */
  var arrayRef = [];

  /** Used for native method references */
  var objectProto = Object.prototype;

  /** Used to restore the original `_` reference in `noConflict` */
  var oldDash = root._;

  /** Used to resolve the internal [[Class]] of values */
  var toString = objectProto.toString;

  /** Used to detect if a method is native */
  var reNative = RegExp(&#039;^&#039; +
    String(toString)
      .replace(/[.*+?^${}()|[\]\\]/g, &#039;\\$&amp;&#039;)
      .replace(/toString| for [^\]]+/g, &#039;.*?&#039;) + &#039;$&#039;
  );

  /** Native method shortcuts */
  var ceil = Math.ceil,
      floor = Math.floor,
      hasOwnProperty = objectProto.hasOwnProperty,
      push = arrayRef.push,
      propertyIsEnumerable = objectProto.propertyIsEnumerable;

  /* Native method shortcuts for methods with the same name as other `lodash` methods */
  var nativeCreate = isNative(nativeCreate = Object.create) &amp;&amp; nativeCreate,
      nativeIsArray = isNative(nativeIsArray = Array.isArray) &amp;&amp; nativeIsArray,
      nativeIsFinite = root.isFinite,
      nativeIsNaN = root.isNaN,
      nativeKeys = isNative(nativeKeys = Object.keys) &amp;&amp; nativeKeys,
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeRandom = Math.random;

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps the given value to enable intuitive
   * method chaining.
   *
   * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
   * and `unshift`
   *
   * Chaining is supported in custom builds as long as the `value` method is
   * implicitly or explicitly included in the build.
   *
   * The chainable wrapper functions are:
   * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
   * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
   * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
   * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
   * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
   * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
   * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
   * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
   * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
   * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
   * and `zip`
   *
   * The non-chainable wrapper functions are:
   * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
   * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
   * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
   * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
   * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
   * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
   * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
   * `template`, `unescape`, `uniqueId`, and `value`
   *
   * The wrapper functions `first` and `last` return wrapped values when `n` is
   * provided, otherwise they return unwrapped values.
   *
   * Explicit chaining can be enabled by using the `_.chain` method.
   *
   * @name _
   * @constructor
   * @category Chaining
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns a `lodash` instance.
   * @example
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // returns an unwrapped value
   * wrapped.reduce(function(sum, num) {
   *   return sum + num;
   * });
   * // =&gt; 6
   *
   * // returns a wrapped value
   * var squares = wrapped.map(function(num) {
   *   return num * num;
   * });
   *
   * _.isArray(squares);
   * // =&gt; false
   *
   * _.isArray(squares.value());
   * // =&gt; true
   */
  function lodash(value) {
    return (value instanceof lodash)
      ? value
      : new lodashWrapper(value);
  }

  /**
   * A fast path for creating `lodash` wrapper objects.
   *
   * @private
   * @param {*} value The value to wrap in a `lodash` instance.
   * @param {boolean} chainAll A flag to enable chaining for all methods
   * @returns {Object} Returns a `lodash` instance.
   */
  function lodashWrapper(value, chainAll) {
    this.__chain__ = !!chainAll;
    this.__wrapped__ = value;
  }
  // ensure `new lodashWrapper` is an instance of `lodash`
  lodashWrapper.prototype = lodash.prototype;

  /**
   * An object used to flag environments features.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  var support = {};

  (function() {
    var object = { &#039;0&#039;: 1, &#039;length&#039;: 1 };

    /**
     * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
     *
     * Firefox &lt; 10, IE compatibility mode, and IE &lt; 9 have buggy Array `shift()`
     * and `splice()` functions that fail to remove the last element, `value[0]`,
     * of array-like objects even though the `length` property is set to `0`.
     * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
     * is buggy regardless of mode in IE &lt; 9 and buggy in compatibility mode in IE 9.
     *
     * @memberOf _.support
     * @type boolean
     */
    support.spliceObjects = (arrayRef.splice.call(object, 0, 1), !object[0]);
  }(1));

  /**
   * By default, the template delimiters used by Lo-Dash are similar to those in
   * embedded Ruby (ERB). Change the following template settings to use alternative
   * delimiters.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  lodash.templateSettings = {

    /**
     * Used to detect `data` property values to be HTML-escaped.
     *
     * @memberOf _.templateSettings
     * @type RegExp
     */
    &#039;escape&#039;: /&lt;%-([\s\S]+?)%&gt;/g,

    /**
     * Used to detect code to be evaluated.
     *
     * @memberOf _.templateSettings
     * @type RegExp
     */
    &#039;evaluate&#039;: /&lt;%([\s\S]+?)%&gt;/g,

    /**
     * Used to detect `data` property values to inject.
     *
     * @memberOf _.templateSettings
     * @type RegExp
     */
    &#039;interpolate&#039;: reInterpolate,

    /**
     * Used to reference the data object in the template text.
     *
     * @memberOf _.templateSettings
     * @type string
     */
    &#039;variable&#039;: &#039;&#039;
  };

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.bind` that creates the bound function and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new bound function.
   */
  function baseBind(bindData) {
    var func = bindData[0],
        partialArgs = bindData[2],
        thisArg = bindData[4];

    function bound() {
      // `Function#bind` spec
      // http://es5.github.io/#x15.3.4.5
      if (partialArgs) {
        // avoid `arguments` object deoptimizations by using `slice` instead
        // of `Array.prototype.slice.call` and not assigning `arguments` to a
        // variable as a ternary expression
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      // mimic the constructor&#039;s `return` behavior
      // http://es5.github.io/#x13.2.2
      if (this instanceof bound) {
        // ensure `new bound` is an instance of `func`
        var thisBinding = baseCreate(func.prototype),
            result = func.apply(thisBinding, args || arguments);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisArg, args || arguments);
    }
    return bound;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  function baseCreate(prototype, properties) {
    return isObject(prototype) ? nativeCreate(prototype) : {};
  }
  // fallback for browsers without `Object.create`
  if (!nativeCreate) {
    baseCreate = (function() {
      function Object() {}
      return function(prototype) {
        if (isObject(prototype)) {
          Object.prototype = prototype;
          var result = new Object;
          Object.prototype = null;
        }
        return result || root.Object();
      };
    }());
  }

  /**
   * The base implementation of `_.createCallback` without support for creating
   * &quot;_.pluck&quot; or &quot;_.where&quot; style callbacks.
   *
   * @private
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   */
  function baseCreateCallback(func, thisArg, argCount) {
    if (typeof func != &#039;function&#039;) {
      return identity;
    }
    // exit early for no `thisArg` or already bound by `Function#bind`
    if (typeof thisArg == &#039;undefined&#039; || !(&#039;prototype&#039; in func)) {
      return func;
    }
    switch (argCount) {
      case 1: return function(value) {
        return func.call(thisArg, value);
      };
      case 2: return function(a, b) {
        return func.call(thisArg, a, b);
      };
      case 3: return function(value, index, collection) {
        return func.call(thisArg, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(thisArg, accumulator, value, index, collection);
      };
    }
    return bind(func, thisArg);
  }

  /**
   * The base implementation of `createWrapper` that creates the wrapper and
   * sets its meta data.
   *
   * @private
   * @param {Array} bindData The bind data array.
   * @returns {Function} Returns the new function.
   */
  function baseCreateWrapper(bindData) {
    var func = bindData[0],
        bitmask = bindData[1],
        partialArgs = bindData[2],
        partialRightArgs = bindData[3],
        thisArg = bindData[4],
        arity = bindData[5];

    var isBind = bitmask &amp; 1,
        isBindKey = bitmask &amp; 2,
        isCurry = bitmask &amp; 4,
        isCurryBound = bitmask &amp; 8,
        key = func;

    function bound() {
      var thisBinding = isBind ? thisArg : this;
      if (partialArgs) {
        var args = slice(partialArgs);
        push.apply(args, arguments);
      }
      if (partialRightArgs || isCurry) {
        args || (args = slice(arguments));
        if (partialRightArgs) {
          push.apply(args, partialRightArgs);
        }
        if (isCurry &amp;&amp; args.length &lt; arity) {
          bitmask |= 16 &amp; ~32;
          return baseCreateWrapper([func, (isCurryBound ? bitmask : bitmask &amp; ~3), args, null, thisArg, arity]);
        }
      }
      args || (args = arguments);
      if (isBindKey) {
        func = thisBinding[key];
      }
      if (this instanceof bound) {
        thisBinding = baseCreate(func.prototype);
        var result = func.apply(thisBinding, args);
        return isObject(result) ? result : thisBinding;
      }
      return func.apply(thisBinding, args);
    }
    return bound;
  }

  /**
   * The base implementation of `_.difference` that accepts a single array
   * of values to exclude.
   *
   * @private
   * @param {Array} array The array to process.
   * @param {Array} [values] The array of values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   */
  function baseDifference(array, values) {
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [];

    while (++index &lt; length) {
      var value = array[index];
      if (indexOf(values, value) &lt; 0) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.flatten` without support for callback
   * shorthands or `thisArg` binding.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
   * @param {number} [fromIndex=0] The index to start from.
   * @returns {Array} Returns a new flattened array.
   */
  function baseFlatten(array, isShallow, isStrict, fromIndex) {
    var index = (fromIndex || 0) - 1,
        length = array ? array.length : 0,
        result = [];

    while (++index &lt; length) {
      var value = array[index];

      if (value &amp;&amp; typeof value == &#039;object&#039; &amp;&amp; typeof value.length == &#039;number&#039;
          &amp;&amp; (isArray(value) || isArguments(value))) {
        // recursively flatten arrays (susceptible to call stack limits)
        if (!isShallow) {
          value = baseFlatten(value, isShallow, isStrict);
        }
        var valIndex = -1,
            valLength = value.length,
            resIndex = result.length;

        result.length += valLength;
        while (++valIndex &lt; valLength) {
          result[resIndex++] = value[valIndex];
        }
      } else if (!isStrict) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.isEqual`, without support for `thisArg` binding,
   * that allows partial &quot;_.where&quot; style comparisons.
   *
   * @private
   * @param {*} a The value to compare.
   * @param {*} b The other value to compare.
   * @param {Function} [callback] The function to customize comparing values.
   * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
   * @param {Array} [stackA=[]] Tracks traversed `a` objects.
   * @param {Array} [stackB=[]] Tracks traversed `b` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(a, b, stackA, stackB) {
    if (a === b) {
      return a !== 0 || (1 / a == 1 / b);
    }
    var type = typeof a,
        otherType = typeof b;

    if (a === a &amp;&amp;
        !(a &amp;&amp; objectTypes[type]) &amp;&amp;
        !(b &amp;&amp; objectTypes[otherType])) {
      return false;
    }
    if (a == null || b == null) {
      return a === b;
    }
    var className = toString.call(a),
        otherClass = toString.call(b);

    if (className != otherClass) {
      return false;
    }
    switch (className) {
      case boolClass:
      case dateClass:
        return +a == +b;

      case numberClass:
        return a != +a
          ? b != +b
          : (a == 0 ? (1 / a == 1 / b) : a == +b);

      case regexpClass:
      case stringClass:
        return a == String(b);
    }
    var isArr = className == arrayClass;
    if (!isArr) {
      var aWrapped = a instanceof lodash,
          bWrapped = b instanceof lodash;

      if (aWrapped || bWrapped) {
        return baseIsEqual(aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, stackA, stackB);
      }
      if (className != objectClass) {
        return false;
      }
      var ctorA = a.constructor,
          ctorB = b.constructor;

      if (ctorA != ctorB &amp;&amp;
            !(isFunction(ctorA) &amp;&amp; ctorA instanceof ctorA &amp;&amp; isFunction(ctorB) &amp;&amp; ctorB instanceof ctorB) &amp;&amp;
            (&#039;constructor&#039; in a &amp;&amp; &#039;constructor&#039; in b)
          ) {
        return false;
      }
    }
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] == a) {
        return stackB[length] == b;
      }
    }
    var result = true,
        size = 0;

    stackA.push(a);
    stackB.push(b);

    if (isArr) {
      size = b.length;
      result = size == a.length;

      if (result) {
        while (size--) {
          if (!(result = baseIsEqual(a[size], b[size], stackA, stackB))) {
            break;
          }
        }
      }
    }
    else {
      forIn(b, function(value, key, b) {
        if (hasOwnProperty.call(b, key)) {
          size++;
          return !(result = hasOwnProperty.call(a, key) &amp;&amp; baseIsEqual(a[key], value, stackA, stackB)) &amp;&amp; indicatorObject;
        }
      });

      if (result) {
        forIn(a, function(value, key, a) {
          if (hasOwnProperty.call(a, key)) {
            return !(result = --size &gt; -1) &amp;&amp; indicatorObject;
          }
        });
      }
    }
    stackA.pop();
    stackB.pop();
    return result;
  }

  /**
   * The base implementation of `_.random` without argument juggling or support
   * for returning floating-point numbers.
   *
   * @private
   * @param {number} min The minimum possible value.
   * @param {number} max The maximum possible value.
   * @returns {number} Returns a random number.
   */
  function baseRandom(min, max) {
    return min + floor(nativeRandom() * (max - min + 1));
  }

  /**
   * The base implementation of `_.uniq` without support for callback shorthands
   * or `thisArg` binding.
   *
   * @private
   * @param {Array} array The array to process.
   * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
   * @param {Function} [callback] The function called per iteration.
   * @returns {Array} Returns a duplicate-value-free array.
   */
  function baseUniq(array, isSorted, callback) {
    var index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [],
        seen = callback ? [] : result;

    while (++index &lt; length) {
      var value = array[index],
          computed = callback ? callback(value, index, array) : value;

      if (isSorted
            ? !index || seen[seen.length - 1] !== computed
            : indexOf(seen, computed) &lt; 0
          ) {
        if (callback) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Creates a function that aggregates a collection, creating an object composed
   * of keys generated from the results of running each element of the collection
   * through a callback. The given `setter` function sets the keys and values
   * of the composed object.
   *
   * @private
   * @param {Function} setter The setter function.
   * @returns {Function} Returns the new aggregator function.
   */
  function createAggregator(setter) {
    return function(collection, callback, thisArg) {
      var result = {};
      callback = createCallback(callback, thisArg, 3);

      var index = -1,
          length = collection ? collection.length : 0;

      if (typeof length == &#039;number&#039;) {
        while (++index &lt; length) {
          var value = collection[index];
          setter(result, value, callback(value, index, collection), collection);
        }
      } else {
        forOwn(collection, function(value, key, collection) {
          setter(result, value, callback(value, key, collection), collection);
        });
      }
      return result;
    };
  }

  /**
   * Creates a function that, when called, either curries or invokes `func`
   * with an optional `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of method flags to compose.
   *  The bitmask may be composed of the following flags:
   *  1 - `_.bind`
   *  2 - `_.bindKey`
   *  4 - `_.curry`
   *  8 - `_.curry` (bound)
   *  16 - `_.partial`
   *  32 - `_.partialRight`
   * @param {Array} [partialArgs] An array of arguments to prepend to those
   *  provided to the new function.
   * @param {Array} [partialRightArgs] An array of arguments to append to those
   *  provided to the new function.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new function.
   */
  function createWrapper(func, bitmask, partialArgs, partialRightArgs, thisArg, arity) {
    var isBind = bitmask &amp; 1,
        isBindKey = bitmask &amp; 2,
        isCurry = bitmask &amp; 4,
        isCurryBound = bitmask &amp; 8,
        isPartial = bitmask &amp; 16,
        isPartialRight = bitmask &amp; 32;

    if (!isBindKey &amp;&amp; !isFunction(func)) {
      throw new TypeError;
    }
    if (isPartial &amp;&amp; !partialArgs.length) {
      bitmask &amp;= ~16;
      isPartial = partialArgs = false;
    }
    if (isPartialRight &amp;&amp; !partialRightArgs.length) {
      bitmask &amp;= ~32;
      isPartialRight = partialRightArgs = false;
    }
    // fast path for `_.bind`
    var creater = (bitmask == 1 || bitmask === 17) ? baseBind : baseCreateWrapper;
    return creater([func, bitmask, partialArgs, partialRightArgs, thisArg, arity]);
  }

  /**
   * Used by `escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} match The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeHtmlChar(match) {
    return htmlEscapes[match];
  }

  /**
   * Gets the appropriate &quot;indexOf&quot; function. If the `_.indexOf` method is
   * customized, this method returns the custom method, otherwise it returns
   * the `baseIndexOf` function.
   *
   * @private
   * @returns {Function} Returns the &quot;indexOf&quot; function.
   */
  function getIndexOf() {
    var result = (result = lodash.indexOf) === indexOf ? baseIndexOf : result;
    return result;
  }

  /**
   * Checks if `value` is a native function.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
   */
  function isNative(value) {
    return typeof value == &#039;function&#039; &amp;&amp; reNative.test(value);
  }

  /**
   * Used by `unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} match The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  function unescapeHtmlChar(match) {
    return htmlUnescapes[match];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if `value` is an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
   * @example
   *
   * (function() { return _.isArguments(arguments); })(1, 2, 3);
   * // =&gt; true
   *
   * _.isArguments([1, 2, 3]);
   * // =&gt; false
   */
  function isArguments(value) {
    return value &amp;&amp; typeof value == &#039;object&#039; &amp;&amp; typeof value.length == &#039;number&#039; &amp;&amp;
      toString.call(value) == argsClass || false;
  }
  // fallback for browsers that can&#039;t detect `arguments` objects by [[Class]]
  if (!isArguments(arguments)) {
    isArguments = function(value) {
      return value &amp;&amp; typeof value == &#039;object&#039; &amp;&amp; typeof value.length == &#039;number&#039; &amp;&amp;
        hasOwnProperty.call(value, &#039;callee&#039;) &amp;&amp; !propertyIsEnumerable.call(value, &#039;callee&#039;) || false;
    };
  }

  /**
   * Checks if `value` is an array.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
   * @example
   *
   * (function() { return _.isArray(arguments); })();
   * // =&gt; false
   *
   * _.isArray([1, 2, 3]);
   * // =&gt; true
   */
  var isArray = nativeIsArray || function(value) {
    return value &amp;&amp; typeof value == &#039;object&#039; &amp;&amp; typeof value.length == &#039;number&#039; &amp;&amp;
      toString.call(value) == arrayClass || false;
  };

  /**
   * A fallback implementation of `Object.keys` which produces an array of the
   * given object&#039;s own enumerable property names.
   *
   * @private
   * @type Function
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   */
  var shimKeys = function(object) {
    var index, iterable = object, result = [];
    if (!iterable) return result;
    if (!(objectTypes[typeof object])) return result;
      for (index in iterable) {
        if (hasOwnProperty.call(iterable, index)) {
          result.push(index);
        }
      }
    return result
  };

  /**
   * Creates an array composed of the own enumerable property names of an object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names.
   * @example
   *
   * _.keys({ &#039;one&#039;: 1, &#039;two&#039;: 2, &#039;three&#039;: 3 });
   * // =&gt; [&#039;one&#039;, &#039;two&#039;, &#039;three&#039;] (property order is not guaranteed across environments)
   */
  var keys = !nativeKeys ? shimKeys : function(object) {
    if (!isObject(object)) {
      return [];
    }
    return nativeKeys(object);
  };

  /**
   * Used to convert characters to HTML entities:
   *
   * Though the `&gt;` character is escaped for symmetry, characters like `&gt;` and `/`
   * don&#039;t require escaping in HTML and have no special meaning unless they&#039;re part
   * of a tag or an unquoted attribute value.
   * http://mathiasbynens.be/notes/ambiguous-ampersands (under &quot;semi-related fun fact&quot;)
   */
  var htmlEscapes = {
    &#039;&amp;&#039;: &#039;&amp;amp;&#039;,
    &#039;&lt;&#039;: &#039;&amp;lt;&#039;,
    &#039;&gt;&#039;: &#039;&amp;gt;&#039;,
    &#039;&quot;&#039;: &#039;&amp;quot;&#039;,
    &quot;&#039;&quot;: &#039;&amp;#x27;&#039;
  };

  /** Used to convert HTML entities to characters */
  var htmlUnescapes = invert(htmlEscapes);

  /** Used to match HTML entities and HTML characters */
  var reEscapedHtml = RegExp(&#039;(&#039; + keys(htmlUnescapes).join(&#039;|&#039;) + &#039;)&#039;, &#039;g&#039;),
      reUnescapedHtml = RegExp(&#039;[&#039; + keys(htmlEscapes).join(&#039;&#039;) + &#039;]&#039;, &#039;g&#039;);

  /*--------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object. Subsequent sources will overwrite property assignments of previous
   * sources. If a callback is provided it will be executed to produce the
   * assigned values. The callback is bound to `thisArg` and invoked with two
   * arguments; (objectValue, sourceValue).
   *
   * @static
   * @memberOf _
   * @type Function
   * @alias extend
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param {Function} [callback] The function to customize assigning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * _.assign({ &#039;name&#039;: &#039;fred&#039; }, { &#039;employer&#039;: &#039;slate&#039; });
   * // =&gt; { &#039;name&#039;: &#039;fred&#039;, &#039;employer&#039;: &#039;slate&#039; }
   *
   * var defaults = _.partialRight(_.assign, function(a, b) {
   *   return typeof a == &#039;undefined&#039; ? b : a;
   * });
   *
   * var object = { &#039;name&#039;: &#039;barney&#039; };
   * defaults(object, { &#039;name&#039;: &#039;fred&#039;, &#039;employer&#039;: &#039;slate&#039; });
   * // =&gt; { &#039;name&#039;: &#039;barney&#039;, &#039;employer&#039;: &#039;slate&#039; }
   */
  function assign(object) {
    if (!object) {
      return object;
    }
    for (var argsIndex = 1, argsLength = arguments.length; argsIndex &lt; argsLength; argsIndex++) {
      var iterable = arguments[argsIndex];
      if (iterable) {
        for (var key in iterable) {
          object[key] = iterable[key];
        }
      }
    }
    return object;
  }

  /**
   * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
   * be cloned, otherwise they will be assigned by reference. If a callback
   * is provided it will be executed to produce the cloned values. If the
   * callback returns `undefined` cloning will be handled by the method instead.
   * The callback is bound to `thisArg` and invoked with one argument; (value).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep=false] Specify a deep clone.
   * @param {Function} [callback] The function to customize cloning values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the cloned value.
   * @example
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 }
   * ];
   *
   * var shallow = _.clone(characters);
   * shallow[0] === characters[0];
   * // =&gt; true
   *
   * var deep = _.clone(characters, true);
   * deep[0] === characters[0];
   * // =&gt; false
   *
   * _.mixin({
   *   &#039;clone&#039;: _.partialRight(_.clone, function(value) {
   *     return _.isElement(value) ? value.cloneNode(false) : undefined;
   *   })
   * });
   *
   * var clone = _.clone(document.body);
   * clone.childNodes.length;
   * // =&gt; 0
   */
  function clone(value) {
    return isObject(value)
      ? (isArray(value) ? slice(value) : assign({}, value))
      : value;
  }

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object for all destination properties that resolve to `undefined`. Once a
   * property is set, additional defaults of the same property will be ignored.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The destination object.
   * @param {...Object} [source] The source objects.
   * @param- {Object} [guard] Allows working with `_.reduce` without using its
   *  `key` and `object` arguments as sources.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * var object = { &#039;name&#039;: &#039;barney&#039; };
   * _.defaults(object, { &#039;name&#039;: &#039;fred&#039;, &#039;employer&#039;: &#039;slate&#039; });
   * // =&gt; { &#039;name&#039;: &#039;barney&#039;, &#039;employer&#039;: &#039;slate&#039; }
   */
  function defaults(object) {
    if (!object) {
      return object;
    }
    for (var argsIndex = 1, argsLength = arguments.length; argsIndex &lt; argsLength; argsIndex++) {
      var iterable = arguments[argsIndex];
      if (iterable) {
        for (var key in iterable) {
          if (typeof object[key] == &#039;undefined&#039;) {
            object[key] = iterable[key];
          }
        }
      }
    }
    return object;
  }

  /**
   * Iterates over own and inherited enumerable properties of an object,
   * executing the callback for each property. The callback is bound to `thisArg`
   * and invoked with three arguments; (value, key, object). Callbacks may exit
   * iteration early by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function Shape() {
   *   this.x = 0;
   *   this.y = 0;
   * }
   *
   * Shape.prototype.move = function(x, y) {
   *   this.x += x;
   *   this.y += y;
   * };
   *
   * _.forIn(new Shape, function(value, key) {
   *   console.log(key);
   * });
   * // =&gt; logs &#039;x&#039;, &#039;y&#039;, and &#039;move&#039; (property order is not guaranteed across environments)
   */
  var forIn = function(collection, callback) {
    var index, iterable = collection, result = iterable;
    if (!iterable) return result;
    if (!objectTypes[typeof iterable]) return result;
      for (index in iterable) {
        if (callback(iterable[index], index, collection) === indicatorObject) return result;
      }
    return result
  };

  /**
   * Iterates over own enumerable properties of an object, executing the callback
   * for each property. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, key, object). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * _.forOwn({ &#039;0&#039;: &#039;zero&#039;, &#039;1&#039;: &#039;one&#039;, &#039;length&#039;: 2 }, function(num, key) {
   *   console.log(key);
   * });
   * // =&gt; logs &#039;0&#039;, &#039;1&#039;, and &#039;length&#039; (property order is not guaranteed across environments)
   */
  var forOwn = function(collection, callback) {
    var index, iterable = collection, result = iterable;
    if (!iterable) return result;
    if (!objectTypes[typeof iterable]) return result;
      for (index in iterable) {
        if (hasOwnProperty.call(iterable, index)) {
          if (callback(iterable[index], index, collection) === indicatorObject) return result;
        }
      }
    return result
  };

  /**
   * Creates a sorted array of property names of all enumerable properties,
   * own and inherited, of `object` that have function values.
   *
   * @static
   * @memberOf _
   * @alias methods
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property names that have function values.
   * @example
   *
   * _.functions(_);
   * // =&gt; [&#039;all&#039;, &#039;any&#039;, &#039;bind&#039;, &#039;bindAll&#039;, &#039;clone&#039;, &#039;compact&#039;, &#039;compose&#039;, ...]
   */
  function functions(object) {
    var result = [];
    forIn(object, function(value, key) {
      if (isFunction(value)) {
        result.push(key);
      }
    });
    return result.sort();
  }

  /**
   * Checks if the specified property name exists as a direct property of `object`,
   * instead of an inherited property.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @param {string} key The name of the property to check.
   * @returns {boolean} Returns `true` if key is a direct property, else `false`.
   * @example
   *
   * _.has({ &#039;a&#039;: 1, &#039;b&#039;: 2, &#039;c&#039;: 3 }, &#039;b&#039;);
   * // =&gt; true
   */
  function has(object, key) {
    return object ? hasOwnProperty.call(object, key) : false;
  }

  /**
   * Creates an object composed of the inverted keys and values of the given object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to invert.
   * @returns {Object} Returns the created inverted object.
   * @example
   *
   * _.invert({ &#039;first&#039;: &#039;fred&#039;, &#039;second&#039;: &#039;barney&#039; });
   * // =&gt; { &#039;fred&#039;: &#039;first&#039;, &#039;barney&#039;: &#039;second&#039; }
   */
  function invert(object) {
    var index = -1,
        props = keys(object),
        length = props.length,
        result = {};

    while (++index &lt; length) {
      var key = props[index];
      result[object[key]] = key;
    }
    return result;
  }

  /**
   * Checks if `value` is a boolean value.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
   * @example
   *
   * _.isBoolean(null);
   * // =&gt; false
   */
  function isBoolean(value) {
    return value === true || value === false ||
      value &amp;&amp; typeof value == &#039;object&#039; &amp;&amp; toString.call(value) == boolClass || false;
  }

  /**
   * Checks if `value` is a date.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
   * @example
   *
   * _.isDate(new Date);
   * // =&gt; true
   */
  function isDate(value) {
    return value &amp;&amp; typeof value == &#039;object&#039; &amp;&amp; toString.call(value) == dateClass || false;
  }

  /**
   * Checks if `value` is a DOM element.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
   * @example
   *
   * _.isElement(document.body);
   * // =&gt; true
   */
  function isElement(value) {
    return value &amp;&amp; value.nodeType === 1 || false;
  }

  /**
   * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
   * length of `0` and objects with no own enumerable properties are considered
   * &quot;empty&quot;.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Array|Object|string} value The value to inspect.
   * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty([1, 2, 3]);
   * // =&gt; false
   *
   * _.isEmpty({});
   * // =&gt; true
   *
   * _.isEmpty(&#039;&#039;);
   * // =&gt; true
   */
  function isEmpty(value) {
    if (!value) {
      return true;
    }
    if (isArray(value) || isString(value)) {
      return !value.length;
    }
    for (var key in value) {
      if (hasOwnProperty.call(value, key)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent to each other. If a callback is provided it will be executed
   * to compare values. If the callback returns `undefined` comparisons will
   * be handled by the method instead. The callback is bound to `thisArg` and
   * invoked with two arguments; (a, b).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} a The value to compare.
   * @param {*} b The other value to compare.
   * @param {Function} [callback] The function to customize comparing values.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { &#039;name&#039;: &#039;fred&#039; };
   * var copy = { &#039;name&#039;: &#039;fred&#039; };
   *
   * object == copy;
   * // =&gt; false
   *
   * _.isEqual(object, copy);
   * // =&gt; true
   *
   * var words = [&#039;hello&#039;, &#039;goodbye&#039;];
   * var otherWords = [&#039;hi&#039;, &#039;goodbye&#039;];
   *
   * _.isEqual(words, otherWords, function(a, b) {
   *   var reGreet = /^(?:hello|hi)$/i,
   *       aGreet = _.isString(a) &amp;&amp; reGreet.test(a),
   *       bGreet = _.isString(b) &amp;&amp; reGreet.test(b);
   *
   *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
   * });
   * // =&gt; true
   */
  function isEqual(a, b) {
    return baseIsEqual(a, b);
  }

  /**
   * Checks if `value` is, or can be coerced to, a finite number.
   *
   * Note: This is not the same as native `isFinite` which will return true for
   * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
   * @example
   *
   * _.isFinite(-101);
   * // =&gt; true
   *
   * _.isFinite(&#039;10&#039;);
   * // =&gt; true
   *
   * _.isFinite(true);
   * // =&gt; false
   *
   * _.isFinite(&#039;&#039;);
   * // =&gt; false
   *
   * _.isFinite(Infinity);
   * // =&gt; false
   */
  function isFinite(value) {
    return nativeIsFinite(value) &amp;&amp; !nativeIsNaN(parseFloat(value));
  }

  /**
   * Checks if `value` is a function.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // =&gt; true
   */
  function isFunction(value) {
    return typeof value == &#039;function&#039;;
  }
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return typeof value == &#039;function&#039; &amp;&amp; toString.call(value) == funcClass;
    };
  }

  /**
   * Checks if `value` is the language type of Object.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String(&#039;&#039;)`)
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // =&gt; true
   *
   * _.isObject([1, 2, 3]);
   * // =&gt; true
   *
   * _.isObject(1);
   * // =&gt; false
   */
  function isObject(value) {
    // check if the value is the ECMAScript language type of Object
    // http://es5.github.io/#x8
    // and avoid a V8 bug
    // http://code.google.com/p/v8/issues/detail?id=2291
    return !!(value &amp;&amp; objectTypes[typeof value]);
  }

  /**
   * Checks if `value` is `NaN`.
   *
   * Note: This is not the same as native `isNaN` which will return `true` for
   * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // =&gt; true
   *
   * _.isNaN(new Number(NaN));
   * // =&gt; true
   *
   * isNaN(undefined);
   * // =&gt; true
   *
   * _.isNaN(undefined);
   * // =&gt; false
   */
  function isNaN(value) {
    // `NaN` as a primitive is the only value that is not equal to itself
    // (perform the [[Class]] check first to avoid errors with some host objects in IE)
    return isNumber(value) &amp;&amp; value != +value;
  }

  /**
   * Checks if `value` is `null`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // =&gt; true
   *
   * _.isNull(undefined);
   * // =&gt; false
   */
  function isNull(value) {
    return value === null;
  }

  /**
   * Checks if `value` is a number.
   *
   * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(8.4 * 5);
   * // =&gt; true
   */
  function isNumber(value) {
    return typeof value == &#039;number&#039; ||
      value &amp;&amp; typeof value == &#039;object&#039; &amp;&amp; toString.call(value) == numberClass || false;
  }

  /**
   * Checks if `value` is a regular expression.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
   * @example
   *
   * _.isRegExp(/fred/);
   * // =&gt; true
   */
  function isRegExp(value) {
    return value &amp;&amp; objectTypes[typeof value] &amp;&amp; toString.call(value) == regexpClass || false;
  }

  /**
   * Checks if `value` is a string.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
   * @example
   *
   * _.isString(&#039;fred&#039;);
   * // =&gt; true
   */
  function isString(value) {
    return typeof value == &#039;string&#039; ||
      value &amp;&amp; typeof value == &#039;object&#039; &amp;&amp; toString.call(value) == stringClass || false;
  }

  /**
   * Checks if `value` is `undefined`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // =&gt; true
   */
  function isUndefined(value) {
    return typeof value == &#039;undefined&#039;;
  }

  /**
   * Creates a shallow clone of `object` excluding the specified properties.
   * Property names may be specified as individual arguments or as arrays of
   * property names. If a callback is provided it will be executed for each
   * property of `object` omitting the properties the callback returns truey
   * for. The callback is bound to `thisArg` and invoked with three arguments;
   * (value, key, object).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The source object.
   * @param {Function|...string|string[]} [callback] The properties to omit or the
   *  function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns an object without the omitted properties.
   * @example
   *
   * _.omit({ &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40 }, &#039;age&#039;);
   * // =&gt; { &#039;name&#039;: &#039;fred&#039; }
   *
   * _.omit({ &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40 }, function(value) {
   *   return typeof value == &#039;number&#039;;
   * });
   * // =&gt; { &#039;name&#039;: &#039;fred&#039; }
   */
  function omit(object) {
    var props = [];
    forIn(object, function(value, key) {
      props.push(key);
    });
    props = baseDifference(props, baseFlatten(arguments, true, false, 1));

    var index = -1,
        length = props.length,
        result = {};

    while (++index &lt; length) {
      var key = props[index];
      result[key] = object[key];
    }
    return result;
  }

  /**
   * Creates a two dimensional array of an object&#039;s key-value pairs,
   * i.e. `[[key1, value1], [key2, value2]]`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns new array of key-value pairs.
   * @example
   *
   * _.pairs({ &#039;barney&#039;: 36, &#039;fred&#039;: 40 });
   * // =&gt; [[&#039;barney&#039;, 36], [&#039;fred&#039;, 40]] (property order is not guaranteed across environments)
   */
  function pairs(object) {
    var index = -1,
        props = keys(object),
        length = props.length,
        result = Array(length);

    while (++index &lt; length) {
      var key = props[index];
      result[index] = [key, object[key]];
    }
    return result;
  }

  /**
   * Creates a shallow clone of `object` composed of the specified properties.
   * Property names may be specified as individual arguments or as arrays of
   * property names. If a callback is provided it will be executed for each
   * property of `object` picking the properties the callback returns truey
   * for. The callback is bound to `thisArg` and invoked with three arguments;
   * (value, key, object).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The source object.
   * @param {Function|...string|string[]} [callback] The function called per
   *  iteration or property names to pick, specified as individual property
   *  names or arrays of property names.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns an object composed of the picked properties.
   * @example
   *
   * _.pick({ &#039;name&#039;: &#039;fred&#039;, &#039;_userid&#039;: &#039;fred1&#039; }, &#039;name&#039;);
   * // =&gt; { &#039;name&#039;: &#039;fred&#039; }
   *
   * _.pick({ &#039;name&#039;: &#039;fred&#039;, &#039;_userid&#039;: &#039;fred1&#039; }, function(value, key) {
   *   return key.charAt(0) != &#039;_&#039;;
   * });
   * // =&gt; { &#039;name&#039;: &#039;fred&#039; }
   */
  function pick(object) {
    var index = -1,
        props = baseFlatten(arguments, true, false, 1),
        length = props.length,
        result = {};

    while (++index &lt; length) {
      var key = props[index];
      if (key in object) {
        result[key] = object[key];
      }
    }
    return result;
  }

  /**
   * Creates an array composed of the own enumerable property values of `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns an array of property values.
   * @example
   *
   * _.values({ &#039;one&#039;: 1, &#039;two&#039;: 2, &#039;three&#039;: 3 });
   * // =&gt; [1, 2, 3] (property order is not guaranteed across environments)
   */
  function values(object) {
    var index = -1,
        props = keys(object),
        length = props.length,
        result = Array(length);

    while (++index &lt; length) {
      result[index] = object[props[index]];
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if a given value is present in a collection using strict equality
   * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
   * offset from the end of the collection.
   *
   * @static
   * @memberOf _
   * @alias include
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {*} target The value to check for.
   * @param {number} [fromIndex=0] The index to search from.
   * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
   * @example
   *
   * _.contains([1, 2, 3], 1);
   * // =&gt; true
   *
   * _.contains([1, 2, 3], 1, 2);
   * // =&gt; false
   *
   * _.contains({ &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40 }, &#039;fred&#039;);
   * // =&gt; true
   *
   * _.contains(&#039;pebbles&#039;, &#039;eb&#039;);
   * // =&gt; true
   */
  function contains(collection, target) {
    var indexOf = getIndexOf(),
        length = collection ? collection.length : 0,
        result = false;
    if (length &amp;&amp; typeof length == &#039;number&#039;) {
      result = indexOf(collection, target) &gt; -1;
    } else {
      forOwn(collection, function(value) {
        return (result = value === target) &amp;&amp; indicatorObject;
      });
    }
    return result;
  }

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of `collection` through the callback. The corresponding value
   * of each key is the number of times the key was returned by the callback.
   * The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
   * // =&gt; { &#039;4&#039;: 1, &#039;6&#039;: 2 }
   *
   * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
   * // =&gt; { &#039;4&#039;: 1, &#039;6&#039;: 2 }
   *
   * _.countBy([&#039;one&#039;, &#039;two&#039;, &#039;three&#039;], &#039;length&#039;);
   * // =&gt; { &#039;3&#039;: 2, &#039;5&#039;: 1 }
   */
  var countBy = createAggregator(function(result, value, key) {
    (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
  });

  /**
   * Checks if the given callback returns truey value for **all** elements of
   * a collection. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias all
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if all elements passed the callback check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, &#039;yes&#039;]);
   * // =&gt; false
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.every(characters, &#039;age&#039;);
   * // =&gt; true
   *
   * // using &quot;_.where&quot; callback shorthand
   * _.every(characters, { &#039;age&#039;: 36 });
   * // =&gt; false
   */
  function every(collection, callback, thisArg) {
    var result = true;
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    if (typeof length == &#039;number&#039;) {
      while (++index &lt; length) {
        if (!(result = !!callback(collection[index], index, collection))) {
          break;
        }
      }
    } else {
      forOwn(collection, function(value, index, collection) {
        return !(result = !!callback(value, index, collection)) &amp;&amp; indicatorObject;
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning an array of all elements
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias select
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that passed the callback check.
   * @example
   *
   * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // =&gt; [2, 4, 6]
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36, &#039;blocked&#039;: false },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40, &#039;blocked&#039;: true }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.filter(characters, &#039;blocked&#039;);
   * // =&gt; [{ &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40, &#039;blocked&#039;: true }]
   *
   * // using &quot;_.where&quot; callback shorthand
   * _.filter(characters, { &#039;age&#039;: 36 });
   * // =&gt; [{ &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36, &#039;blocked&#039;: false }]
   */
  function filter(collection, callback, thisArg) {
    var result = [];
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    if (typeof length == &#039;number&#039;) {
      while (++index &lt; length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          result.push(value);
        }
      }
    } else {
      forOwn(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result.push(value);
        }
      });
    }
    return result;
  }

  /**
   * Iterates over elements of a collection, returning the first element that
   * the callback returns truey for. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias detect, findWhere
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the found element, else `undefined`.
   * @example
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;,  &#039;age&#039;: 36, &#039;blocked&#039;: false },
   *   { &#039;name&#039;: &#039;fred&#039;,    &#039;age&#039;: 40, &#039;blocked&#039;: true },
   *   { &#039;name&#039;: &#039;pebbles&#039;, &#039;age&#039;: 1,  &#039;blocked&#039;: false }
   * ];
   *
   * _.find(characters, function(chr) {
   *   return chr.age &lt; 40;
   * });
   * // =&gt; { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36, &#039;blocked&#039;: false }
   *
   * // using &quot;_.where&quot; callback shorthand
   * _.find(characters, { &#039;age&#039;: 1 });
   * // =&gt;  { &#039;name&#039;: &#039;pebbles&#039;, &#039;age&#039;: 1, &#039;blocked&#039;: false }
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.find(characters, &#039;blocked&#039;);
   * // =&gt; { &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40, &#039;blocked&#039;: true }
   */
  function find(collection, callback, thisArg) {
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    if (typeof length == &#039;number&#039;) {
      while (++index &lt; length) {
        var value = collection[index];
        if (callback(value, index, collection)) {
          return value;
        }
      }
    } else {
      var result;
      forOwn(collection, function(value, index, collection) {
        if (callback(value, index, collection)) {
          result = value;
          return indicatorObject;
        }
      });
      return result;
    }
  }

  /**
   * Examines each element in a `collection`, returning the first that
   * has the given properties. When checking `properties`, this method
   * performs a deep comparison between values to determine if they are
   * equivalent to each other.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Object} properties The object of property values to filter by.
   * @returns {*} Returns the found element, else `undefined`.
   * @example
   *
   * var food = [
   *   { &#039;name&#039;: &#039;apple&#039;,  &#039;organic&#039;: false, &#039;type&#039;: &#039;fruit&#039; },
   *   { &#039;name&#039;: &#039;banana&#039;, &#039;organic&#039;: true,  &#039;type&#039;: &#039;fruit&#039; },
   *   { &#039;name&#039;: &#039;beet&#039;,   &#039;organic&#039;: false, &#039;type&#039;: &#039;vegetable&#039; }
   * ];
   *
   * _.findWhere(food, { &#039;type&#039;: &#039;vegetable&#039; });
   * // =&gt; { &#039;name&#039;: &#039;beet&#039;, &#039;organic&#039;: false, &#039;type&#039;: &#039;vegetable&#039; }
   */
  function findWhere(object, properties) {
    return where(object, properties, true);
  }

  /**
   * Iterates over elements of a collection, executing the callback for each
   * element. The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection). Callbacks may exit iteration early by
   * explicitly returning `false`.
   *
   * Note: As with other &quot;Collections&quot; methods, objects with a `length` property
   * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
   * may be used for object iteration.
   *
   * @static
   * @memberOf _
   * @alias each
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   * @example
   *
   * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(&#039;,&#039;);
   * // =&gt; logs each number and returns &#039;1,2,3&#039;
   *
   * _.forEach({ &#039;one&#039;: 1, &#039;two&#039;: 2, &#039;three&#039;: 3 }, function(num) { console.log(num); });
   * // =&gt; logs each number and returns the object (property order is not guaranteed across environments)
   */
  function forEach(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0;

    callback = callback &amp;&amp; typeof thisArg == &#039;undefined&#039; ? callback : baseCreateCallback(callback, thisArg, 3);
    if (typeof length == &#039;number&#039;) {
      while (++index &lt; length) {
        if (callback(collection[index], index, collection) === indicatorObject) {
          break;
        }
      }
    } else {
      forOwn(collection, callback);
    }
  }

  /**
   * This method is like `_.forEach` except that it iterates over elements
   * of a `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @alias eachRight
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|string} Returns `collection`.
   * @example
   *
   * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(&#039;,&#039;);
   * // =&gt; logs each number from right to left and returns &#039;3,2,1&#039;
   */
  function forEachRight(collection, callback) {
    var length = collection ? collection.length : 0;
    if (typeof length == &#039;number&#039;) {
      while (length--) {
        if (callback(collection[length], length, collection) === false) {
          break;
        }
      }
    } else {
      var props = keys(collection);
      length = props.length;
      forOwn(collection, function(value, key, collection) {
        key = props ? props[--length] : --length;
        return callback(collection[key], key, collection) === false &amp;&amp; indicatorObject;
      });
    }
  }

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of a collection through the callback. The corresponding value
   * of each key is an array of the elements responsible for generating the key.
   * The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
   * // =&gt; { &#039;4&#039;: [4.2], &#039;6&#039;: [6.1, 6.4] }
   *
   * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
   * // =&gt; { &#039;4&#039;: [4.2], &#039;6&#039;: [6.1, 6.4] }
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.groupBy([&#039;one&#039;, &#039;two&#039;, &#039;three&#039;], &#039;length&#039;);
   * // =&gt; { &#039;3&#039;: [&#039;one&#039;, &#039;two&#039;], &#039;5&#039;: [&#039;three&#039;] }
   */
  var groupBy = createAggregator(function(result, value, key) {
    (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
  });

  /**
   * Creates an object composed of keys generated from the results of running
   * each element of the collection through the given callback. The corresponding
   * value of each key is the last element responsible for generating the key.
   * The callback is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * var keys = [
   *   { &#039;dir&#039;: &#039;left&#039;, &#039;code&#039;: 97 },
   *   { &#039;dir&#039;: &#039;right&#039;, &#039;code&#039;: 100 }
   * ];
   *
   * _.indexBy(keys, &#039;dir&#039;);
   * // =&gt; { &#039;left&#039;: { &#039;dir&#039;: &#039;left&#039;, &#039;code&#039;: 97 }, &#039;right&#039;: { &#039;dir&#039;: &#039;right&#039;, &#039;code&#039;: 100 } }
   *
   * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
   * // =&gt; { &#039;a&#039;: { &#039;dir&#039;: &#039;left&#039;, &#039;code&#039;: 97 }, &#039;d&#039;: { &#039;dir&#039;: &#039;right&#039;, &#039;code&#039;: 100 } }
   *
   * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
   * // =&gt; { &#039;a&#039;: { &#039;dir&#039;: &#039;left&#039;, &#039;code&#039;: 97 }, &#039;d&#039;: { &#039;dir&#039;: &#039;right&#039;, &#039;code&#039;: 100 } }
   */
  var indexBy = createAggregator(function(result, value, key) {
    result[key] = value;
  });

  /**
   * Invokes the method named by `methodName` on each element in the `collection`
   * returning an array of the results of each invoked method. Additional arguments
   * will be provided to each invoked method. If `methodName` is a function it
   * will be invoked for, and `this` bound to, each element in the `collection`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|string} methodName The name of the method to invoke or
   *  the function invoked per iteration.
   * @param {...*} [arg] Arguments to invoke the method with.
   * @returns {Array} Returns a new array of the results of each invoked method.
   * @example
   *
   * _.invoke([[5, 1, 7], [3, 2, 1]], &#039;sort&#039;);
   * // =&gt; [[1, 5, 7], [1, 2, 3]]
   *
   * _.invoke([123, 456], String.prototype.split, &#039;&#039;);
   * // =&gt; [[&#039;1&#039;, &#039;2&#039;, &#039;3&#039;], [&#039;4&#039;, &#039;5&#039;, &#039;6&#039;]]
   */
  function invoke(collection, methodName) {
    var args = slice(arguments, 2),
        index = -1,
        isFunc = typeof methodName == &#039;function&#039;,
        length = collection ? collection.length : 0,
        result = Array(typeof length == &#039;number&#039; ? length : 0);

    forEach(collection, function(value) {
      result[++index] = (isFunc ? methodName : value[methodName]).apply(value, args);
    });
    return result;
  }

  /**
   * Creates an array of values by running each element in the collection
   * through the callback. The callback is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias collect
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of the results of each `callback` execution.
   * @example
   *
   * _.map([1, 2, 3], function(num) { return num * 3; });
   * // =&gt; [3, 6, 9]
   *
   * _.map({ &#039;one&#039;: 1, &#039;two&#039;: 2, &#039;three&#039;: 3 }, function(num) { return num * 3; });
   * // =&gt; [3, 6, 9] (property order is not guaranteed across environments)
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.map(characters, &#039;name&#039;);
   * // =&gt; [&#039;barney&#039;, &#039;fred&#039;]
   */
  function map(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0;

    callback = createCallback(callback, thisArg, 3);
    if (typeof length == &#039;number&#039;) {
      var result = Array(length);
      while (++index &lt; length) {
        result[index] = callback(collection[index], index, collection);
      }
    } else {
      result = [];
      forOwn(collection, function(value, key, collection) {
        result[++index] = callback(value, key, collection);
      });
    }
    return result;
  }

  /**
   * Retrieves the maximum value of a collection. If the collection is empty or
   * falsey `-Infinity` is returned. If a callback is provided it will be executed
   * for each value in the collection to generate the criterion by which the value
   * is ranked. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the maximum value.
   * @example
   *
   * _.max([4, 2, 8, 6]);
   * // =&gt; 8
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 }
   * ];
   *
   * _.max(characters, function(chr) { return chr.age; });
   * // =&gt; { &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40 };
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.max(characters, &#039;age&#039;);
   * // =&gt; { &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40 };
   */
  function max(collection, callback, thisArg) {
    var computed = -Infinity,
        result = computed;

    // allows working with functions like `_.map` without using
    // their `index` argument as a callback
    if (typeof callback != &#039;function&#039; &amp;&amp; thisArg &amp;&amp; thisArg[callback] === collection) {
      callback = null;
    }
    var index = -1,
        length = collection ? collection.length : 0;

    if (callback == null &amp;&amp; typeof length == &#039;number&#039;) {
      while (++index &lt; length) {
        var value = collection[index];
        if (value &gt; result) {
          result = value;
        }
      }
    } else {
      callback = createCallback(callback, thisArg, 3);

      forEach(collection, function(value, index, collection) {
        var current = callback(value, index, collection);
        if (current &gt; computed) {
          computed = current;
          result = value;
        }
      });
    }
    return result;
  }

  /**
   * Retrieves the minimum value of a collection. If the collection is empty or
   * falsey `Infinity` is returned. If a callback is provided it will be executed
   * for each value in the collection to generate the criterion by which the value
   * is ranked. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the minimum value.
   * @example
   *
   * _.min([4, 2, 8, 6]);
   * // =&gt; 2
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 }
   * ];
   *
   * _.min(characters, function(chr) { return chr.age; });
   * // =&gt; { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 };
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.min(characters, &#039;age&#039;);
   * // =&gt; { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 };
   */
  function min(collection, callback, thisArg) {
    var computed = Infinity,
        result = computed;

    // allows working with functions like `_.map` without using
    // their `index` argument as a callback
    if (typeof callback != &#039;function&#039; &amp;&amp; thisArg &amp;&amp; thisArg[callback] === collection) {
      callback = null;
    }
    var index = -1,
        length = collection ? collection.length : 0;

    if (callback == null &amp;&amp; typeof length == &#039;number&#039;) {
      while (++index &lt; length) {
        var value = collection[index];
        if (value &lt; result) {
          result = value;
        }
      }
    } else {
      callback = createCallback(callback, thisArg, 3);

      forEach(collection, function(value, index, collection) {
        var current = callback(value, index, collection);
        if (current &lt; computed) {
          computed = current;
          result = value;
        }
      });
    }
    return result;
  }

  /**
   * Retrieves the value of a specified property from all elements in the collection.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {string} property The name of the property to pluck.
   * @returns {Array} Returns a new array of property values.
   * @example
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 }
   * ];
   *
   * _.pluck(characters, &#039;name&#039;);
   * // =&gt; [&#039;barney&#039;, &#039;fred&#039;]
   */
  var pluck = map;

  /**
   * Reduces a collection to a value which is the accumulated result of running
   * each element in the collection through the callback, where each successive
   * callback execution consumes the return value of the previous execution. If
   * `accumulator` is not provided the first element of the collection will be
   * used as the initial `accumulator` value. The callback is bound to `thisArg`
   * and invoked with four arguments; (accumulator, value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias foldl, inject
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [accumulator] Initial value of the accumulator.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the accumulated value.
   * @example
   *
   * var sum = _.reduce([1, 2, 3], function(sum, num) {
   *   return sum + num;
   * });
   * // =&gt; 6
   *
   * var mapped = _.reduce({ &#039;a&#039;: 1, &#039;b&#039;: 2, &#039;c&#039;: 3 }, function(result, num, key) {
   *   result[key] = num * 3;
   *   return result;
   * }, {});
   * // =&gt; { &#039;a&#039;: 3, &#039;b&#039;: 6, &#039;c&#039;: 9 }
   */
  function reduce(collection, callback, accumulator, thisArg) {
    if (!collection) return accumulator;
    var noaccum = arguments.length &lt; 3;
    callback = createCallback(callback, thisArg, 4);

    var index = -1,
        length = collection.length;

    if (typeof length == &#039;number&#039;) {
      if (noaccum) {
        accumulator = collection[++index];
      }
      while (++index &lt; length) {
        accumulator = callback(accumulator, collection[index], index, collection);
      }
    } else {
      forOwn(collection, function(value, index, collection) {
        accumulator = noaccum
          ? (noaccum = false, value)
          : callback(accumulator, value, index, collection)
      });
    }
    return accumulator;
  }

  /**
   * This method is like `_.reduce` except that it iterates over elements
   * of a `collection` from right to left.
   *
   * @static
   * @memberOf _
   * @alias foldr
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {*} [accumulator] Initial value of the accumulator.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the accumulated value.
   * @example
   *
   * var list = [[0, 1], [2, 3], [4, 5]];
   * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
   * // =&gt; [4, 5, 2, 3, 0, 1]
   */
  function reduceRight(collection, callback, accumulator, thisArg) {
    var noaccum = arguments.length &lt; 3;
    callback = createCallback(callback, thisArg, 4);
    forEachRight(collection, function(value, index, collection) {
      accumulator = noaccum
        ? (noaccum = false, value)
        : callback(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The opposite of `_.filter` this method returns the elements of a
   * collection that the callback does **not** return truey for.
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that failed the callback check.
   * @example
   *
   * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // =&gt; [1, 3, 5]
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36, &#039;blocked&#039;: false },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40, &#039;blocked&#039;: true }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.reject(characters, &#039;blocked&#039;);
   * // =&gt; [{ &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36, &#039;blocked&#039;: false }]
   *
   * // using &quot;_.where&quot; callback shorthand
   * _.reject(characters, { &#039;age&#039;: 36 });
   * // =&gt; [{ &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40, &#039;blocked&#039;: true }]
   */
  function reject(collection, callback, thisArg) {
    callback = createCallback(callback, thisArg, 3);
    return filter(collection, function(value, index, collection) {
      return !callback(value, index, collection);
    });
  }

  /**
   * Retrieves a random element or `n` random elements from a collection.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to sample.
   * @param {number} [n] The number of elements to sample.
   * @param- {Object} [guard] Allows working with functions like `_.map`
   *  without using their `index` arguments as `n`.
   * @returns {Array} Returns the random sample(s) of `collection`.
   * @example
   *
   * _.sample([1, 2, 3, 4]);
   * // =&gt; 2
   *
   * _.sample([1, 2, 3, 4], 2);
   * // =&gt; [3, 1]
   */
  function sample(collection, n, guard) {
    if (collection &amp;&amp; typeof collection.length != &#039;number&#039;) {
      collection = values(collection);
    }
    if (n == null || guard) {
      return collection ? collection[baseRandom(0, collection.length - 1)] : undefined;
    }
    var result = shuffle(collection);
    result.length = nativeMin(nativeMax(0, n), result.length);
    return result;
  }

  /**
   * Creates an array of shuffled values, using a version of the Fisher-Yates
   * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to shuffle.
   * @returns {Array} Returns a new shuffled collection.
   * @example
   *
   * _.shuffle([1, 2, 3, 4, 5, 6]);
   * // =&gt; [4, 1, 6, 3, 5, 2]
   */
  function shuffle(collection) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == &#039;number&#039; ? length : 0);

    forEach(collection, function(value) {
      var rand = baseRandom(0, ++index);
      result[index] = result[rand];
      result[rand] = value;
    });
    return result;
  }

  /**
   * Gets the size of the `collection` by returning `collection.length` for arrays
   * and array-like objects or the number of own enumerable properties for objects.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to inspect.
   * @returns {number} Returns `collection.length` or number of own enumerable properties.
   * @example
   *
   * _.size([1, 2]);
   * // =&gt; 2
   *
   * _.size({ &#039;one&#039;: 1, &#039;two&#039;: 2, &#039;three&#039;: 3 });
   * // =&gt; 3
   *
   * _.size(&#039;pebbles&#039;);
   * // =&gt; 7
   */
  function size(collection) {
    var length = collection ? collection.length : 0;
    return typeof length == &#039;number&#039; ? length : keys(collection).length;
  }

  /**
   * Checks if the callback returns a truey value for **any** element of a
   * collection. The function returns as soon as it finds a passing value and
   * does not iterate over the entire collection. The callback is bound to
   * `thisArg` and invoked with three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias any
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {boolean} Returns `true` if any element passed the callback check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, &#039;yes&#039;, false], Boolean);
   * // =&gt; true
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36, &#039;blocked&#039;: false },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40, &#039;blocked&#039;: true }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.some(characters, &#039;blocked&#039;);
   * // =&gt; true
   *
   * // using &quot;_.where&quot; callback shorthand
   * _.some(characters, { &#039;age&#039;: 1 });
   * // =&gt; false
   */
  function some(collection, callback, thisArg) {
    var result;
    callback = createCallback(callback, thisArg, 3);

    var index = -1,
        length = collection ? collection.length : 0;

    if (typeof length == &#039;number&#039;) {
      while (++index &lt; length) {
        if ((result = callback(collection[index], index, collection))) {
          break;
        }
      }
    } else {
      forOwn(collection, function(value, index, collection) {
        return (result = callback(value, index, collection)) &amp;&amp; indicatorObject;
      });
    }
    return !!result;
  }

  /**
   * Creates an array of elements, sorted in ascending order by the results of
   * running each element in a collection through the callback. This method
   * performs a stable sort, that is, it will preserve the original sort order
   * of equal elements. The callback is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an array of property names is provided for `callback` the collection
   * will be sorted by each property value.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Array|Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of sorted elements.
   * @example
   *
   * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
   * // =&gt; [3, 1, 2]
   *
   * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
   * // =&gt; [3, 1, 2]
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;,  &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,    &#039;age&#039;: 40 },
   *   { &#039;name&#039;: &#039;barney&#039;,  &#039;age&#039;: 26 },
   *   { &#039;name&#039;: &#039;fred&#039;,    &#039;age&#039;: 30 }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.map(_.sortBy(characters, &#039;age&#039;), _.values);
   * // =&gt; [[&#039;barney&#039;, 26], [&#039;fred&#039;, 30], [&#039;barney&#039;, 36], [&#039;fred&#039;, 40]]
   *
   * // sorting by multiple properties
   * _.map(_.sortBy(characters, [&#039;name&#039;, &#039;age&#039;]), _.values);
   * // = &gt; [[&#039;barney&#039;, 26], [&#039;barney&#039;, 36], [&#039;fred&#039;, 30], [&#039;fred&#039;, 40]]
   */
  function sortBy(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == &#039;number&#039; ? length : 0);

    callback = createCallback(callback, thisArg, 3);
    forEach(collection, function(value, key, collection) {
      result[++index] = {
        &#039;criteria&#039;: [callback(value, key, collection)],
        &#039;index&#039;: index,
        &#039;value&#039;: value
      };
    });

    length = result.length;
    result.sort(compareAscending);
    while (length--) {
      result[length] = result[length].value;
    }
    return result;
  }

  /**
   * Converts the `collection` to an array.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|string} collection The collection to convert.
   * @returns {Array} Returns the new converted array.
   * @example
   *
   * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
   * // =&gt; [2, 3, 4]
   */
  function toArray(collection) {
    if (isArray(collection)) {
      return slice(collection);
    }
    if (collection &amp;&amp; typeof collection.length == &#039;number&#039;) {
      return map(collection);
    }
    return values(collection);
  }

  /**
   * Performs a deep comparison of each element in a `collection` to the given
   * `properties` object, returning an array of all elements that have equivalent
   * property values.
   *
   * @static
   * @memberOf _
   * @type Function
   * @category Collections
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Object} props The object of property values to filter by.
   * @returns {Array} Returns a new array of elements that have the given properties.
   * @example
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36, &#039;pets&#039;: [&#039;hoppy&#039;] },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40, &#039;pets&#039;: [&#039;baby puss&#039;, &#039;dino&#039;] }
   * ];
   *
   * _.where(characters, { &#039;age&#039;: 36 });
   * // =&gt; [{ &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36, &#039;pets&#039;: [&#039;hoppy&#039;] }]
   *
   * _.where(characters, { &#039;pets&#039;: [&#039;dino&#039;] });
   * // =&gt; [{ &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40, &#039;pets&#039;: [&#039;baby puss&#039;, &#039;dino&#039;] }]
   */
  function where(collection, properties, first) {
    return (first &amp;&amp; isEmpty(properties))
      ? undefined
      : (first ? find : filter)(collection, properties);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values removed. The values `false`, `null`,
   * `0`, `&quot;&quot;`, `undefined`, and `NaN` are all falsey.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to compact.
   * @returns {Array} Returns a new array of filtered values.
   * @example
   *
   * _.compact([0, 1, false, 2, &#039;&#039;, 3]);
   * // =&gt; [1, 2, 3]
   */
  function compact(array) {
    var index = -1,
        length = array ? array.length : 0,
        result = [];

    while (++index &lt; length) {
      var value = array[index];
      if (value) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Creates an array excluding all values of the provided arrays using strict
   * equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {...Array} [values] The arrays of values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   * @example
   *
   * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
   * // =&gt; [1, 3, 4]
   */
  function difference(array) {
    return baseDifference(array, baseFlatten(arguments, true, true, 1));
  }

  /**
   * Gets the first element or first `n` elements of an array. If a callback
   * is provided elements at the beginning of the array are returned as long
   * as the callback returns truey. The callback is bound to `thisArg` and
   * invoked with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias head, take
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback] The function called
   *  per element or the number of elements to return. If a property name or
   *  object is provided it will be used to create a &quot;_.pluck&quot; or &quot;_.where&quot;
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the first element(s) of `array`.
   * @example
   *
   * _.first([1, 2, 3]);
   * // =&gt; 1
   *
   * _.first([1, 2, 3], 2);
   * // =&gt; [1, 2]
   *
   * _.first([1, 2, 3], function(num) {
   *   return num &lt; 3;
   * });
   * // =&gt; [1, 2]
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;,  &#039;blocked&#039;: true,  &#039;employer&#039;: &#039;slate&#039; },
   *   { &#039;name&#039;: &#039;fred&#039;,    &#039;blocked&#039;: false, &#039;employer&#039;: &#039;slate&#039; },
   *   { &#039;name&#039;: &#039;pebbles&#039;, &#039;blocked&#039;: true,  &#039;employer&#039;: &#039;na&#039; }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.first(characters, &#039;blocked&#039;);
   * // =&gt; [{ &#039;name&#039;: &#039;barney&#039;, &#039;blocked&#039;: true, &#039;employer&#039;: &#039;slate&#039; }]
   *
   * // using &quot;_.where&quot; callback shorthand
   * _.pluck(_.first(characters, { &#039;employer&#039;: &#039;slate&#039; }), &#039;name&#039;);
   * // =&gt; [&#039;barney&#039;, &#039;fred&#039;]
   */
  function first(array, callback, thisArg) {
    var n = 0,
        length = array ? array.length : 0;

    if (typeof callback != &#039;number&#039; &amp;&amp; callback != null) {
      var index = -1;
      callback = createCallback(callback, thisArg, 3);
      while (++index &lt; length &amp;&amp; callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = callback;
      if (n == null || thisArg) {
        return array ? array[0] : undefined;
      }
    }
    return slice(array, 0, nativeMin(nativeMax(0, n), length));
  }

  /**
   * Flattens a nested array (the nesting can be to any depth). If `isShallow`
   * is truey, the array will only be flattened a single level. If a callback
   * is provided each element of the array is passed through the callback before
   * flattening. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to flatten.
   * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new flattened array.
   * @example
   *
   * _.flatten([1, [2], [3, [[4]]]]);
   * // =&gt; [1, 2, 3, 4];
   *
   * _.flatten([1, [2], [3, [[4]]]], true);
   * // =&gt; [1, 2, 3, [[4]]];
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 30, &#039;pets&#039;: [&#039;hoppy&#039;] },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40, &#039;pets&#039;: [&#039;baby puss&#039;, &#039;dino&#039;] }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.flatten(characters, &#039;pets&#039;);
   * // =&gt; [&#039;hoppy&#039;, &#039;baby puss&#039;, &#039;dino&#039;]
   */
  function flatten(array, isShallow) {
    return baseFlatten(array, isShallow);
  }

  /**
   * Gets the index at which the first occurrence of `value` is found using
   * strict equality for comparisons, i.e. `===`. If the array is already sorted
   * providing `true` for `fromIndex` will run a faster binary search.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {boolean|number} [fromIndex=0] The index to search from or `true`
   *  to perform a binary search on a sorted array.
   * @returns {number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2);
   * // =&gt; 1
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // =&gt; 4
   *
   * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
   * // =&gt; 2
   */
  function indexOf(array, value, fromIndex) {
    if (typeof fromIndex == &#039;number&#039;) {
      var length = array ? array.length : 0;
      fromIndex = (fromIndex &lt; 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0);
    } else if (fromIndex) {
      var index = sortedIndex(array, value);
      return array[index] === value ? index : -1;
    }
    return baseIndexOf(array, value, fromIndex);
  }

  /**
   * Gets all but the last element or last `n` elements of an array. If a
   * callback is provided elements at the end of the array are excluded from
   * the result as long as the callback returns truey. The callback is bound
   * to `thisArg` and invoked with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback=1] The function called
   *  per element or the number of elements to exclude. If a property name or
   *  object is provided it will be used to create a &quot;_.pluck&quot; or &quot;_.where&quot;
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a slice of `array`.
   * @example
   *
   * _.initial([1, 2, 3]);
   * // =&gt; [1, 2]
   *
   * _.initial([1, 2, 3], 2);
   * // =&gt; [1]
   *
   * _.initial([1, 2, 3], function(num) {
   *   return num &gt; 1;
   * });
   * // =&gt; [1]
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;,  &#039;blocked&#039;: false, &#039;employer&#039;: &#039;slate&#039; },
   *   { &#039;name&#039;: &#039;fred&#039;,    &#039;blocked&#039;: true,  &#039;employer&#039;: &#039;slate&#039; },
   *   { &#039;name&#039;: &#039;pebbles&#039;, &#039;blocked&#039;: true,  &#039;employer&#039;: &#039;na&#039; }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.initial(characters, &#039;blocked&#039;);
   * // =&gt; [{ &#039;name&#039;: &#039;barney&#039;,  &#039;blocked&#039;: false, &#039;employer&#039;: &#039;slate&#039; }]
   *
   * // using &quot;_.where&quot; callback shorthand
   * _.pluck(_.initial(characters, { &#039;employer&#039;: &#039;na&#039; }), &#039;name&#039;);
   * // =&gt; [&#039;barney&#039;, &#039;fred&#039;]
   */
  function initial(array, callback, thisArg) {
    var n = 0,
        length = array ? array.length : 0;

    if (typeof callback != &#039;number&#039; &amp;&amp; callback != null) {
      var index = length;
      callback = createCallback(callback, thisArg, 3);
      while (index-- &amp;&amp; callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = (callback == null || thisArg) ? 1 : callback || n;
    }
    return slice(array, 0, nativeMin(nativeMax(0, length - n), length));
  }

  /**
   * Creates an array of unique values present in all provided arrays using
   * strict equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {...Array} [array] The arrays to inspect.
   * @returns {Array} Returns an array of shared values.
   * @example
   *
   * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
   * // =&gt; [1, 2]
   */
  function intersection() {
    var args = [],
        argsIndex = -1,
        argsLength = arguments.length;

    while (++argsIndex &lt; argsLength) {
      var value = arguments[argsIndex];
       if (isArray(value) || isArguments(value)) {
         args.push(value);
       }
    }
    var array = args[0],
        index = -1,
        indexOf = getIndexOf(),
        length = array ? array.length : 0,
        result = [];

    outer:
    while (++index &lt; length) {
      value = array[index];
      if (indexOf(result, value) &lt; 0) {
        var argsIndex = argsLength;
        while (--argsIndex) {
          if (indexOf(args[argsIndex], value) &lt; 0) {
            continue outer;
          }
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Gets the last element or last `n` elements of an array. If a callback is
   * provided elements at the end of the array are returned as long as the
   * callback returns truey. The callback is bound to `thisArg` and invoked
   * with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback] The function called
   *  per element or the number of elements to return. If a property name or
   *  object is provided it will be used to create a &quot;_.pluck&quot; or &quot;_.where&quot;
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {*} Returns the last element(s) of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // =&gt; 3
   *
   * _.last([1, 2, 3], 2);
   * // =&gt; [2, 3]
   *
   * _.last([1, 2, 3], function(num) {
   *   return num &gt; 1;
   * });
   * // =&gt; [2, 3]
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;,  &#039;blocked&#039;: false, &#039;employer&#039;: &#039;slate&#039; },
   *   { &#039;name&#039;: &#039;fred&#039;,    &#039;blocked&#039;: true,  &#039;employer&#039;: &#039;slate&#039; },
   *   { &#039;name&#039;: &#039;pebbles&#039;, &#039;blocked&#039;: true,  &#039;employer&#039;: &#039;na&#039; }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.pluck(_.last(characters, &#039;blocked&#039;), &#039;name&#039;);
   * // =&gt; [&#039;fred&#039;, &#039;pebbles&#039;]
   *
   * // using &quot;_.where&quot; callback shorthand
   * _.last(characters, { &#039;employer&#039;: &#039;na&#039; });
   * // =&gt; [{ &#039;name&#039;: &#039;pebbles&#039;, &#039;blocked&#039;: true, &#039;employer&#039;: &#039;na&#039; }]
   */
  function last(array, callback, thisArg) {
    var n = 0,
        length = array ? array.length : 0;

    if (typeof callback != &#039;number&#039; &amp;&amp; callback != null) {
      var index = length;
      callback = createCallback(callback, thisArg, 3);
      while (index-- &amp;&amp; callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = callback;
      if (n == null || thisArg) {
        return array ? array[length - 1] : undefined;
      }
    }
    return slice(array, nativeMax(0, length - n));
  }

  /**
   * Gets the index at which the last occurrence of `value` is found using strict
   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
   * as the offset from the end of the collection.
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} [fromIndex=array.length-1] The index to search from.
   * @returns {number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
   * // =&gt; 4
   *
   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // =&gt; 1
   */
  function lastIndexOf(array, value, fromIndex) {
    var index = array ? array.length : 0;
    if (typeof fromIndex == &#039;number&#039;) {
      index = (fromIndex &lt; 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
    }
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Creates an array of numbers (positive and/or negative) progressing from
   * `start` up to but not including `end`. If `start` is less than `stop` a
   * zero-length range is created unless a negative `step` is specified.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {number} [start=0] The start of the range.
   * @param {number} end The end of the range.
   * @param {number} [step=1] The value to increment or decrement by.
   * @returns {Array} Returns a new range array.
   * @example
   *
   * _.range(4);
   * // =&gt; [0, 1, 2, 3]
   *
   * _.range(1, 5);
   * // =&gt; [1, 2, 3, 4]
   *
   * _.range(0, 20, 5);
   * // =&gt; [0, 5, 10, 15]
   *
   * _.range(0, -4, -1);
   * // =&gt; [0, -1, -2, -3]
   *
   * _.range(1, 4, 0);
   * // =&gt; [1, 1, 1]
   *
   * _.range(0);
   * // =&gt; []
   */
  function range(start, end, step) {
    start = +start || 0;
    step =  (+step || 1);

    if (end == null) {
      end = start;
      start = 0;
    }
    // use `Array(length)` so engines like Chakra and V8 avoid slower modes
    // http://youtu.be/XAqIpGU8ZZk#t=17m25s
    var index = -1,
        length = nativeMax(0, ceil((end - start) / step)),
        result = Array(length);

    while (++index &lt; length) {
      result[index] = start;
      start += step;
    }
    return result;
  }

  /**
   * The opposite of `_.initial` this method gets all but the first element or
   * first `n` elements of an array. If a callback function is provided elements
   * at the beginning of the array are excluded from the result as long as the
   * callback returns truey. The callback is bound to `thisArg` and invoked
   * with three arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias drop, tail
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Function|Object|number|string} [callback=1] The function called
   *  per element or the number of elements to exclude. If a property name or
   *  object is provided it will be used to create a &quot;_.pluck&quot; or &quot;_.where&quot;
   *  style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a slice of `array`.
   * @example
   *
   * _.rest([1, 2, 3]);
   * // =&gt; [2, 3]
   *
   * _.rest([1, 2, 3], 2);
   * // =&gt; [3]
   *
   * _.rest([1, 2, 3], function(num) {
   *   return num &lt; 3;
   * });
   * // =&gt; [3]
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;,  &#039;blocked&#039;: true,  &#039;employer&#039;: &#039;slate&#039; },
   *   { &#039;name&#039;: &#039;fred&#039;,    &#039;blocked&#039;: false,  &#039;employer&#039;: &#039;slate&#039; },
   *   { &#039;name&#039;: &#039;pebbles&#039;, &#039;blocked&#039;: true, &#039;employer&#039;: &#039;na&#039; }
   * ];
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.pluck(_.rest(characters, &#039;blocked&#039;), &#039;name&#039;);
   * // =&gt; [&#039;fred&#039;, &#039;pebbles&#039;]
   *
   * // using &quot;_.where&quot; callback shorthand
   * _.rest(characters, { &#039;employer&#039;: &#039;slate&#039; });
   * // =&gt; [{ &#039;name&#039;: &#039;pebbles&#039;, &#039;blocked&#039;: true, &#039;employer&#039;: &#039;na&#039; }]
   */
  function rest(array, callback, thisArg) {
    if (typeof callback != &#039;number&#039; &amp;&amp; callback != null) {
      var n = 0,
          index = -1,
          length = array ? array.length : 0;

      callback = createCallback(callback, thisArg, 3);
      while (++index &lt; length &amp;&amp; callback(array[index], index, array)) {
        n++;
      }
    } else {
      n = (callback == null || thisArg) ? 1 : nativeMax(0, callback);
    }
    return slice(array, n);
  }

  /**
   * Uses a binary search to determine the smallest index at which a value
   * should be inserted into a given sorted array in order to maintain the sort
   * order of the array. If a callback is provided it will be executed for
   * `value` and each element of `array` to compute their sort ranking. The
   * callback is bound to `thisArg` and invoked with one argument; (value).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to inspect.
   * @param {*} value The value to evaluate.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {number} Returns the index at which `value` should be inserted
   *  into `array`.
   * @example
   *
   * _.sortedIndex([20, 30, 50], 40);
   * // =&gt; 2
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.sortedIndex([{ &#039;x&#039;: 20 }, { &#039;x&#039;: 30 }, { &#039;x&#039;: 50 }], { &#039;x&#039;: 40 }, &#039;x&#039;);
   * // =&gt; 2
   *
   * var dict = {
   *   &#039;wordToNumber&#039;: { &#039;twenty&#039;: 20, &#039;thirty&#039;: 30, &#039;fourty&#039;: 40, &#039;fifty&#039;: 50 }
   * };
   *
   * _.sortedIndex([&#039;twenty&#039;, &#039;thirty&#039;, &#039;fifty&#039;], &#039;fourty&#039;, function(word) {
   *   return dict.wordToNumber[word];
   * });
   * // =&gt; 2
   *
   * _.sortedIndex([&#039;twenty&#039;, &#039;thirty&#039;, &#039;fifty&#039;], &#039;fourty&#039;, function(word) {
   *   return this.wordToNumber[word];
   * }, dict);
   * // =&gt; 2
   */
  function sortedIndex(array, value, callback, thisArg) {
    var low = 0,
        high = array ? array.length : low;

    // explicitly reference `identity` for better inlining in Firefox
    callback = callback ? createCallback(callback, thisArg, 1) : identity;
    value = callback(value);

    while (low &lt; high) {
      var mid = (low + high) &gt;&gt;&gt; 1;
      (callback(array[mid]) &lt; value)
        ? low = mid + 1
        : high = mid;
    }
    return low;
  }

  /**
   * Creates an array of unique values, in order, of the provided arrays using
   * strict equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {...Array} [array] The arrays to inspect.
   * @returns {Array} Returns an array of combined values.
   * @example
   *
   * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
   * // =&gt; [1, 2, 3, 5, 4]
   */
  function union() {
    return baseUniq(baseFlatten(arguments, true, true));
  }

  /**
   * Creates a duplicate-value-free version of an array using strict equality
   * for comparisons, i.e. `===`. If the array is sorted, providing
   * `true` for `isSorted` will use a faster algorithm. If a callback is provided
   * each element of `array` is passed through the callback before uniqueness
   * is computed. The callback is bound to `thisArg` and invoked with three
   * arguments; (value, index, array).
   *
   * If a property name is provided for `callback` the created &quot;_.pluck&quot; style
   * callback will return the property value of the given element.
   *
   * If an object is provided for `callback` the created &quot;_.where&quot; style callback
   * will return `true` for elements that have the properties of the given object,
   * else `false`.
   *
   * @static
   * @memberOf _
   * @alias unique
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
   * @param {Function|Object|string} [callback=identity] The function called
   *  per iteration. If a property name or object is provided it will be used
   *  to create a &quot;_.pluck&quot; or &quot;_.where&quot; style callback, respectively.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a duplicate-value-free array.
   * @example
   *
   * _.uniq([1, 2, 1, 3, 1]);
   * // =&gt; [1, 2, 3]
   *
   * _.uniq([1, 1, 2, 2, 3], true);
   * // =&gt; [1, 2, 3]
   *
   * _.uniq([&#039;A&#039;, &#039;b&#039;, &#039;C&#039;, &#039;a&#039;, &#039;B&#039;, &#039;c&#039;], function(letter) { return letter.toLowerCase(); });
   * // =&gt; [&#039;A&#039;, &#039;b&#039;, &#039;C&#039;]
   *
   * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
   * // =&gt; [1, 2.5, 3]
   *
   * // using &quot;_.pluck&quot; callback shorthand
   * _.uniq([{ &#039;x&#039;: 1 }, { &#039;x&#039;: 2 }, { &#039;x&#039;: 1 }], &#039;x&#039;);
   * // =&gt; [{ &#039;x&#039;: 1 }, { &#039;x&#039;: 2 }]
   */
  function uniq(array, isSorted, callback, thisArg) {
    // juggle arguments
    if (typeof isSorted != &#039;boolean&#039; &amp;&amp; isSorted != null) {
      thisArg = callback;
      callback = (typeof isSorted != &#039;function&#039; &amp;&amp; thisArg &amp;&amp; thisArg[isSorted] === array) ? null : isSorted;
      isSorted = false;
    }
    if (callback != null) {
      callback = createCallback(callback, thisArg, 3);
    }
    return baseUniq(array, isSorted, callback);
  }

  /**
   * Creates an array excluding all provided values using strict equality for
   * comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to filter.
   * @param {...*} [value] The values to exclude.
   * @returns {Array} Returns a new array of filtered values.
   * @example
   *
   * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
   * // =&gt; [2, 3, 4]
   */
  function without(array) {
    return baseDifference(array, slice(arguments, 1));
  }

  /**
   * Creates an array of grouped elements, the first of which contains the first
   * elements of the given arrays, the second of which contains the second
   * elements of the given arrays, and so on.
   *
   * @static
   * @memberOf _
   * @alias unzip
   * @category Arrays
   * @param {...Array} [array] Arrays to process.
   * @returns {Array} Returns a new array of grouped elements.
   * @example
   *
   * _.zip([&#039;fred&#039;, &#039;barney&#039;], [30, 40], [true, false]);
   * // =&gt; [[&#039;fred&#039;, 30, true], [&#039;barney&#039;, 40, false]]
   */
  function zip() {
    var index = -1,
        length = max(pluck(arguments, &#039;length&#039;)),
        result = Array(length &lt; 0 ? 0 : length);

    while (++index &lt; length) {
      result[index] = pluck(arguments, index);
    }
    return result;
  }

  /**
   * Creates an object composed from arrays of `keys` and `values`. Provide
   * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
   * or two arrays, one of `keys` and one of corresponding `values`.
   *
   * @static
   * @memberOf _
   * @alias object
   * @category Arrays
   * @param {Array} keys The array of keys.
   * @param {Array} [values=[]] The array of values.
   * @returns {Object} Returns an object composed of the given keys and
   *  corresponding values.
   * @example
   *
   * _.zipObject([&#039;fred&#039;, &#039;barney&#039;], [30, 40]);
   * // =&gt; { &#039;fred&#039;: 30, &#039;barney&#039;: 40 }
   */
  function zipObject(keys, values) {
    var index = -1,
        length = keys ? keys.length : 0,
        result = {};

    if (!values &amp;&amp; length &amp;&amp; !isArray(keys[0])) {
      values = [];
    }
    while (++index &lt; length) {
      var key = keys[index];
      if (values) {
        result[key] = values[index];
      } else if (key) {
        result[key[0]] = key[1];
      }
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function that executes `func`, with  the `this` binding and
   * arguments of the created function, only after being called `n` times.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {number} n The number of times the function must be called before
   *  `func` is executed.
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var saves = [&#039;profile&#039;, &#039;settings&#039;];
   *
   * var done = _.after(saves.length, function() {
   *   console.log(&#039;Done saving!&#039;);
   * });
   *
   * _.forEach(saves, function(type) {
   *   asyncSave({ &#039;type&#039;: type, &#039;complete&#039;: done });
   * });
   * // =&gt; logs &#039;Done saving!&#039;, after all saves have completed
   */
  function after(n, func) {
    if (!isFunction(func)) {
      throw new TypeError;
    }
    return function() {
      if (--n &lt; 1) {
        return func.apply(this, arguments);
      }
    };
  }

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any additional `bind` arguments to those
   * provided to the bound function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to bind.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {...*} [arg] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var func = function(greeting) {
   *   return greeting + &#039; &#039; + this.name;
   * };
   *
   * func = _.bind(func, { &#039;name&#039;: &#039;fred&#039; }, &#039;hi&#039;);
   * func();
   * // =&gt; &#039;hi fred&#039;
   */
  function bind(func, thisArg) {
    return arguments.length &gt; 2
      ? createWrapper(func, 17, slice(arguments, 2), null, thisArg)
      : createWrapper(func, 1, null, null, thisArg);
  }

  /**
   * Binds methods of an object to the object itself, overwriting the existing
   * method. Method names may be specified as individual arguments or as arrays
   * of method names. If no method names are provided all the function properties
   * of `object` will be bound.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Object} object The object to bind and assign the bound methods to.
   * @param {...string} [methodName] The object method names to
   *  bind, specified as individual method names or arrays of method names.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var view = {
   *   &#039;label&#039;: &#039;docs&#039;,
   *   &#039;onClick&#039;: function() { console.log(&#039;clicked &#039; + this.label); }
   * };
   *
   * _.bindAll(view);
   * jQuery(&#039;#docs&#039;).on(&#039;click&#039;, view.onClick);
   * // =&gt; logs &#039;clicked docs&#039;, when the button is clicked
   */
  function bindAll(object) {
    var funcs = arguments.length &gt; 1 ? baseFlatten(arguments, true, false, 1) : functions(object),
        index = -1,
        length = funcs.length;

    while (++index &lt; length) {
      var key = funcs[index];
      object[key] = createWrapper(object[key], 1, null, null, object);
    }
    return object;
  }

  /**
   * Creates a function that is the composition of the provided functions,
   * where each function consumes the return value of the function that follows.
   * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
   * Each function is executed with the `this` binding of the composed function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {...Function} [func] Functions to compose.
   * @returns {Function} Returns the new composed function.
   * @example
   *
   * var realNameMap = {
   *   &#039;pebbles&#039;: &#039;penelope&#039;
   * };
   *
   * var format = function(name) {
   *   name = realNameMap[name.toLowerCase()] || name;
   *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
   * };
   *
   * var greet = function(formatted) {
   *   return &#039;Hiya &#039; + formatted + &#039;!&#039;;
   * };
   *
   * var welcome = _.compose(greet, format);
   * welcome(&#039;pebbles&#039;);
   * // =&gt; &#039;Hiya Penelope!&#039;
   */
  function compose() {
    var funcs = arguments,
        length = funcs.length;

    while (length--) {
      if (!isFunction(funcs[length])) {
        throw new TypeError;
      }
    }
    return function() {
      var args = arguments,
          length = funcs.length;

      while (length--) {
        args = [funcs[length].apply(this, args)];
      }
      return args[0];
    };
  }

  /**
   * Creates a function that will delay the execution of `func` until after
   * `wait` milliseconds have elapsed since the last time it was invoked.
   * Provide an options object to indicate that `func` should be invoked on
   * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
   * to the debounced function will return the result of the last `func` call.
   *
   * Note: If `leading` and `trailing` options are `true` `func` will be called
   * on the trailing edge of the timeout only if the the debounced function is
   * invoked more than once during the `wait` timeout.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to debounce.
   * @param {number} wait The number of milliseconds to delay.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
   * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it&#039;s called.
   * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * // avoid costly calculations while the window size is in flux
   * var lazyLayout = _.debounce(calculateLayout, 150);
   * jQuery(window).on(&#039;resize&#039;, lazyLayout);
   *
   * // execute `sendMail` when the click event is fired, debouncing subsequent calls
   * jQuery(&#039;#postbox&#039;).on(&#039;click&#039;, _.debounce(sendMail, 300, {
   *   &#039;leading&#039;: true,
   *   &#039;trailing&#039;: false
   * });
   *
   * // ensure `batchLog` is executed once after 1 second of debounced calls
   * var source = new EventSource(&#039;/stream&#039;);
   * source.addEventListener(&#039;message&#039;, _.debounce(batchLog, 250, {
   *   &#039;maxWait&#039;: 1000
   * }, false);
   */
  function debounce(func, wait, options) {
    var args,
        maxTimeoutId,
        result,
        stamp,
        thisArg,
        timeoutId,
        trailingCall,
        lastCalled = 0,
        maxWait = false,
        trailing = true;

    if (!isFunction(func)) {
      throw new TypeError;
    }
    wait = nativeMax(0, wait) || 0;
    if (options === true) {
      var leading = true;
      trailing = false;
    } else if (isObject(options)) {
      leading = options.leading;
      maxWait = &#039;maxWait&#039; in options &amp;&amp; (nativeMax(wait, options.maxWait) || 0);
      trailing = &#039;trailing&#039; in options ? options.trailing : trailing;
    }
    var delayed = function() {
      var remaining = wait - (now() - stamp);
      if (remaining &lt;= 0) {
        if (maxTimeoutId) {
          clearTimeout(maxTimeoutId);
        }
        var isCalled = trailingCall;
        maxTimeoutId = timeoutId = trailingCall = undefined;
        if (isCalled) {
          lastCalled = now();
          result = func.apply(thisArg, args);
          if (!timeoutId &amp;&amp; !maxTimeoutId) {
            args = thisArg = null;
          }
        }
      } else {
        timeoutId = setTimeout(delayed, remaining);
      }
    };

    var maxDelayed = function() {
      if (timeoutId) {
        clearTimeout(timeoutId);
      }
      maxTimeoutId = timeoutId = trailingCall = undefined;
      if (trailing || (maxWait !== wait)) {
        lastCalled = now();
        result = func.apply(thisArg, args);
        if (!timeoutId &amp;&amp; !maxTimeoutId) {
          args = thisArg = null;
        }
      }
    };

    return function() {
      args = arguments;
      stamp = now();
      thisArg = this;
      trailingCall = trailing &amp;&amp; (timeoutId || !leading);

      if (maxWait === false) {
        var leadingCall = leading &amp;&amp; !timeoutId;
      } else {
        if (!maxTimeoutId &amp;&amp; !leading) {
          lastCalled = stamp;
        }
        var remaining = maxWait - (stamp - lastCalled),
            isCalled = remaining &lt;= 0;

        if (isCalled) {
          if (maxTimeoutId) {
            maxTimeoutId = clearTimeout(maxTimeoutId);
          }
          lastCalled = stamp;
          result = func.apply(thisArg, args);
        }
        else if (!maxTimeoutId) {
          maxTimeoutId = setTimeout(maxDelayed, remaining);
        }
      }
      if (isCalled &amp;&amp; timeoutId) {
        timeoutId = clearTimeout(timeoutId);
      }
      else if (!timeoutId &amp;&amp; wait !== maxWait) {
        timeoutId = setTimeout(delayed, wait);
      }
      if (leadingCall) {
        isCalled = true;
        result = func.apply(thisArg, args);
      }
      if (isCalled &amp;&amp; !timeoutId &amp;&amp; !maxTimeoutId) {
        args = thisArg = null;
      }
      return result;
    };
  }

  /**
   * Defers executing the `func` function until the current call stack has cleared.
   * Additional arguments will be provided to `func` when it is invoked.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to defer.
   * @param {...*} [arg] Arguments to invoke the function with.
   * @returns {number} Returns the timer id.
   * @example
   *
   * _.defer(function(text) { console.log(text); }, &#039;deferred&#039;);
   * // logs &#039;deferred&#039; after one or more milliseconds
   */
  function defer(func) {
    if (!isFunction(func)) {
      throw new TypeError;
    }
    var args = slice(arguments, 1);
    return setTimeout(function() { func.apply(undefined, args); }, 1);
  }

  /**
   * Executes the `func` function after `wait` milliseconds. Additional arguments
   * will be provided to `func` when it is invoked.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to delay.
   * @param {number} wait The number of milliseconds to delay execution.
   * @param {...*} [arg] Arguments to invoke the function with.
   * @returns {number} Returns the timer id.
   * @example
   *
   * _.delay(function(text) { console.log(text); }, 1000, &#039;later&#039;);
   * // =&gt; logs &#039;later&#039; after one second
   */
  function delay(func, wait) {
    if (!isFunction(func)) {
      throw new TypeError;
    }
    var args = slice(arguments, 2);
    return setTimeout(function() { func.apply(undefined, args); }, wait);
  }

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * provided it will be used to determine the cache key for storing the result
   * based on the arguments provided to the memoized function. By default, the
   * first argument provided to the memoized function is used as the cache key.
   * The `func` is executed with the `this` binding of the memoized function.
   * The result cache is exposed as the `cache` property on the memoized function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] A function used to resolve the cache key.
   * @returns {Function} Returns the new memoizing function.
   * @example
   *
   * var fibonacci = _.memoize(function(n) {
   *   return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
   * });
   *
   * fibonacci(9)
   * // =&gt; 34
   *
   * var data = {
   *   &#039;fred&#039;: { &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40 },
   *   &#039;pebbles&#039;: { &#039;name&#039;: &#039;pebbles&#039;, &#039;age&#039;: 1 }
   * };
   *
   * // modifying the result cache
   * var get = _.memoize(function(name) { return data[name]; }, _.identity);
   * get(&#039;pebbles&#039;);
   * // =&gt; { &#039;name&#039;: &#039;pebbles&#039;, &#039;age&#039;: 1 }
   *
   * get.cache.pebbles.name = &#039;penelope&#039;;
   * get(&#039;pebbles&#039;);
   * // =&gt; { &#039;name&#039;: &#039;penelope&#039;, &#039;age&#039;: 1 }
   */
  function memoize(func, resolver) {
    var cache = {};
    return function() {
      var key = resolver ? resolver.apply(this, arguments) : keyPrefix + arguments[0];
      return hasOwnProperty.call(cache, key)
        ? cache[key]
        : (cache[key] = func.apply(this, arguments));
    };
  }

  /**
   * Creates a function that is restricted to execute `func` once. Repeat calls to
   * the function will return the value of the first call. The `func` is executed
   * with the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var initialize = _.once(createApplication);
   * initialize();
   * initialize();
   * // `initialize` executes `createApplication` once
   */
  function once(func) {
    var ran,
        result;

    if (!isFunction(func)) {
      throw new TypeError;
    }
    return function() {
      if (ran) {
        return result;
      }
      ran = true;
      result = func.apply(this, arguments);

      // clear the `func` variable so the function may be garbage collected
      func = null;
      return result;
    };
  }

  /**
   * Creates a function that, when called, invokes `func` with any additional
   * `partial` arguments prepended to those provided to the new function. This
   * method is similar to `_.bind` except it does **not** alter the `this` binding.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to partially apply arguments to.
   * @param {...*} [arg] Arguments to be partially applied.
   * @returns {Function} Returns the new partially applied function.
   * @example
   *
   * var greet = function(greeting, name) { return greeting + &#039; &#039; + name; };
   * var hi = _.partial(greet, &#039;hi&#039;);
   * hi(&#039;fred&#039;);
   * // =&gt; &#039;hi fred&#039;
   */
  function partial(func) {
    return createWrapper(func, 16, slice(arguments, 1));
  }

  /**
   * Creates a function that, when executed, will only call the `func` function
   * at most once per every `wait` milliseconds. Provide an options object to
   * indicate that `func` should be invoked on the leading and/or trailing edge
   * of the `wait` timeout. Subsequent calls to the throttled function will
   * return the result of the last `func` call.
   *
   * Note: If `leading` and `trailing` options are `true` `func` will be called
   * on the trailing edge of the timeout only if the the throttled function is
   * invoked more than once during the `wait` timeout.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to throttle.
   * @param {number} wait The number of milliseconds to throttle executions to.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
   * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * // avoid excessively updating the position while scrolling
   * var throttled = _.throttle(updatePosition, 100);
   * jQuery(window).on(&#039;scroll&#039;, throttled);
   *
   * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
   * jQuery(&#039;.interactive&#039;).on(&#039;click&#039;, _.throttle(renewToken, 300000, {
   *   &#039;trailing&#039;: false
   * }));
   */
  function throttle(func, wait, options) {
    var leading = true,
        trailing = true;

    if (!isFunction(func)) {
      throw new TypeError;
    }
    if (options === false) {
      leading = false;
    } else if (isObject(options)) {
      leading = &#039;leading&#039; in options ? options.leading : leading;
      trailing = &#039;trailing&#039; in options ? options.trailing : trailing;
    }
    options = {};
    options.leading = leading;
    options.maxWait = wait;
    options.trailing = trailing;

    return debounce(func, wait, options);
  }

  /**
   * Creates a function that provides `value` to the wrapper function as its
   * first argument. Additional arguments provided to the function are appended
   * to those provided to the wrapper function. The wrapper is executed with
   * the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {*} value The value to wrap.
   * @param {Function} wrapper The wrapper function.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var p = _.wrap(_.escape, function(func, text) {
   *   return &#039;&lt;p&gt;&#039; + func(text) + &#039;&lt;/p&gt;&#039;;
   * });
   *
   * p(&#039;Fred, Wilma, &amp; Pebbles&#039;);
   * // =&gt; &#039;&lt;p&gt;Fred, Wilma, &amp;amp; Pebbles&lt;/p&gt;&#039;
   */
  function wrap(value, wrapper) {
    return createWrapper(wrapper, 16, [value]);
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Produces a callback bound to an optional `thisArg`. If `func` is a property
   * name the created callback will return the property value for a given element.
   * If `func` is an object the created callback will return `true` for elements
   * that contain the equivalent object properties, otherwise it will return `false`.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} [func=identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of the created callback.
   * @param {number} [argCount] The number of arguments the callback accepts.
   * @returns {Function} Returns a callback function.
   * @example
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 }
   * ];
   *
   * // wrap to create custom callback shorthands
   * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
   *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
   *   return !match ? func(callback, thisArg) : function(object) {
   *     return match[2] == &#039;gt&#039; ? object[match[1]] &gt; match[3] : object[match[1]] &lt; match[3];
   *   };
   * });
   *
   * _.filter(characters, &#039;age__gt38&#039;);
   * // =&gt; [{ &#039;name&#039;: &#039;fred&#039;, &#039;age&#039;: 40 }]
   */
  function createCallback(func, thisArg, argCount) {
    var type = typeof func;
    if (func == null || type == &#039;function&#039;) {
      return baseCreateCallback(func, thisArg, argCount);
    }
    // handle &quot;_.pluck&quot; style callback shorthands
    if (type != &#039;object&#039;) {
      return property(func);
    }
    var props = keys(func);
    return function(object) {
      var length = props.length,
          result = false;

      while (length--) {
        if (!(result = object[props[length]] === func[props[length]])) {
          break;
        }
      }
      return result;
    };
  }

  /**
   * Converts the characters `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#039;` in `string` to their
   * corresponding HTML entities.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} string The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escape(&#039;Fred, Wilma, &amp; Pebbles&#039;);
   * // =&gt; &#039;Fred, Wilma, &amp;amp; Pebbles&#039;
   */
  function escape(string) {
    return string == null ? &#039;&#039; : String(string).replace(reUnescapedHtml, escapeHtmlChar);
  }

  /**
   * This method returns the first argument provided to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { &#039;name&#039;: &#039;fred&#039; };
   * _.identity(object) === object;
   * // =&gt; true
   */
  function identity(value) {
    return value;
  }

  /**
   * Adds function properties of a source object to the destination object.
   * If `object` is a function methods will be added to its prototype as well.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Function|Object} [object=lodash] object The destination object.
   * @param {Object} source The object of functions to add.
   * @param {Object} [options] The options object.
   * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
   * @example
   *
   * function capitalize(string) {
   *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
   * }
   *
   * _.mixin({ &#039;capitalize&#039;: capitalize });
   * _.capitalize(&#039;fred&#039;);
   * // =&gt; &#039;Fred&#039;
   *
   * _(&#039;fred&#039;).capitalize().value();
   * // =&gt; &#039;Fred&#039;
   *
   * _.mixin({ &#039;capitalize&#039;: capitalize }, { &#039;chain&#039;: false });
   * _(&#039;fred&#039;).capitalize();
   * // =&gt; &#039;Fred&#039;
   */
  function mixin(object) {
    forEach(functions(object), function(methodName) {
      var func = lodash[methodName] = object[methodName];

      lodash.prototype[methodName] = function() {
        var args = [this.__wrapped__];
        push.apply(args, arguments);

        var result = func.apply(lodash, args);
        return this.__chain__
          ? new lodashWrapper(result, true)
          : result;
      };
    });
  }

  /**
   * Reverts the &#039;_&#039; variable to its previous value and returns a reference to
   * the `lodash` function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @returns {Function} Returns the `lodash` function.
   * @example
   *
   * var lodash = _.noConflict();
   */
  function noConflict() {
    root._ = oldDash;
    return this;
  }

  /**
   * A no-operation function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var object = { &#039;name&#039;: &#039;fred&#039; };
   * _.noop(object) === undefined;
   * // =&gt; true
   */
  function noop() {
    // no operation performed
  }

  /**
   * Gets the number of milliseconds that have elapsed since the Unix epoch
   * (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @example
   *
   * var stamp = _.now();
   * _.defer(function() { console.log(_.now() - stamp); });
   * // =&gt; logs the number of milliseconds it took for the deferred function to be called
   */
  var now = isNative(now = Date.now) &amp;&amp; now || function() {
    return new Date().getTime();
  };

  /**
   * Creates a &quot;_.pluck&quot; style function, which returns the `key` value of a
   * given object.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} key The name of the property to retrieve.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 },
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 }
   * ];
   *
   * var getName = _.property(&#039;name&#039;);
   *
   * _.map(characters, getName);
   * // =&gt; [&#039;barney&#039;, &#039;fred&#039;]
   *
   * _.sortBy(characters, getName);
   * // =&gt; [{ &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 }, { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 }]
   */
  function property(key) {
    return function(object) {
      return object[key];
    };
  }

  /**
   * Produces a random number between `min` and `max` (inclusive). If only one
   * argument is provided a number between `0` and the given number will be
   * returned. If `floating` is truey or either `min` or `max` are floats a
   * floating-point number will be returned instead of an integer.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {number} [min=0] The minimum possible value.
   * @param {number} [max=1] The maximum possible value.
   * @param {boolean} [floating=false] Specify returning a floating-point number.
   * @returns {number} Returns a random number.
   * @example
   *
   * _.random(0, 5);
   * // =&gt; an integer between 0 and 5
   *
   * _.random(5);
   * // =&gt; also an integer between 0 and 5
   *
   * _.random(5, true);
   * // =&gt; a floating-point number between 0 and 5
   *
   * _.random(1.2, 5.2);
   * // =&gt; a floating-point number between 1.2 and 5.2
   */
  function random(min, max) {
    if (min == null &amp;&amp; max == null) {
      max = 1;
    }
    min = +min || 0;
    if (max == null) {
      max = min;
      min = 0;
    } else {
      max = +max || 0;
    }
    return min + floor(nativeRandom() * (max - min + 1));
  }

  /**
   * Resolves the value of property `key` on `object`. If `key` is a function
   * it will be invoked with the `this` binding of `object` and its result returned,
   * else the property value is returned. If `object` is falsey then `undefined`
   * is returned.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} object The object to inspect.
   * @param {string} key The name of the property to resolve.
   * @returns {*} Returns the resolved value.
   * @example
   *
   * var object = {
   *   &#039;cheese&#039;: &#039;crumpets&#039;,
   *   &#039;stuff&#039;: function() {
   *     return &#039;nonsense&#039;;
   *   }
   * };
   *
   * _.result(object, &#039;cheese&#039;);
   * // =&gt; &#039;crumpets&#039;
   *
   * _.result(object, &#039;stuff&#039;);
   * // =&gt; &#039;nonsense&#039;
   */
  function result(object, key) {
    if (object) {
      var value = object[key];
      return isFunction(value) ? object[key]() : value;
    }
  }

  /**
   * A micro-templating method that handles arbitrary delimiters, preserves
   * whitespace, and correctly escapes quotes within interpolated code.
   *
   * Note: In the development build, `_.template` utilizes sourceURLs for easier
   * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
   *
   * For more information on precompiling templates see:
   * https://lodash.com/custom-builds
   *
   * For more information on Chrome extension sandboxes see:
   * http://developer.chrome.com/stable/extensions/sandboxingEval.html
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} text The template text.
   * @param {Object} data The data object used to populate the text.
   * @param {Object} [options] The options object.
   * @param {RegExp} [options.escape] The &quot;escape&quot; delimiter.
   * @param {RegExp} [options.evaluate] The &quot;evaluate&quot; delimiter.
   * @param {Object} [options.imports] An object to import into the template as local variables.
   * @param {RegExp} [options.interpolate] The &quot;interpolate&quot; delimiter.
   * @param {string} [sourceURL] The sourceURL of the template&#039;s compiled source.
   * @param {string} [variable] The data object variable name.
   * @returns {Function|string} Returns a compiled function when no `data` object
   *  is given, else it returns the interpolated text.
   * @example
   *
   * // using the &quot;interpolate&quot; delimiter to create a compiled template
   * var compiled = _.template(&#039;hello &lt;%= name %&gt;&#039;);
   * compiled({ &#039;name&#039;: &#039;fred&#039; });
   * // =&gt; &#039;hello fred&#039;
   *
   * // using the &quot;escape&quot; delimiter to escape HTML in data property values
   * _.template(&#039;&lt;b&gt;&lt;%- value %&gt;&lt;/b&gt;&#039;, { &#039;value&#039;: &#039;&lt;script&gt;&#039; });
   * // =&gt; &#039;&lt;b&gt;&amp;lt;script&amp;gt;&lt;/b&gt;&#039;
   *
   * // using the &quot;evaluate&quot; delimiter to generate HTML
   * var list = &#039;&lt;% _.forEach(people, function(name) { %&gt;&lt;li&gt;&lt;%- name %&gt;&lt;/li&gt;&lt;% }); %&gt;&#039;;
   * _.template(list, { &#039;people&#039;: [&#039;fred&#039;, &#039;barney&#039;] });
   * // =&gt; &#039;&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;&#039;
   *
   * // using the ES6 delimiter as an alternative to the default &quot;interpolate&quot; delimiter
   * _.template(&#039;hello ${ name }&#039;, { &#039;name&#039;: &#039;pebbles&#039; });
   * // =&gt; &#039;hello pebbles&#039;
   *
   * // using the internal `print` function in &quot;evaluate&quot; delimiters
   * _.template(&#039;&lt;% print(&quot;hello &quot; + name); %&gt;!&#039;, { &#039;name&#039;: &#039;barney&#039; });
   * // =&gt; &#039;hello barney!&#039;
   *
   * // using a custom template delimiters
   * _.templateSettings = {
   *   &#039;interpolate&#039;: /{{([\s\S]+?)}}/g
   * };
   *
   * _.template(&#039;hello {{ name }}!&#039;, { &#039;name&#039;: &#039;mustache&#039; });
   * // =&gt; &#039;hello mustache!&#039;
   *
   * // using the `imports` option to import jQuery
   * var list = &#039;&lt;% jq.each(people, function(name) { %&gt;&lt;li&gt;&lt;%- name %&gt;&lt;/li&gt;&lt;% }); %&gt;&#039;;
   * _.template(list, { &#039;people&#039;: [&#039;fred&#039;, &#039;barney&#039;] }, { &#039;imports&#039;: { &#039;jq&#039;: jQuery } });
   * // =&gt; &#039;&lt;li&gt;fred&lt;/li&gt;&lt;li&gt;barney&lt;/li&gt;&#039;
   *
   * // using the `sourceURL` option to specify a custom sourceURL for the template
   * var compiled = _.template(&#039;hello &lt;%= name %&gt;&#039;, null, { &#039;sourceURL&#039;: &#039;/basic/greeting.jst&#039; });
   * compiled(data);
   * // =&gt; find the source of &quot;greeting.jst&quot; under the Sources tab or Resources panel of the web inspector
   *
   * // using the `variable` option to ensure a with-statement isn&#039;t used in the compiled template
   * var compiled = _.template(&#039;hi &lt;%= data.name %&gt;!&#039;, null, { &#039;variable&#039;: &#039;data&#039; });
   * compiled.source;
   * // =&gt; function(data) {
   *   var __t, __p = &#039;&#039;, __e = _.escape;
   *   __p += &#039;hi &#039; + ((__t = ( data.name )) == null ? &#039;&#039; : __t) + &#039;!&#039;;
   *   return __p;
   * }
   *
   * // using the `source` property to inline compiled templates for meaningful
   * // line numbers in error messages and a stack trace
   * fs.writeFileSync(path.join(cwd, &#039;jst.js&#039;), &#039;\
   *   var JST = {\
   *     &quot;main&quot;: &#039; + _.template(mainText).source + &#039;\
   *   };\
   * &#039;);
   */
  function template(text, data, options) {
    var _ = lodash,
        settings = _.templateSettings;

    text = String(text || &#039;&#039;);
    options = defaults({}, options, settings);

    var index = 0,
        source = &quot;__p += &#039;&quot;,
        variable = options.variable;

    var reDelimiters = RegExp(
      (options.escape || reNoMatch).source + &#039;|&#039; +
      (options.interpolate || reNoMatch).source + &#039;|&#039; +
      (options.evaluate || reNoMatch).source + &#039;|$&#039;
    , &#039;g&#039;);

    text.replace(reDelimiters, function(match, escapeValue, interpolateValue, evaluateValue, offset) {
      source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);
      if (escapeValue) {
        source += &quot;&#039; +\n_.escape(&quot; + escapeValue + &quot;) +\n&#039;&quot;;
      }
      if (evaluateValue) {
        source += &quot;&#039;;\n&quot; + evaluateValue + &quot;;\n__p += &#039;&quot;;
      }
      if (interpolateValue) {
        source += &quot;&#039; +\n((__t = (&quot; + interpolateValue + &quot;)) == null ? &#039;&#039; : __t) +\n&#039;&quot;;
      }
      index = offset + match.length;
      return match;
    });

    source += &quot;&#039;;\n&quot;;
    if (!variable) {
      variable = &#039;obj&#039;;
      source = &#039;with (&#039; + variable + &#039; || {}) {\n&#039; + source + &#039;\n}\n&#039;;
    }
    source = &#039;function(&#039; + variable + &#039;) {\n&#039; +
      &quot;var __t, __p = &#039;&#039;, __j = Array.prototype.join;\n&quot; +
      &quot;function print() { __p += __j.call(arguments, &#039;&#039;) }\n&quot; +
      source +
      &#039;return __p\n}&#039;;

    try {
      var result = Function(&#039;_&#039;, &#039;return &#039; + source)(_);
    } catch(e) {
      e.source = source;
      throw e;
    }
    if (data) {
      return result(data);
    }
    result.source = source;
    return result;
  }

  /**
   * Executes the callback `n` times, returning an array of the results
   * of each callback execution. The callback is bound to `thisArg` and invoked
   * with one argument; (index).
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {number} n The number of times to execute the callback.
   * @param {Function} callback The function called per iteration.
   * @param {*} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns an array of the results of each `callback` execution.
   * @example
   *
   * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
   * // =&gt; [3, 6, 4]
   *
   * _.times(3, function(n) { mage.castSpell(n); });
   * // =&gt; calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
   *
   * _.times(3, function(n) { this.cast(n); }, mage);
   * // =&gt; also calls `mage.castSpell(n)` three times
   */
  function times(n, callback, thisArg) {
    n = (n = +n) &gt; -1 ? n : 0;
    var index = -1,
        result = Array(n);

    callback = baseCreateCallback(callback, thisArg, 1);
    while (++index &lt; n) {
      result[index] = callback(index);
    }
    return result;
  }

  /**
   * The inverse of `_.escape` this method converts the HTML entities
   * `&amp;amp;`, `&amp;lt;`, `&amp;gt;`, `&amp;quot;`, and `&amp;#39;` in `string` to their
   * corresponding characters.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} string The string to unescape.
   * @returns {string} Returns the unescaped string.
   * @example
   *
   * _.unescape(&#039;Fred, Barney &amp;amp; Pebbles&#039;);
   * // =&gt; &#039;Fred, Barney &amp; Pebbles&#039;
   */
  function unescape(string) {
    return string == null ? &#039;&#039; : String(string).replace(reEscapedHtml, unescapeHtmlChar);
  }

  /**
   * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {string} [prefix] The value to prefix the ID with.
   * @returns {string} Returns the unique ID.
   * @example
   *
   * _.uniqueId(&#039;contact_&#039;);
   * // =&gt; &#039;contact_104&#039;
   *
   * _.uniqueId();
   * // =&gt; &#039;105&#039;
   */
  function uniqueId(prefix) {
    var id = ++idCounter + &#039;&#039;;
    return prefix ? prefix + id : id;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object that wraps the given value with explicit
   * method chaining enabled.
   *
   * @static
   * @memberOf _
   * @category Chaining
   * @param {*} value The value to wrap.
   * @returns {Object} Returns the wrapper object.
   * @example
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;,  &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,    &#039;age&#039;: 40 },
   *   { &#039;name&#039;: &#039;pebbles&#039;, &#039;age&#039;: 1 }
   * ];
   *
   * var youngest = _.chain(characters)
   *     .sortBy(&#039;age&#039;)
   *     .map(function(chr) { return chr.name + &#039; is &#039; + chr.age; })
   *     .first()
   *     .value();
   * // =&gt; &#039;pebbles is 1&#039;
   */
  function chain(value) {
    value = new lodashWrapper(value);
    value.__chain__ = true;
    return value;
  }

  /**
   * Invokes `interceptor` with the `value` as the first argument and then
   * returns `value`. The purpose of this method is to &quot;tap into&quot; a method
   * chain in order to perform operations on intermediate results within
   * the chain.
   *
   * @static
   * @memberOf _
   * @category Chaining
   * @param {*} value The value to provide to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {*} Returns `value`.
   * @example
   *
   * _([1, 2, 3, 4])
   *  .tap(function(array) { array.pop(); })
   *  .reverse()
   *  .value();
   * // =&gt; [3, 2, 1]
   */
  function tap(value, interceptor) {
    interceptor(value);
    return value;
  }

  /**
   * Enables explicit method chaining on the wrapper object.
   *
   * @name chain
   * @memberOf _
   * @category Chaining
   * @returns {*} Returns the wrapper object.
   * @example
   *
   * var characters = [
   *   { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 },
   *   { &#039;name&#039;: &#039;fred&#039;,   &#039;age&#039;: 40 }
   * ];
   *
   * // without explicit chaining
   * _(characters).first();
   * // =&gt; { &#039;name&#039;: &#039;barney&#039;, &#039;age&#039;: 36 }
   *
   * // with explicit chaining
   * _(characters).chain()
   *   .first()
   *   .pick(&#039;age&#039;)
   *   .value();
   * // =&gt; { &#039;age&#039;: 36 }
   */
  function wrapperChain() {
    this.__chain__ = true;
    return this;
  }

  /**
   * Extracts the wrapped value.
   *
   * @name valueOf
   * @memberOf _
   * @alias value
   * @category Chaining
   * @returns {*} Returns the wrapped value.
   * @example
   *
   * _([1, 2, 3]).valueOf();
   * // =&gt; [1, 2, 3]
   */
  function wrapperValueOf() {
    return this.__wrapped__;
  }

  /*--------------------------------------------------------------------------*/

  // add functions that return wrapped values when chaining
  lodash.after = after;
  lodash.bind = bind;
  lodash.bindAll = bindAll;
  lodash.chain = chain;
  lodash.compact = compact;
  lodash.compose = compose;
  lodash.countBy = countBy;
  lodash.debounce = debounce;
  lodash.defaults = defaults;
  lodash.defer = defer;
  lodash.delay = delay;
  lodash.difference = difference;
  lodash.filter = filter;
  lodash.flatten = flatten;
  lodash.forEach = forEach;
  lodash.functions = functions;
  lodash.groupBy = groupBy;
  lodash.indexBy = indexBy;
  lodash.initial = initial;
  lodash.intersection = intersection;
  lodash.invert = invert;
  lodash.invoke = invoke;
  lodash.keys = keys;
  lodash.map = map;
  lodash.max = max;
  lodash.memoize = memoize;
  lodash.min = min;
  lodash.omit = omit;
  lodash.once = once;
  lodash.pairs = pairs;
  lodash.partial = partial;
  lodash.pick = pick;
  lodash.pluck = pluck;
  lodash.range = range;
  lodash.reject = reject;
  lodash.rest = rest;
  lodash.shuffle = shuffle;
  lodash.sortBy = sortBy;
  lodash.tap = tap;
  lodash.throttle = throttle;
  lodash.times = times;
  lodash.toArray = toArray;
  lodash.union = union;
  lodash.uniq = uniq;
  lodash.values = values;
  lodash.where = where;
  lodash.without = without;
  lodash.wrap = wrap;
  lodash.zip = zip;

  // add aliases
  lodash.collect = map;
  lodash.drop = rest;
  lodash.each = forEach;
  lodash.extend = assign;
  lodash.methods = functions;
  lodash.object = zipObject;
  lodash.select = filter;
  lodash.tail = rest;
  lodash.unique = uniq;

  /*--------------------------------------------------------------------------*/

  // add functions that return unwrapped values when chaining
  lodash.clone = clone;
  lodash.contains = contains;
  lodash.escape = escape;
  lodash.every = every;
  lodash.find = find;
  lodash.has = has;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isBoolean = isBoolean;
  lodash.isDate = isDate;
  lodash.isElement = isElement;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFinite = isFinite;
  lodash.isFunction = isFunction;
  lodash.isNaN = isNaN;
  lodash.isNull = isNull;
  lodash.isNumber = isNumber;
  lodash.isObject = isObject;
  lodash.isRegExp = isRegExp;
  lodash.isString = isString;
  lodash.isUndefined = isUndefined;
  lodash.lastIndexOf = lastIndexOf;
  lodash.mixin = mixin;
  lodash.noConflict = noConflict;
  lodash.random = random;
  lodash.reduce = reduce;
  lodash.reduceRight = reduceRight;
  lodash.result = result;
  lodash.size = size;
  lodash.some = some;
  lodash.sortedIndex = sortedIndex;
  lodash.template = template;
  lodash.unescape = unescape;
  lodash.uniqueId = uniqueId;

  // add aliases
  lodash.all = every;
  lodash.any = some;
  lodash.detect = find;
  lodash.findWhere = findWhere;
  lodash.foldl = reduce;
  lodash.foldr = reduceRight;
  lodash.include = contains;
  lodash.inject = reduce;

  /*--------------------------------------------------------------------------*/

  // add functions capable of returning wrapped and unwrapped values when chaining
  lodash.first = first;
  lodash.last = last;
  lodash.sample = sample;

  // add aliases
  lodash.take = first;
  lodash.head = first;

  /*--------------------------------------------------------------------------*/

  // add functions to `lodash.prototype`
  mixin(lodash);

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type string
   */
  lodash.VERSION = &#039;2.4.2&#039;;

  // add &quot;Chaining&quot; functions to the wrapper
  lodash.prototype.chain = wrapperChain;
  lodash.prototype.value = wrapperValueOf;

    // add `Array` mutator functions to the wrapper
    forEach([&#039;pop&#039;, &#039;push&#039;, &#039;reverse&#039;, &#039;shift&#039;, &#039;sort&#039;, &#039;splice&#039;, &#039;unshift&#039;], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__;
        func.apply(value, arguments);

        // avoid array-like object bugs with `Array#shift` and `Array#splice`
        // in Firefox &lt; 10 and IE &lt; 9
        if (!support.spliceObjects &amp;&amp; value.length === 0) {
          delete value[0];
        }
        return this;
      };
    });

    // add `Array` accessor functions to the wrapper
    forEach([&#039;concat&#039;, &#039;join&#039;, &#039;slice&#039;], function(methodName) {
      var func = arrayRef[methodName];
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            result = func.apply(value, arguments);

        if (this.__chain__) {
          result = new lodashWrapper(result);
          result.__chain__ = true;
        }
        return result;
      };
    });

  /*--------------------------------------------------------------------------*/

  // some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == &#039;function&#039; &amp;&amp; typeof define.amd == &#039;object&#039; &amp;&amp; define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash is loaded with a RequireJS shim config.
    // See http://requirejs.org/docs/api.html#config-shim
    root._ = lodash;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the &quot;underscore&quot; module
    define(function() {
      return lodash;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports &amp;&amp; freeModule) {
    // in Node.js or RingoJS
    if (moduleExports) {
      (freeModule.exports = lodash)._ = lodash;
    }
    // in Narwhal or Rhino -require
    else {
      freeExports._ = lodash;
    }
  }
  else {
    // in a browser or Rhino
    root._ = lodash;
  }
}.call(this));</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
