<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/findup-sync/node_modules/minimatch/minimatch.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/findup-sync/node_modules/minimatch/minimatch.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.38</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1061</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">109.19</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.75</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">;(function (require, exports, module, platform) {

if (module) module.exports = minimatch
else exports.minimatch = minimatch

if (!require) {
  require = function (id) {
    switch (id) {
      case &quot;sigmund&quot;: return function sigmund (obj) {
        return JSON.stringify(obj)
      }
      case &quot;path&quot;: return { basename: function (f) {
        f = f.split(/[\/\\]/)
        var e = f.pop()
        if (!e) e = f.pop()
        return e
      }}
      case &quot;lru-cache&quot;: return function LRUCache () {
        // not quite an LRU, but still space-limited.
        var cache = {}
        var cnt = 0
        this.set = function (k, v) {
          cnt ++
          if (cnt &gt;= 100) cache = {}
          cache[k] = v
        }
        this.get = function (k) { return cache[k] }
      }
    }
  }
}

minimatch.Minimatch = Minimatch

var LRU = require(&quot;lru-cache&quot;)
  , cache = minimatch.cache = new LRU({max: 100})
  , GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
  , sigmund = require(&quot;sigmund&quot;)

var path = require(&quot;path&quot;)
  // any single thing other than /
  // don&#039;t need to escape / when using new RegExp()
  , qmark = &quot;[^/]&quot;

  // * =&gt; any number of characters
  , star = qmark + &quot;*?&quot;

  // ** when dots are allowed.  Anything goes, except .. and .
  // not (^ or / followed by one or two dots followed by $ or /),
  // followed by anything, any number of times.
  , twoStarDot = &quot;(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?&quot;

  // not a ^ or / followed by a dot,
  // followed by anything, any number of times.
  , twoStarNoDot = &quot;(?:(?!(?:\\\/|^)\\.).)*?&quot;

  // characters that need to be escaped in RegExp.
  , reSpecials = charSet(&quot;().*{}+?[]^$\\!&quot;)

// &quot;abc&quot; -&gt; { a:true, b:true, c:true }
function charSet (s) {
  return s.split(&quot;&quot;).reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}


function minimatch (p, pattern, options) {
  if (typeof pattern !== &quot;string&quot;) {
    throw new TypeError(&quot;glob pattern string required&quot;)
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment &amp;&amp; pattern.charAt(0) === &quot;#&quot;) {
    return false
  }

  // &quot;&quot; only matches &quot;&quot;
  if (pattern.trim() === &quot;&quot;) return p === &quot;&quot;

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options, cache)
  }

  if (typeof pattern !== &quot;string&quot;) {
    throw new TypeError(&quot;glob pattern string required&quot;)
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows: need to use /, not \
  // On other platforms, \ is a valid (albeit bad) filename char.
  if (platform === &quot;win32&quot;) {
    pattern = pattern.split(&quot;\\&quot;).join(&quot;/&quot;)
  }

  // lru storage.
  // these things aren&#039;t particularly big, but walking down the string
  // and turning it into a regexp can get pretty costly.
  var cacheKey = pattern + &quot;\n&quot; + sigmund(options)
  var cached = minimatch.cache.get(cacheKey)
  if (cached) return cached
  minimatch.cache.set(cacheKey, this)

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function() {}

Minimatch.prototype.make = make
function make () {
  // don&#039;t do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment &amp;&amp; pattern.charAt(0) === &quot;#&quot;) {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of &quot;**&quot;, which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --&gt; regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn&#039;t compile properly.
  set = set.filter(function (s) {
    return -1 === s.indexOf(false)
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
    , negate = false
    , options = this.options
    , negateOffset = 0

  if (options.nonegate) return

  for ( var i = 0, l = pattern.length
      ; i &lt; l &amp;&amp; pattern.charAt(i) === &quot;!&quot;
      ; i ++) {
    negate = !negate
    negateOffset ++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -&gt; abd acd
// a{b,}c -&gt; abc ac
// a{0..3}d -&gt; a0d a1d a2d a3d
// a{b,c{d,e}f}g -&gt; abg acdfg acefg
// a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -&gt; a{2..}b
// a{b}c -&gt; a{b}c
minimatch.braceExpand = function (pattern, options) {
  return new Minimatch(pattern, options).braceExpand()
}

Minimatch.prototype.braceExpand = braceExpand
function braceExpand (pattern, options) {
  options = options || this.options
  pattern = typeof pattern === &quot;undefined&quot;
    ? this.pattern : pattern

  if (typeof pattern === &quot;undefined&quot;) {
    throw new Error(&quot;undefined pattern&quot;)
  }

  if (options.nobrace ||
      !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  var escaping = false

  // examples and comments refer to this crazy pattern:
  // a{b,c{d,e},{f,g}h}x{y,z}
  // expected:
  // abxy
  // abxz
  // acdxy
  // acdxz
  // acexy
  // acexz
  // afhxy
  // afhxz
  // aghxy
  // aghxz

  // everything before the first \{ is just a prefix.
  // So, we pluck that off, and work with the rest,
  // and then prepend it to everything we find.
  if (pattern.charAt(0) !== &quot;{&quot;) {
    this.debug(pattern)
    var prefix = null
    for (var i = 0, l = pattern.length; i &lt; l; i ++) {
      var c = pattern.charAt(i)
      this.debug(i, c)
      if (c === &quot;\\&quot;) {
        escaping = !escaping
      } else if (c === &quot;{&quot; &amp;&amp; !escaping) {
        prefix = pattern.substr(0, i)
        break
      }
    }

    // actually no sets, all { were escaped.
    if (prefix === null) {
      this.debug(&quot;no sets&quot;)
      return [pattern]
    }

   var tail = braceExpand.call(this, pattern.substr(i), options)
    return tail.map(function (t) {
      return prefix + t
    })
  }

  // now we have something like:
  // {b,c{d,e},{f,g}h}x{y,z}
  // walk through the set, expanding each part, until
  // the set ends.  then, we&#039;ll expand the suffix.
  // If the set only has a single member, then&#039;ll put the {} back

  // first, handle numeric sets, since they&#039;re easier
  var numset = pattern.match(/^\{(-?[0-9]+)\.\.(-?[0-9]+)\}/)
  if (numset) {
    this.debug(&quot;numset&quot;, numset[1], numset[2])
    var suf = braceExpand.call(this, pattern.substr(numset[0].length), options)
      , start = +numset[1]
      , end = +numset[2]
      , inc = start &gt; end ? -1 : 1
      , set = []
    for (var i = start; i != (end + inc); i += inc) {
      // append all the suffixes
      for (var ii = 0, ll = suf.length; ii &lt; ll; ii ++) {
        set.push(i + suf[ii])
      }
    }
    return set
  }

  // ok, walk through the set
  // We hope, somewhat optimistically, that there
  // will be a } at the end.
  // If the closing brace isn&#039;t found, then the pattern is
  // interpreted as braceExpand(&quot;\\&quot; + pattern) so that
  // the leading \{ will be interpreted literally.
  var i = 1 // skip the \{
    , depth = 1
    , set = []
    , member = &quot;&quot;
    , sawEnd = false
    , escaping = false

  function addMember () {
    set.push(member)
    member = &quot;&quot;
  }

  this.debug(&quot;Entering for&quot;)
  FOR: for (i = 1, l = pattern.length; i &lt; l; i ++) {
    var c = pattern.charAt(i)
    this.debug(&quot;&quot;, i, c)

    if (escaping) {
      escaping = false
      member += &quot;\\&quot; + c
    } else {
      switch (c) {
        case &quot;\\&quot;:
          escaping = true
          continue

        case &quot;{&quot;:
          depth ++
          member += &quot;{&quot;
          continue

        case &quot;}&quot;:
          depth --
          // if this closes the actual set, then we&#039;re done
          if (depth === 0) {
            addMember()
            // pluck off the close-brace
            i ++
            break FOR
          } else {
            member += c
            continue
          }

        case &quot;,&quot;:
          if (depth === 1) {
            addMember()
          } else {
            member += c
          }
          continue

        default:
          member += c
          continue
      } // switch
    } // else
  } // for

  // now we&#039;ve either finished the set, and the suffix is
  // pattern.substr(i), or we have *not* closed the set,
  // and need to escape the leading brace
  if (depth !== 0) {
    this.debug(&quot;didn&#039;t close&quot;, pattern)
    return braceExpand.call(this, &quot;\\&quot; + pattern, options)
  }

  // x{y,z} -&gt; [&quot;xy&quot;, &quot;xz&quot;]
  this.debug(&quot;set&quot;, set)
  this.debug(&quot;suffix&quot;, pattern.substr(i))
  var suf = braceExpand.call(this, pattern.substr(i), options)
  // [&quot;b&quot;, &quot;c{d,e}&quot;,&quot;{f,g}h&quot;] -&gt;
  //   [[&quot;b&quot;], [&quot;cd&quot;, &quot;ce&quot;], [&quot;fh&quot;, &quot;gh&quot;]]
  var addBraces = set.length === 1
  this.debug(&quot;set pre-expanded&quot;, set)
  set = set.map(function (p) {
    return braceExpand.call(this, p, options)
  }, this)
  this.debug(&quot;set expanded&quot;, set)


  // [[&quot;b&quot;], [&quot;cd&quot;, &quot;ce&quot;], [&quot;fh&quot;, &quot;gh&quot;]] -&gt;
  //   [&quot;b&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;fh&quot;, &quot;gh&quot;]
  set = set.reduce(function (l, r) {
    return l.concat(r)
  })

  if (addBraces) {
    set = set.map(function (s) {
      return &quot;{&quot; + s + &quot;}&quot;
    })
  }

  // now attach the suffixes.
  var ret = []
  for (var i = 0, l = set.length; i &lt; l; i ++) {
    for (var ii = 0, ll = suf.length; ii &lt; ll; ii ++) {
      ret.push(set[i] + suf[ii])
    }
  }
  return ret
}

// parse a component of the expanded set.
// At this point, no pattern may contain &quot;/&quot; in it
// so we&#039;re going to return a 2d array, where each entry is the full
// pattern, split on &#039;/&#039;, and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  var options = this.options

  // shortcuts
  if (!options.noglobstar &amp;&amp; pattern === &quot;**&quot;) return GLOBSTAR
  if (pattern === &quot;&quot;) return &quot;&quot;

  var re = &quot;&quot;
    , hasMagic = !!options.nocase
    , escaping = false
    // ? =&gt; one single character
    , patternListStack = []
    , plType
    , stateChar
    , inClass = false
    , reClassStart = -1
    , classStart = -1
    // . and .. never match anything that doesn&#039;t start with .,
    // even when options.dot is set.
    , patternStart = pattern.charAt(0) === &quot;.&quot; ? &quot;&quot; // anything
      // not (start or / followed by . or .. followed by / or end)
      : options.dot ? &quot;(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))&quot;
      : &quot;(?!\\.)&quot;
    , self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn&#039;t consumed by this pass.
      switch (stateChar) {
        case &quot;*&quot;:
          re += star
          hasMagic = true
          break
        case &quot;?&quot;:
          re += qmark
          hasMagic = true
          break
        default:
          re += &quot;\\&quot;+stateChar
          break
      }
      self.debug(&#039;clearStateChar %j %j&#039;, stateChar, re)
      stateChar = false
    }
  }

  for ( var i = 0, len = pattern.length, c
      ; (i &lt; len) &amp;&amp; (c = pattern.charAt(i))
      ; i ++ ) {

    this.debug(&quot;%s\t%s %s %j&quot;, pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping &amp;&amp; reSpecials[c]) {
      re += &quot;\\&quot; + c
      escaping = false
      continue
    }

    SWITCH: switch (c) {
      case &quot;/&quot;:
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case &quot;\\&quot;:
        clearStateChar()
        escaping = true
        continue

      // the various stateChar values
      // for the &quot;extglob&quot; stuff.
      case &quot;?&quot;:
      case &quot;*&quot;:
      case &quot;+&quot;:
      case &quot;@&quot;:
      case &quot;!&quot;:
        this.debug(&quot;%s\t%s %s %j &lt;-- stateChar&quot;, pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug(&#039;  in class&#039;)
          if (c === &quot;!&quot; &amp;&amp; i === classStart + 1) c = &quot;^&quot;
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug(&#039;call clearStateChar %j&#039;, stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn&#039;t a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
        continue

      case &quot;(&quot;:
        if (inClass) {
          re += &quot;(&quot;
          continue
        }

        if (!stateChar) {
          re += &quot;\\(&quot;
          continue
        }

        plType = stateChar
        patternListStack.push({ type: plType
                              , start: i - 1
                              , reStart: re.length })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === &quot;!&quot; ? &quot;(?:(?!&quot; : &quot;(?:&quot;
        this.debug(&#039;plType %j %j&#039;, stateChar, re)
        stateChar = false
        continue

      case &quot;)&quot;:
        if (inClass || !patternListStack.length) {
          re += &quot;\\)&quot;
          continue
        }

        clearStateChar()
        hasMagic = true
        re += &quot;)&quot;
        plType = patternListStack.pop().type
        // negation is (?:(?!js)[^/]*)
        // The others are (?:&lt;pattern&gt;)&lt;type&gt;
        switch (plType) {
          case &quot;!&quot;:
            re += &quot;[^/]*?)&quot;
            break
          case &quot;?&quot;:
          case &quot;+&quot;:
          case &quot;*&quot;: re += plType
          case &quot;@&quot;: break // the default anyway
        }
        continue

      case &quot;|&quot;:
        if (inClass || !patternListStack.length || escaping) {
          re += &quot;\\|&quot;
          escaping = false
          continue
        }

        clearStateChar()
        re += &quot;|&quot;
        continue

      // these are mostly the same in regexp and glob
      case &quot;[&quot;:
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += &quot;\\&quot; + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
        continue

      case &quot;]&quot;:
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += &quot;\\&quot; + c
          escaping = false
          continue
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
        continue

      default:
        // swallow any state char that wasn&#039;t consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
                   &amp;&amp; !(c === &quot;^&quot; &amp;&amp; inClass)) {
          re += &quot;\\&quot;
        }

        re += c

    } // switch
  } // for


  // handle the case where we left a class open.
  // &quot;[abc&quot; is valid, equivalent to &quot;\[abc&quot;
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    var cs = pattern.substr(classStart + 1)
      , sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + &quot;\\[&quot; + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  var pl
  while (pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + 3)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn&#039;t already escaped, so escape it.
        $2 = &quot;\\&quot;
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That&#039;s why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + &quot;|&quot;
    })

    this.debug(&quot;tail=%j\n   %s&quot;, tail, tail)
    var t = pl.type === &quot;*&quot; ? star
          : pl.type === &quot;?&quot; ? qmark
          : &quot;\\&quot; + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart)
       + t + &quot;\\(&quot;
       + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += &quot;\\\\&quot;
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case &quot;.&quot;:
    case &quot;[&quot;:
    case &quot;(&quot;: addPatternStart = true
  }

  // if the re is not &quot;&quot; at this point, then we need to make sure
  // it doesn&#039;t match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== &quot;&quot; &amp;&amp; hasMagic) re = &quot;(?=.)&quot; + re

  if (addPatternStart) re = patternStart + re

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [ re, hasMagic ]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it&#039;ll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? &quot;i&quot; : &quot;&quot;
    , regExp = new RegExp(&quot;^&quot; + re + &quot;$&quot;, flags)

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or &quot;**&quot;.
  //
  // It&#039;s better to use .match().  This function shouldn&#039;t
  // be used, really, but it&#039;s pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) return this.regexp = false
  var options = this.options

  var twoStar = options.noglobstar ? star
      : options.dot ? twoStarDot
      : twoStarNoDot
    , flags = options.nocase ? &quot;i&quot; : &quot;&quot;

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
           : (typeof p === &quot;string&quot;) ? regExpEscape(p)
           : p._src
    }).join(&quot;\\\/&quot;)
  }).join(&quot;|&quot;)

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = &quot;^(?:&quot; + re + &quot;)$&quot;

  // can match anything, as long as it&#039;s not this.
  if (this.negate) re = &quot;^(?!&quot; + re + &quot;).*$&quot;

  try {
    return this.regexp = new RegExp(re, flags)
  } catch (ex) {
    return this.regexp = false
  }
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull &amp;&amp; !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug(&quot;match&quot;, f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === &quot;&quot;

  if (f === &quot;/&quot; &amp;&amp; partial) return true

  var options = this.options

  // windows: need to use /, not \
  // On other platforms, \ is a valid (albeit bad) filename char.
  if (platform === &quot;win32&quot;) {
    f = f.split(&quot;\\&quot;).join(&quot;/&quot;)
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, &quot;split&quot;, f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, &quot;set&quot;, set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename;
  for (var i = f.length - 1; i &gt;= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (var i = 0, l = set.length; i &lt; l; i ++) {
    var pattern = set[i], file = f
    if (options.matchBase &amp;&amp; pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn&#039;t get any hits.  this is success if it&#039;s a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// &quot;/a/b&quot; matches the start of &quot;/*/b/*/d&quot;
// Partial means, if you run out of file before you run
// out of pattern, then that&#039;s fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug(&quot;matchOne&quot;,
              { &quot;this&quot;: this
              , file: file
              , pattern: pattern })

  this.debug(&quot;matchOne&quot;, file.length, pattern.length)

  for ( var fi = 0
          , pi = 0
          , fl = file.length
          , pl = pattern.length
      ; (fi &lt; fl) &amp;&amp; (pi &lt; pl)
      ; fi ++, pi ++ ) {

    this.debug(&quot;matchOne loop&quot;)
    var p = pattern[pi]
      , f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug(&#039;GLOBSTAR&#039;, [pattern, p, f])

      // &quot;**&quot;
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** &quot;swallows&quot; a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -&gt; no
      //       - matchOne(y/z/c, c) -&gt; no
      //       - matchOne(z/c, c) -&gt; no
      //       - matchOne(c, c) yes, hit
      var fr = fi
        , pr = pi + 1
      if (pr === pl) {
        this.debug(&#039;** at the end&#039;)
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for ( ; fi &lt; fl; fi ++) {
          if (file[fi] === &quot;.&quot; || file[fi] === &quot;..&quot; ||
              (!options.dot &amp;&amp; file[fi].charAt(0) === &quot;.&quot;)) return false
        }
        return true
      }

      // ok, let&#039;s see if we can swallow whatever we can.
      WHILE: while (fr &lt; fl) {
        var swallowee = file[fr]

        this.debug(&#039;\nglobstar while&#039;,
                    file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug(&#039;globstar found match!&#039;, fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can&#039;t swallow &quot;.&quot; or &quot;..&quot; ever.
          // can only swallow &quot;.foo&quot; when explicitly asked.
          if (swallowee === &quot;.&quot; || swallowee === &quot;..&quot; ||
              (!options.dot &amp;&amp; swallowee.charAt(0) === &quot;.&quot;)) {
            this.debug(&quot;dot detected!&quot;, file, fr, pattern, pr)
            break WHILE
          }

          // ** swallows a segment, and continue.
          this.debug(&#039;globstar swallow a segment, and continue&#039;)
          fr ++
        }
      }
      // no match was found.
      // However, in partial mode, we can&#039;t say this is necessarily over.
      // If there&#039;s more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug(&quot;\n&gt;&gt;&gt; no match, partial?&quot;, file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === &quot;string&quot;) {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug(&quot;string match&quot;, p, f, hit)
    } else {
      hit = f.match(p)
      this.debug(&quot;pattern match&quot;, p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we&#039;ll get a final &quot;&quot;
  // at the end of the pattern.  This can only match a
  // corresponding &quot;&quot; at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn&#039;t have any more for it. But, a/b/ should *not*
  // match &quot;a/b/*&quot;, even though &quot;&quot; matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we&#039;re done.
  if (fi === fl &amp;&amp; pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we&#039;re doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we&#039;re on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) &amp;&amp; (file[fi] === &quot;&quot;)
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error(&quot;wtf?&quot;)
}


// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, &quot;$1&quot;)
}


function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &quot;\\$&amp;&quot;)
}

})( typeof require === &quot;function&quot; ? require : null,
    this,
    typeof module === &quot;object&quot; ? module : null,
    typeof process === &quot;object&quot; ? process.platform : &quot;win32&quot;
  )</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
