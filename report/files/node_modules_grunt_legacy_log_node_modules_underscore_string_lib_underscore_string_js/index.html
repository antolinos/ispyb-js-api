<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/grunt-legacy-log/node_modules/underscore.string/lib/underscore.string.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/grunt-legacy-log/node_modules/underscore.string/lib/underscore.string.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">63.74</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">666</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">127.07</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">9.62</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">//  Underscore.string
//  (c) 2010 Esa-Matti Suuronen &lt;esa-matti aet suuronen dot org&gt;
//  Underscore.string is freely distributable under the terms of the MIT license.
//  Documentation: https://github.com/epeli/underscore.string
//  Some code is borrowed from MooTools and Alexandru Marasteanu.
//  Version &#039;2.3.2&#039;

!function(root, String){
  &#039;use strict&#039;;

  // Defining helper functions.

  var nativeTrim = String.prototype.trim;
  var nativeTrimRight = String.prototype.trimRight;
  var nativeTrimLeft = String.prototype.trimLeft;

  var parseNumber = function(source) { return source * 1 || 0; };

  var strRepeat = function(str, qty){
    if (qty &lt; 1) return &#039;&#039;;
    var result = &#039;&#039;;
    while (qty &gt; 0) {
      if (qty &amp; 1) result += str;
      qty &gt;&gt;= 1, str += str;
    }
    return result;
  };

  var slice = [].slice;

  var defaultToWhiteSpace = function(characters) {
    if (characters == null)
      return &#039;\\s&#039;;
    else if (characters.source)
      return characters.source;
    else
      return &#039;[&#039; + _s.escapeRegExp(characters) + &#039;]&#039;;
  };

  // Helper for toBoolean
  function boolMatch(s, matchers) {
    var i, matcher, down = s.toLowerCase();
    matchers = [].concat(matchers);
    for (i = 0; i &lt; matchers.length; i += 1) {
      matcher = matchers[i];
      if (!matcher) continue;
      if (matcher.test &amp;&amp; matcher.test(s)) return true;
      if (matcher.toLowerCase() === down) return true;
    }
  }

  var escapeChars = {
    lt: &#039;&lt;&#039;,
    gt: &#039;&gt;&#039;,
    quot: &#039;&quot;&#039;,
    amp: &#039;&amp;&#039;,
    apos: &quot;&#039;&quot;
  };

  var reversedEscapeChars = {};
  for(var key in escapeChars) reversedEscapeChars[escapeChars[key]] = key;
  reversedEscapeChars[&quot;&#039;&quot;] = &#039;#39&#039;;

  // sprintf() for JavaScript 0.7-beta1
  // http://www.diveintojavascript.com/projects/javascript-sprintf
  //
  // Copyright (c) Alexandru Marasteanu &lt;alexaholic [at) gmail (dot] com&gt;
  // All rights reserved.

  var sprintf = (function() {
    function get_type(variable) {
      return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
    }

    var str_repeat = strRepeat;

    var str_format = function() {
      if (!str_format.cache.hasOwnProperty(arguments[0])) {
        str_format.cache[arguments[0]] = str_format.parse(arguments[0]);
      }
      return str_format.format.call(null, str_format.cache[arguments[0]], arguments);
    };

    str_format.format = function(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, node_type = &#039;&#039;, arg, output = [], i, k, match, pad, pad_character, pad_length;
      for (i = 0; i &lt; tree_length; i++) {
        node_type = get_type(parse_tree[i]);
        if (node_type === &#039;string&#039;) {
          output.push(parse_tree[i]);
        }
        else if (node_type === &#039;array&#039;) {
          match = parse_tree[i]; // convenience purposes only
          if (match[2]) { // keyword argument
            arg = argv[cursor];
            for (k = 0; k &lt; match[2].length; k++) {
              if (!arg.hasOwnProperty(match[2][k])) {
                throw new Error(sprintf(&#039;[_.sprintf] property &quot;%s&quot; does not exist&#039;, match[2][k]));
              }
              arg = arg[match[2][k]];
            }
          } else if (match[1]) { // positional argument (explicit)
            arg = argv[match[1]];
          }
          else { // positional argument (implicit)
            arg = argv[cursor++];
          }

          if (/[^s]/.test(match[8]) &amp;&amp; (get_type(arg) != &#039;number&#039;)) {
            throw new Error(sprintf(&#039;[_.sprintf] expecting number but found %s&#039;, get_type(arg)));
          }
          switch (match[8]) {
            case &#039;b&#039;: arg = arg.toString(2); break;
            case &#039;c&#039;: arg = String.fromCharCode(arg); break;
            case &#039;d&#039;: arg = parseInt(arg, 10); break;
            case &#039;e&#039;: arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential(); break;
            case &#039;f&#039;: arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg); break;
            case &#039;o&#039;: arg = arg.toString(8); break;
            case &#039;s&#039;: arg = ((arg = String(arg)) &amp;&amp; match[7] ? arg.substring(0, match[7]) : arg); break;
            case &#039;u&#039;: arg = Math.abs(arg); break;
            case &#039;x&#039;: arg = arg.toString(16); break;
            case &#039;X&#039;: arg = arg.toString(16).toUpperCase(); break;
          }
          arg = (/[def]/.test(match[8]) &amp;&amp; match[3] &amp;&amp; arg &gt;= 0 ? &#039;+&#039;+ arg : arg);
          pad_character = match[4] ? match[4] == &#039;0&#039; ? &#039;0&#039; : match[4].charAt(1) : &#039; &#039;;
          pad_length = match[6] - String(arg).length;
          pad = match[6] ? str_repeat(pad_character, pad_length) : &#039;&#039;;
          output.push(match[5] ? arg + pad : pad + arg);
        }
      }
      return output.join(&#039;&#039;);
    };

    str_format.cache = {};

    str_format.parse = function(fmt) {
      var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        }
        else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
          parse_tree.push(&#039;%&#039;);
        }
        else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|&#039;[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== &#039;&#039;) {
                if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                }
                else {
                  throw new Error(&#039;[_.sprintf] huh?&#039;);
                }
              }
            }
            else {
              throw new Error(&#039;[_.sprintf] huh?&#039;);
            }
            match[2] = field_list;
          }
          else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error(&#039;[_.sprintf] mixing positional and named placeholders is not (yet) supported&#039;);
          }
          parse_tree.push(match);
        }
        else {
          throw new Error(&#039;[_.sprintf] huh?&#039;);
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return parse_tree;
    };

    return str_format;
  })();



  // Defining underscore.string

  var _s = {

    VERSION: &#039;2.3.0&#039;,

    isBlank: function(str){
      if (str == null) str = &#039;&#039;;
      return (/^\s*$/).test(str);
    },

    stripTags: function(str){
      if (str == null) return &#039;&#039;;
      return String(str).replace(/&lt;\/?[^&gt;]+&gt;/g, &#039;&#039;);
    },

    capitalize : function(str){
      str = str == null ? &#039;&#039; : String(str);
      return str.charAt(0).toUpperCase() + str.slice(1);
    },

    chop: function(str, step){
      if (str == null) return [];
      str = String(str);
      step = ~~step;
      return step &gt; 0 ? str.match(new RegExp(&#039;.{1,&#039; + step + &#039;}&#039;, &#039;g&#039;)) : [str];
    },

    clean: function(str){
      return _s.strip(str).replace(/\s+/g, &#039; &#039;);
    },

    count: function(str, substr){
      if (str == null || substr == null) return 0;

      str = String(str);
      substr = String(substr);

      var count = 0,
        pos = 0,
        length = substr.length;

      while (true) {
        pos = str.indexOf(substr, pos);
        if (pos === -1) break;
        count++;
        pos += length;
      }

      return count;
    },

    chars: function(str) {
      if (str == null) return [];
      return String(str).split(&#039;&#039;);
    },

    swapCase: function(str) {
      if (str == null) return &#039;&#039;;
      return String(str).replace(/\S/g, function(c){
        return c === c.toUpperCase() ? c.toLowerCase() : c.toUpperCase();
      });
    },

    escapeHTML: function(str) {
      if (str == null) return &#039;&#039;;
      return String(str).replace(/[&amp;&lt;&gt;&quot;&#039;]/g, function(m){ return &#039;&amp;&#039; + reversedEscapeChars[m] + &#039;;&#039;; });
    },

    unescapeHTML: function(str) {
      if (str == null) return &#039;&#039;;
      return String(str).replace(/\&amp;([^;]+);/g, function(entity, entityCode){
        var match;

        if (entityCode in escapeChars) {
          return escapeChars[entityCode];
        } else if (match = entityCode.match(/^#x([\da-fA-F]+)$/)) {
          return String.fromCharCode(parseInt(match[1], 16));
        } else if (match = entityCode.match(/^#(\d+)$/)) {
          return String.fromCharCode(~~match[1]);
        } else {
          return entity;
        }
      });
    },

    escapeRegExp: function(str){
      if (str == null) return &#039;&#039;;
      return String(str).replace(/([.*+?^=!:${}()|[\]\/\\])/g, &#039;\\$1&#039;);
    },

    splice: function(str, i, howmany, substr){
      var arr = _s.chars(str);
      arr.splice(~~i, ~~howmany, substr);
      return arr.join(&#039;&#039;);
    },

    insert: function(str, i, substr){
      return _s.splice(str, i, 0, substr);
    },

    include: function(str, needle){
      if (needle === &#039;&#039;) return true;
      if (str == null) return false;
      return String(str).indexOf(needle) !== -1;
    },

    join: function() {
      var args = slice.call(arguments),
        separator = args.shift();

      if (separator == null) separator = &#039;&#039;;

      return args.join(separator);
    },

    lines: function(str) {
      if (str == null) return [];
      return String(str).split(&quot;\n&quot;);
    },

    reverse: function(str){
      return _s.chars(str).reverse().join(&#039;&#039;);
    },

    startsWith: function(str, starts){
      if (starts === &#039;&#039;) return true;
      if (str == null || starts == null) return false;
      str = String(str); starts = String(starts);
      return str.length &gt;= starts.length &amp;&amp; str.slice(0, starts.length) === starts;
    },

    endsWith: function(str, ends){
      if (ends === &#039;&#039;) return true;
      if (str == null || ends == null) return false;
      str = String(str); ends = String(ends);
      return str.length &gt;= ends.length &amp;&amp; str.slice(str.length - ends.length) === ends;
    },

    succ: function(str){
      if (str == null) return &#039;&#039;;
      str = String(str);
      return str.slice(0, -1) + String.fromCharCode(str.charCodeAt(str.length-1) + 1);
    },

    titleize: function(str){
      if (str == null) return &#039;&#039;;
      str  = String(str).toLowerCase();
      return str.replace(/(?:^|\s|-)\S/g, function(c){ return c.toUpperCase(); });
    },

    camelize: function(str){
      return _s.trim(str).replace(/[-_\s]+(.)?/g, function(match, c){ return c ? c.toUpperCase() : &quot;&quot;; });
    },

    underscored: function(str){
      return _s.trim(str).replace(/([a-z\d])([A-Z]+)/g, &#039;$1_$2&#039;).replace(/[-\s]+/g, &#039;_&#039;).toLowerCase();
    },

    dasherize: function(str){
      return _s.trim(str).replace(/([A-Z])/g, &#039;-$1&#039;).replace(/[-_\s]+/g, &#039;-&#039;).toLowerCase();
    },

    classify: function(str){
      return _s.titleize(String(str).replace(/[\W_]/g, &#039; &#039;)).replace(/\s/g, &#039;&#039;);
    },

    humanize: function(str){
      return _s.capitalize(_s.underscored(str).replace(/_id$/,&#039;&#039;).replace(/_/g, &#039; &#039;));
    },

    trim: function(str, characters){
      if (str == null) return &#039;&#039;;
      if (!characters &amp;&amp; nativeTrim) return nativeTrim.call(str);
      characters = defaultToWhiteSpace(characters);
      return String(str).replace(new RegExp(&#039;\^&#039; + characters + &#039;+|&#039; + characters + &#039;+$&#039;, &#039;g&#039;), &#039;&#039;);
    },

    ltrim: function(str, characters){
      if (str == null) return &#039;&#039;;
      if (!characters &amp;&amp; nativeTrimLeft) return nativeTrimLeft.call(str);
      characters = defaultToWhiteSpace(characters);
      return String(str).replace(new RegExp(&#039;^&#039; + characters + &#039;+&#039;), &#039;&#039;);
    },

    rtrim: function(str, characters){
      if (str == null) return &#039;&#039;;
      if (!characters &amp;&amp; nativeTrimRight) return nativeTrimRight.call(str);
      characters = defaultToWhiteSpace(characters);
      return String(str).replace(new RegExp(characters + &#039;+$&#039;), &#039;&#039;);
    },

    truncate: function(str, length, truncateStr){
      if (str == null) return &#039;&#039;;
      str = String(str); truncateStr = truncateStr || &#039;...&#039;;
      length = ~~length;
      return str.length &gt; length ? str.slice(0, length) + truncateStr : str;
    },

    /**
     * _s.prune: a more elegant version of truncate
     * prune extra chars, never leaving a half-chopped word.
     * @author github.com/rwz
     */
    prune: function(str, length, pruneStr){
      if (str == null) return &#039;&#039;;

      str = String(str); length = ~~length;
      pruneStr = pruneStr != null ? String(pruneStr) : &#039;...&#039;;

      if (str.length &lt;= length) return str;

      var tmpl = function(c){ return c.toUpperCase() !== c.toLowerCase() ? &#039;A&#039; : &#039; &#039;; },
        template = str.slice(0, length+1).replace(/.(?=\W*\w*$)/g, tmpl); // &#039;Hello, world&#039; -&gt; &#039;HellAA AAAAA&#039;

      if (template.slice(template.length-2).match(/\w\w/))
        template = template.replace(/\s*\S+$/, &#039;&#039;);
      else
        template = _s.rtrim(template.slice(0, template.length-1));

      return (template+pruneStr).length &gt; str.length ? str : str.slice(0, template.length)+pruneStr;
    },

    words: function(str, delimiter) {
      if (_s.isBlank(str)) return [];
      return _s.trim(str, delimiter).split(delimiter || /\s+/);
    },

    pad: function(str, length, padStr, type) {
      str = str == null ? &#039;&#039; : String(str);
      length = ~~length;

      var padlen  = 0;

      if (!padStr)
        padStr = &#039; &#039;;
      else if (padStr.length &gt; 1)
        padStr = padStr.charAt(0);

      switch(type) {
        case &#039;right&#039;:
          padlen = length - str.length;
          return str + strRepeat(padStr, padlen);
        case &#039;both&#039;:
          padlen = length - str.length;
          return strRepeat(padStr, Math.ceil(padlen/2)) + str
                  + strRepeat(padStr, Math.floor(padlen/2));
        default: // &#039;left&#039;
          padlen = length - str.length;
          return strRepeat(padStr, padlen) + str;
        }
    },

    lpad: function(str, length, padStr) {
      return _s.pad(str, length, padStr);
    },

    rpad: function(str, length, padStr) {
      return _s.pad(str, length, padStr, &#039;right&#039;);
    },

    lrpad: function(str, length, padStr) {
      return _s.pad(str, length, padStr, &#039;both&#039;);
    },

    sprintf: sprintf,

    vsprintf: function(fmt, argv){
      argv.unshift(fmt);
      return sprintf.apply(null, argv);
    },

    toNumber: function(str, decimals) {
      if (!str) return 0;
      str = _s.trim(str);
      if (!str.match(/^-?\d+(?:\.\d+)?$/)) return NaN;
      return parseNumber(parseNumber(str).toFixed(~~decimals));
    },

    numberFormat : function(number, dec, dsep, tsep) {
      if (isNaN(number) || number == null) return &#039;&#039;;

      number = number.toFixed(~~dec);
      tsep = typeof tsep == &#039;string&#039; ? tsep : &#039;,&#039;;

      var parts = number.split(&#039;.&#039;), fnums = parts[0],
        decimals = parts[1] ? (dsep || &#039;.&#039;) + parts[1] : &#039;&#039;;

      return fnums.replace(/(\d)(?=(?:\d{3})+$)/g, &#039;$1&#039; + tsep) + decimals;
    },

    strRight: function(str, sep){
      if (str == null) return &#039;&#039;;
      str = String(str); sep = sep != null ? String(sep) : sep;
      var pos = !sep ? -1 : str.indexOf(sep);
      return ~pos ? str.slice(pos+sep.length, str.length) : str;
    },

    strRightBack: function(str, sep){
      if (str == null) return &#039;&#039;;
      str = String(str); sep = sep != null ? String(sep) : sep;
      var pos = !sep ? -1 : str.lastIndexOf(sep);
      return ~pos ? str.slice(pos+sep.length, str.length) : str;
    },

    strLeft: function(str, sep){
      if (str == null) return &#039;&#039;;
      str = String(str); sep = sep != null ? String(sep) : sep;
      var pos = !sep ? -1 : str.indexOf(sep);
      return ~pos ? str.slice(0, pos) : str;
    },

    strLeftBack: function(str, sep){
      if (str == null) return &#039;&#039;;
      str += &#039;&#039;; sep = sep != null ? &#039;&#039;+sep : sep;
      var pos = str.lastIndexOf(sep);
      return ~pos ? str.slice(0, pos) : str;
    },

    toSentence: function(array, separator, lastSeparator, serial) {
      separator = separator || &#039;, &#039;;
      lastSeparator = lastSeparator || &#039; and &#039;;
      var a = array.slice(), lastMember = a.pop();

      if (array.length &gt; 2 &amp;&amp; serial) lastSeparator = _s.rtrim(separator) + lastSeparator;

      return a.length ? a.join(separator) + lastSeparator + lastMember : lastMember;
    },

    toSentenceSerial: function() {
      var args = slice.call(arguments);
      args[3] = true;
      return _s.toSentence.apply(_s, args);
    },

    slugify: function(str) {
      if (str == null) return &#039;&#039;;

      var from  = &quot;ąàáäâãåæăćęèéëêìíïîłńòóöôõøśșțùúüûñçżź&quot;,
          to    = &quot;aaaaaaaaaceeeeeiiiilnoooooosstuuuunczz&quot;,
          regex = new RegExp(defaultToWhiteSpace(from), &#039;g&#039;);

      str = String(str).toLowerCase().replace(regex, function(c){
        var index = from.indexOf(c);
        return to.charAt(index) || &#039;-&#039;;
      });

      return _s.dasherize(str.replace(/[^\w\s-]/g, &#039;&#039;));
    },

    surround: function(str, wrapper) {
      return [wrapper, str, wrapper].join(&#039;&#039;);
    },

    quote: function(str, quoteChar) {
      return _s.surround(str, quoteChar || &#039;&quot;&#039;);
    },

    unquote: function(str, quoteChar) {
      quoteChar = quoteChar || &#039;&quot;&#039;;
      if (str[0] === quoteChar &amp;&amp; str[str.length-1] === quoteChar)
        return str.slice(1,str.length-1);
      else return str;
    },

    exports: function() {
      var result = {};

      for (var prop in this) {
        if (!this.hasOwnProperty(prop) || prop.match(/^(?:include|contains|reverse)$/)) continue;
        result[prop] = this[prop];
      }

      return result;
    },

    repeat: function(str, qty, separator){
      if (str == null) return &#039;&#039;;

      qty = ~~qty;

      // using faster implementation if separator is not needed;
      if (separator == null) return strRepeat(String(str), qty);

      // this one is about 300x slower in Google Chrome
      for (var repeat = []; qty &gt; 0; repeat[--qty] = str) {}
      return repeat.join(separator);
    },

    naturalCmp: function(str1, str2){
      if (str1 == str2) return 0;
      if (!str1) return -1;
      if (!str2) return 1;

      var cmpRegex = /(\.\d+)|(\d+)|(\D+)/g,
        tokens1 = String(str1).toLowerCase().match(cmpRegex),
        tokens2 = String(str2).toLowerCase().match(cmpRegex),
        count = Math.min(tokens1.length, tokens2.length);

      for(var i = 0; i &lt; count; i++) {
        var a = tokens1[i], b = tokens2[i];

        if (a !== b){
          var num1 = parseInt(a, 10);
          if (!isNaN(num1)){
            var num2 = parseInt(b, 10);
            if (!isNaN(num2) &amp;&amp; num1 - num2)
              return num1 - num2;
          }
          return a &lt; b ? -1 : 1;
        }
      }

      if (tokens1.length === tokens2.length)
        return tokens1.length - tokens2.length;

      return str1 &lt; str2 ? -1 : 1;
    },

    levenshtein: function(str1, str2) {
      if (str1 == null &amp;&amp; str2 == null) return 0;
      if (str1 == null) return String(str2).length;
      if (str2 == null) return String(str1).length;

      str1 = String(str1); str2 = String(str2);

      var current = [], prev, value;

      for (var i = 0; i &lt;= str2.length; i++)
        for (var j = 0; j &lt;= str1.length; j++) {
          if (i &amp;&amp; j)
            if (str1.charAt(j - 1) === str2.charAt(i - 1))
              value = prev;
            else
              value = Math.min(current[j], current[j - 1], prev) + 1;
          else
            value = i + j;

          prev = current[j];
          current[j] = value;
        }

      return current.pop();
    },

    toBoolean: function(str, trueValues, falseValues) {
      if (typeof str === &quot;number&quot;) str = &quot;&quot; + str;
      if (typeof str !== &quot;string&quot;) return !!str;
      str = _s.trim(str);
      if (boolMatch(str, trueValues || [&quot;true&quot;, &quot;1&quot;])) return true;
      if (boolMatch(str, falseValues || [&quot;false&quot;, &quot;0&quot;])) return false;
    }
  };

  // Aliases

  _s.strip    = _s.trim;
  _s.lstrip   = _s.ltrim;
  _s.rstrip   = _s.rtrim;
  _s.center   = _s.lrpad;
  _s.rjust    = _s.lpad;
  _s.ljust    = _s.rpad;
  _s.contains = _s.include;
  _s.q        = _s.quote;
  _s.toBool   = _s.toBoolean;

  // Exporting

  // CommonJS module is defined
  if (typeof exports !== &#039;undefined&#039;) {
    if (typeof module !== &#039;undefined&#039; &amp;&amp; module.exports)
      module.exports = _s;

    exports._s = _s;
  }

  // Register as a named module with AMD.
  if (typeof define === &#039;function&#039; &amp;&amp; define.amd)
    define(&#039;underscore.string&#039;, [], function(){ return _s; });


  // Integrate with Underscore.js if defined
  // or create our own underscore object.
  root._ = root._ || {};
  root._.string = root._.str = _s;
}(this, String);</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
