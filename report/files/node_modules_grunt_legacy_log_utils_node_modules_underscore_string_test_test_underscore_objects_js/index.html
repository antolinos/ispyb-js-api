<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/objects.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/grunt-legacy-log-utils/node_modules/underscore.string/test/test_underscore/objects.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.25</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">548</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">48.48</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">12.34</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">$(document).ready(function() {

  module(&quot;Objects&quot;);

  test(&quot;keys&quot;, function() {
    equal(_.keys({one : 1, two : 2}).join(&#039;, &#039;), &#039;one, two&#039;, &#039;can extract the keys from an object&#039;);
    // the test above is not safe because it relies on for-in enumeration order
    var a = []; a[1] = 0;
    equal(_.keys(a).join(&#039;, &#039;), &#039;1&#039;, &#039;is not fooled by sparse arrays; see issue #95&#039;);
    raises(function() { _.keys(null); }, TypeError, &#039;throws an error for `null` values&#039;);
    raises(function() { _.keys(void 0); }, TypeError, &#039;throws an error for `undefined` values&#039;);
    raises(function() { _.keys(1); }, TypeError, &#039;throws an error for number primitives&#039;);
    raises(function() { _.keys(&#039;a&#039;); }, TypeError, &#039;throws an error for string primitives&#039;);
    raises(function() { _.keys(true); }, TypeError, &#039;throws an error for boolean primitives&#039;);
  });

  test(&quot;values&quot;, function() {
    equal(_.values({one: 1, two: 2}).join(&#039;, &#039;), &#039;1, 2&#039;, &#039;can extract the values from an object&#039;);
    equal(_.values({one: 1, two: 2, length: 3}).join(&#039;, &#039;), &#039;1, 2, 3&#039;, &#039;... even when one of them is &quot;length&quot;&#039;);
  });

  test(&quot;pairs&quot;, function() {
    deepEqual(_.pairs({one: 1, two: 2}), [[&#039;one&#039;, 1], [&#039;two&#039;, 2]], &#039;can convert an object into pairs&#039;);
    deepEqual(_.pairs({one: 1, two: 2, length: 3}), [[&#039;one&#039;, 1], [&#039;two&#039;, 2], [&#039;length&#039;, 3]], &#039;... even when one of them is &quot;length&quot;&#039;);
  });

  test(&quot;invert&quot;, function() {
    var obj = {first: &#039;Moe&#039;, second: &#039;Larry&#039;, third: &#039;Curly&#039;};
    equal(_.keys(_.invert(obj)).join(&#039; &#039;), &#039;Moe Larry Curly&#039;, &#039;can invert an object&#039;);
    ok(_.isEqual(_.invert(_.invert(obj)), obj), &#039;two inverts gets you back where you started&#039;);

    var obj = {length: 3};
    ok(_.invert(obj)[&#039;3&#039;] == &#039;length&#039;, &#039;can invert an object with &quot;length&quot;&#039;)
  });

  test(&quot;functions&quot;, function() {
    var obj = {a : &#039;dash&#039;, b : _.map, c : (/yo/), d : _.reduce};
    ok(_.isEqual([&#039;b&#039;, &#039;d&#039;], _.functions(obj)), &#039;can grab the function names of any passed-in object&#039;);

    var Animal = function(){};
    Animal.prototype.run = function(){};
    equal(_.functions(new Animal).join(&#039;&#039;), &#039;run&#039;, &#039;also looks up functions on the prototype&#039;);
  });

  test(&quot;extend&quot;, function() {
    var result;
    equal(_.extend({}, {a:&#039;b&#039;}).a, &#039;b&#039;, &#039;can extend an object with the attributes of another&#039;);
    equal(_.extend({a:&#039;x&#039;}, {a:&#039;b&#039;}).a, &#039;b&#039;, &#039;properties in source override destination&#039;);
    equal(_.extend({x:&#039;x&#039;}, {a:&#039;b&#039;}).x, &#039;x&#039;, &#039;properties not in source dont get overriden&#039;);
    result = _.extend({x:&#039;x&#039;}, {a:&#039;a&#039;}, {b:&#039;b&#039;});
    ok(_.isEqual(result, {x:&#039;x&#039;, a:&#039;a&#039;, b:&#039;b&#039;}), &#039;can extend from multiple source objects&#039;);
    result = _.extend({x:&#039;x&#039;}, {a:&#039;a&#039;, x:2}, {a:&#039;b&#039;});
    ok(_.isEqual(result, {x:2, a:&#039;b&#039;}), &#039;extending from multiple source objects last property trumps&#039;);
    result = _.extend({}, {a: void 0, b: null});
    equal(_.keys(result).join(&#039;&#039;), &#039;ab&#039;, &#039;extend does not copy undefined values&#039;);
  });

  test(&quot;pick&quot;, function() {
    var result;
    result = _.pick({a:1, b:2, c:3}, &#039;a&#039;, &#039;c&#039;);
    ok(_.isEqual(result, {a:1, c:3}), &#039;can restrict properties to those named&#039;);
    result = _.pick({a:1, b:2, c:3}, [&#039;b&#039;, &#039;c&#039;]);
    ok(_.isEqual(result, {b:2, c:3}), &#039;can restrict properties to those named in an array&#039;);
    result = _.pick({a:1, b:2, c:3}, [&#039;a&#039;], &#039;b&#039;);
    ok(_.isEqual(result, {a:1, b:2}), &#039;can restrict properties to those named in mixed args&#039;);

    var Obj = function(){};
    Obj.prototype = {a: 1, b: 2, c: 3};
    ok(_.isEqual(_.pick(new Obj, &#039;a&#039;, &#039;c&#039;), {a:1, c: 3}), &#039;include prototype props&#039;);
  });

  test(&quot;omit&quot;, function() {
    var result;
    result = _.omit({a:1, b:2, c:3}, &#039;b&#039;);
    ok(_.isEqual(result, {a:1, c:3}), &#039;can omit a single named property&#039;);
    result = _.omit({a:1, b:2, c:3}, &#039;a&#039;, &#039;c&#039;);
    ok(_.isEqual(result, {b:2}), &#039;can omit several named properties&#039;);
    result = _.omit({a:1, b:2, c:3}, [&#039;b&#039;, &#039;c&#039;]);
    ok(_.isEqual(result, {a:1}), &#039;can omit properties named in an array&#039;);

    var Obj = function(){};
    Obj.prototype = {a: 1, b: 2, c: 3};
    ok(_.isEqual(_.omit(new Obj, &#039;b&#039;), {a:1, c: 3}), &#039;include prototype props&#039;);
  });

  test(&quot;defaults&quot;, function() {
    var result;
    var options = {zero: 0, one: 1, empty: &quot;&quot;, nan: NaN, string: &quot;string&quot;};

    _.defaults(options, {zero: 1, one: 10, twenty: 20});
    equal(options.zero, 0, &#039;value exists&#039;);
    equal(options.one, 1, &#039;value exists&#039;);
    equal(options.twenty, 20, &#039;default applied&#039;);

    _.defaults(options, {empty: &quot;full&quot;}, {nan: &quot;nan&quot;}, {word: &quot;word&quot;}, {word: &quot;dog&quot;});
    equal(options.empty, &quot;&quot;, &#039;value exists&#039;);
    ok(_.isNaN(options.nan), &quot;NaN isn&#039;t overridden&quot;);
    equal(options.word, &quot;word&quot;, &#039;new value is added, first one wins&#039;);
  });

  test(&quot;clone&quot;, function() {
    var moe = {name : &#039;moe&#039;, lucky : [13, 27, 34]};
    var clone = _.clone(moe);
    equal(clone.name, &#039;moe&#039;, &#039;the clone as the attributes of the original&#039;);

    clone.name = &#039;curly&#039;;
    ok(clone.name == &#039;curly&#039; &amp;&amp; moe.name == &#039;moe&#039;, &#039;clones can change shallow attributes without affecting the original&#039;);

    clone.lucky.push(101);
    equal(_.last(moe.lucky), 101, &#039;changes to deep attributes are shared with the original&#039;);

    equal(_.clone(undefined), void 0, &#039;non objects should not be changed by clone&#039;);
    equal(_.clone(1), 1, &#039;non objects should not be changed by clone&#039;);
    equal(_.clone(null), null, &#039;non objects should not be changed by clone&#039;);
  });

  test(&quot;isEqual&quot;, function() {
    function First() {
      this.value = 1;
    }
    First.prototype.value = 1;
    function Second() {
      this.value = 1;
    }
    Second.prototype.value = 2;

    // Basic equality and identity comparisons.
    ok(_.isEqual(null, null), &quot;`null` is equal to `null`&quot;);
    ok(_.isEqual(), &quot;`undefined` is equal to `undefined`&quot;);

    ok(!_.isEqual(0, -0), &quot;`0` is not equal to `-0`&quot;);
    ok(!_.isEqual(-0, 0), &quot;Commutative equality is implemented for `0` and `-0`&quot;);
    ok(!_.isEqual(null, undefined), &quot;`null` is not equal to `undefined`&quot;);
    ok(!_.isEqual(undefined, null), &quot;Commutative equality is implemented for `null` and `undefined`&quot;);

    // String object and primitive comparisons.
    ok(_.isEqual(&quot;Curly&quot;, &quot;Curly&quot;), &quot;Identical string primitives are equal&quot;);
    ok(_.isEqual(new String(&quot;Curly&quot;), new String(&quot;Curly&quot;)), &quot;String objects with identical primitive values are equal&quot;);
    ok(_.isEqual(new String(&quot;Curly&quot;), &quot;Curly&quot;), &quot;String primitives and their corresponding object wrappers are equal&quot;);
    ok(_.isEqual(&quot;Curly&quot;, new String(&quot;Curly&quot;)), &quot;Commutative equality is implemented for string objects and primitives&quot;);

    ok(!_.isEqual(&quot;Curly&quot;, &quot;Larry&quot;), &quot;String primitives with different values are not equal&quot;);
    ok(!_.isEqual(new String(&quot;Curly&quot;), new String(&quot;Larry&quot;)), &quot;String objects with different primitive values are not equal&quot;);
    ok(!_.isEqual(new String(&quot;Curly&quot;), {toString: function(){ return &quot;Curly&quot;; }}), &quot;String objects and objects with a custom `toString` method are not equal&quot;);

    // Number object and primitive comparisons.
    ok(_.isEqual(75, 75), &quot;Identical number primitives are equal&quot;);
    ok(_.isEqual(new Number(75), new Number(75)), &quot;Number objects with identical primitive values are equal&quot;);
    ok(_.isEqual(75, new Number(75)), &quot;Number primitives and their corresponding object wrappers are equal&quot;);
    ok(_.isEqual(new Number(75), 75), &quot;Commutative equality is implemented for number objects and primitives&quot;);
    ok(!_.isEqual(new Number(0), -0), &quot;`new Number(0)` and `-0` are not equal&quot;);
    ok(!_.isEqual(0, new Number(-0)), &quot;Commutative equality is implemented for `new Number(0)` and `-0`&quot;);

    ok(!_.isEqual(new Number(75), new Number(63)), &quot;Number objects with different primitive values are not equal&quot;);
    ok(!_.isEqual(new Number(63), {valueOf: function(){ return 63; }}), &quot;Number objects and objects with a `valueOf` method are not equal&quot;);

    // Comparisons involving `NaN`.
    ok(_.isEqual(NaN, NaN), &quot;`NaN` is equal to `NaN`&quot;);
    ok(!_.isEqual(61, NaN), &quot;A number primitive is not equal to `NaN`&quot;);
    ok(!_.isEqual(new Number(79), NaN), &quot;A number object is not equal to `NaN`&quot;);
    ok(!_.isEqual(Infinity, NaN), &quot;`Infinity` is not equal to `NaN`&quot;);

    // Boolean object and primitive comparisons.
    ok(_.isEqual(true, true), &quot;Identical boolean primitives are equal&quot;);
    ok(_.isEqual(new Boolean, new Boolean), &quot;Boolean objects with identical primitive values are equal&quot;);
    ok(_.isEqual(true, new Boolean(true)), &quot;Boolean primitives and their corresponding object wrappers are equal&quot;);
    ok(_.isEqual(new Boolean(true), true), &quot;Commutative equality is implemented for booleans&quot;);
    ok(!_.isEqual(new Boolean(true), new Boolean), &quot;Boolean objects with different primitive values are not equal&quot;);

    // Common type coercions.
    ok(!_.isEqual(true, new Boolean(false)), &quot;Boolean objects are not equal to the boolean primitive `true`&quot;);
    ok(!_.isEqual(&quot;75&quot;, 75), &quot;String and number primitives with like values are not equal&quot;);
    ok(!_.isEqual(new Number(63), new String(63)), &quot;String and number objects with like values are not equal&quot;);
    ok(!_.isEqual(75, &quot;75&quot;), &quot;Commutative equality is implemented for like string and number values&quot;);
    ok(!_.isEqual(0, &quot;&quot;), &quot;Number and string primitives with like values are not equal&quot;);
    ok(!_.isEqual(1, true), &quot;Number and boolean primitives with like values are not equal&quot;);
    ok(!_.isEqual(new Boolean(false), new Number(0)), &quot;Boolean and number objects with like values are not equal&quot;);
    ok(!_.isEqual(false, new String(&quot;&quot;)), &quot;Boolean primitives and string objects with like values are not equal&quot;);
    ok(!_.isEqual(12564504e5, new Date(2009, 9, 25)), &quot;Dates and their corresponding numeric primitive values are not equal&quot;);

    // Dates.
    ok(_.isEqual(new Date(2009, 9, 25), new Date(2009, 9, 25)), &quot;Date objects referencing identical times are equal&quot;);
    ok(!_.isEqual(new Date(2009, 9, 25), new Date(2009, 11, 13)), &quot;Date objects referencing different times are not equal&quot;);
    ok(!_.isEqual(new Date(2009, 11, 13), {
      getTime: function(){
        return 12606876e5;
      }
    }), &quot;Date objects and objects with a `getTime` method are not equal&quot;);
    ok(!_.isEqual(new Date(&quot;Curly&quot;), new Date(&quot;Curly&quot;)), &quot;Invalid dates are not equal&quot;);

    // Functions.
    ok(!_.isEqual(First, Second), &quot;Different functions with identical bodies and source code representations are not equal&quot;);

    // RegExps.
    ok(_.isEqual(/(?:)/gim, /(?:)/gim), &quot;RegExps with equivalent patterns and flags are equal&quot;);
    ok(!_.isEqual(/(?:)/g, /(?:)/gi), &quot;RegExps with equivalent patterns and different flags are not equal&quot;);
    ok(!_.isEqual(/Moe/gim, /Curly/gim), &quot;RegExps with different patterns and equivalent flags are not equal&quot;);
    ok(!_.isEqual(/(?:)/gi, /(?:)/g), &quot;Commutative equality is implemented for RegExps&quot;);
    ok(!_.isEqual(/Curly/g, {source: &quot;Larry&quot;, global: true, ignoreCase: false, multiline: false}), &quot;RegExps and RegExp-like objects are not equal&quot;);

    // Empty arrays, array-like objects, and object literals.
    ok(_.isEqual({}, {}), &quot;Empty object literals are equal&quot;);
    ok(_.isEqual([], []), &quot;Empty array literals are equal&quot;);
    ok(_.isEqual([{}], [{}]), &quot;Empty nested arrays and objects are equal&quot;);
    ok(!_.isEqual({length: 0}, []), &quot;Array-like objects and arrays are not equal.&quot;);
    ok(!_.isEqual([], {length: 0}), &quot;Commutative equality is implemented for array-like objects&quot;);

    ok(!_.isEqual({}, []), &quot;Object literals and array literals are not equal&quot;);
    ok(!_.isEqual([], {}), &quot;Commutative equality is implemented for objects and arrays&quot;);

    // Arrays with primitive and object values.
    ok(_.isEqual([1, &quot;Larry&quot;, true], [1, &quot;Larry&quot;, true]), &quot;Arrays containing identical primitives are equal&quot;);
    ok(_.isEqual([(/Moe/g), new Date(2009, 9, 25)], [(/Moe/g), new Date(2009, 9, 25)]), &quot;Arrays containing equivalent elements are equal&quot;);

    // Multi-dimensional arrays.
    var a = [new Number(47), false, &quot;Larry&quot;, /Moe/, new Date(2009, 11, 13), [&#039;running&#039;, &#039;biking&#039;, new String(&#039;programming&#039;)], {a: 47}];
    var b = [new Number(47), false, &quot;Larry&quot;, /Moe/, new Date(2009, 11, 13), [&#039;running&#039;, &#039;biking&#039;, new String(&#039;programming&#039;)], {a: 47}];
    ok(_.isEqual(a, b), &quot;Arrays containing nested arrays and objects are recursively compared&quot;);

    // Overwrite the methods defined in ES 5.1 section 15.4.4.
    a.forEach = a.map = a.filter = a.every = a.indexOf = a.lastIndexOf = a.some = a.reduce = a.reduceRight = null;
    b.join = b.pop = b.reverse = b.shift = b.slice = b.splice = b.concat = b.sort = b.unshift = null;

    // Array elements and properties.
    ok(_.isEqual(a, b), &quot;Arrays containing equivalent elements and different non-numeric properties are equal&quot;);
    a.push(&quot;White Rocks&quot;);
    ok(!_.isEqual(a, b), &quot;Arrays of different lengths are not equal&quot;);
    a.push(&quot;East Boulder&quot;);
    b.push(&quot;Gunbarrel Ranch&quot;, &quot;Teller Farm&quot;);
    ok(!_.isEqual(a, b), &quot;Arrays of identical lengths containing different elements are not equal&quot;);

    // Sparse arrays.
    ok(_.isEqual(Array(3), Array(3)), &quot;Sparse arrays of identical lengths are equal&quot;);
    ok(!_.isEqual(Array(3), Array(6)), &quot;Sparse arrays of different lengths are not equal when both are empty&quot;);

    // Simple objects.
    ok(_.isEqual({a: &quot;Curly&quot;, b: 1, c: true}, {a: &quot;Curly&quot;, b: 1, c: true}), &quot;Objects containing identical primitives are equal&quot;);
    ok(_.isEqual({a: /Curly/g, b: new Date(2009, 11, 13)}, {a: /Curly/g, b: new Date(2009, 11, 13)}), &quot;Objects containing equivalent members are equal&quot;);
    ok(!_.isEqual({a: 63, b: 75}, {a: 61, b: 55}), &quot;Objects of identical sizes with different values are not equal&quot;);
    ok(!_.isEqual({a: 63, b: 75}, {a: 61, c: 55}), &quot;Objects of identical sizes with different property names are not equal&quot;);
    ok(!_.isEqual({a: 1, b: 2}, {a: 1}), &quot;Objects of different sizes are not equal&quot;);
    ok(!_.isEqual({a: 1}, {a: 1, b: 2}), &quot;Commutative equality is implemented for objects&quot;);
    ok(!_.isEqual({x: 1, y: undefined}, {x: 1, z: 2}), &quot;Objects with identical keys and different values are not equivalent&quot;);

    // `A` contains nested objects and arrays.
    a = {
      name: new String(&quot;Moe Howard&quot;),
      age: new Number(77),
      stooge: true,
      hobbies: [&quot;acting&quot;],
      film: {
        name: &quot;Sing a Song of Six Pants&quot;,
        release: new Date(1947, 9, 30),
        stars: [new String(&quot;Larry Fine&quot;), &quot;Shemp Howard&quot;],
        minutes: new Number(16),
        seconds: 54
      }
    };

    // `B` contains equivalent nested objects and arrays.
    b = {
      name: new String(&quot;Moe Howard&quot;),
      age: new Number(77),
      stooge: true,
      hobbies: [&quot;acting&quot;],
      film: {
        name: &quot;Sing a Song of Six Pants&quot;,
        release: new Date(1947, 9, 30),
        stars: [new String(&quot;Larry Fine&quot;), &quot;Shemp Howard&quot;],
        minutes: new Number(16),
        seconds: 54
      }
    };
    ok(_.isEqual(a, b), &quot;Objects with nested equivalent members are recursively compared&quot;);

    // Instances.
    ok(_.isEqual(new First, new First), &quot;Object instances are equal&quot;);
    ok(!_.isEqual(new First, new Second), &quot;Objects with different constructors and identical own properties are not equal&quot;);
    ok(!_.isEqual({value: 1}, new First), &quot;Object instances and objects sharing equivalent properties are not equal&quot;);
    ok(!_.isEqual({value: 2}, new Second), &quot;The prototype chain of objects should not be examined&quot;);

    // Circular Arrays.
    (a = []).push(a);
    (b = []).push(b);
    ok(_.isEqual(a, b), &quot;Arrays containing circular references are equal&quot;);
    a.push(new String(&quot;Larry&quot;));
    b.push(new String(&quot;Larry&quot;));
    ok(_.isEqual(a, b), &quot;Arrays containing circular references and equivalent properties are equal&quot;);
    a.push(&quot;Shemp&quot;);
    b.push(&quot;Curly&quot;);
    ok(!_.isEqual(a, b), &quot;Arrays containing circular references and different properties are not equal&quot;);

    // More circular arrays #767.
    a = [&quot;everything is checked but&quot;, &quot;this&quot;, &quot;is not&quot;];
    a[1] = a;
    b = [&quot;everything is checked but&quot;, [&quot;this&quot;, &quot;array&quot;], &quot;is not&quot;];
    ok(!_.isEqual(a, b), &quot;Comparison of circular references with non-circular references are not equal&quot;);

    // Circular Objects.
    a = {abc: null};
    b = {abc: null};
    a.abc = a;
    b.abc = b;
    ok(_.isEqual(a, b), &quot;Objects containing circular references are equal&quot;);
    a.def = 75;
    b.def = 75;
    ok(_.isEqual(a, b), &quot;Objects containing circular references and equivalent properties are equal&quot;);
    a.def = new Number(75);
    b.def = new Number(63);
    ok(!_.isEqual(a, b), &quot;Objects containing circular references and different properties are not equal&quot;);

    // More circular objects #767.
    a = {everything: &quot;is checked&quot;, but: &quot;this&quot;, is: &quot;not&quot;};
    a.but = a;
    b = {everything: &quot;is checked&quot;, but: {that:&quot;object&quot;}, is: &quot;not&quot;};
    ok(!_.isEqual(a, b), &quot;Comparison of circular references with non-circular object references are not equal&quot;);

    // Cyclic Structures.
    a = [{abc: null}];
    b = [{abc: null}];
    (a[0].abc = a).push(a);
    (b[0].abc = b).push(b);
    ok(_.isEqual(a, b), &quot;Cyclic structures are equal&quot;);
    a[0].def = &quot;Larry&quot;;
    b[0].def = &quot;Larry&quot;;
    ok(_.isEqual(a, b), &quot;Cyclic structures containing equivalent properties are equal&quot;);
    a[0].def = new String(&quot;Larry&quot;);
    b[0].def = new String(&quot;Curly&quot;);
    ok(!_.isEqual(a, b), &quot;Cyclic structures containing different properties are not equal&quot;);

    // Complex Circular References.
    a = {foo: {b: {foo: {c: {foo: null}}}}};
    b = {foo: {b: {foo: {c: {foo: null}}}}};
    a.foo.b.foo.c.foo = a;
    b.foo.b.foo.c.foo = b;
    ok(_.isEqual(a, b), &quot;Cyclic structures with nested and identically-named properties are equal&quot;);

    // Chaining.
    ok(!_.isEqual(_({x: 1, y: undefined}).chain(), _({x: 1, z: 2}).chain()), &#039;Chained objects containing different values are not equal&#039;);
    equal(_({x: 1, y: 2}).chain().isEqual(_({x: 1, y: 2}).chain()).value(), true, &#039;`isEqual` can be chained&#039;);

    // Custom `isEqual` methods.
    var isEqualObj = {isEqual: function (o) { return o.isEqual == this.isEqual; }, unique: {}};
    var isEqualObjClone = {isEqual: isEqualObj.isEqual, unique: {}};

    ok(_.isEqual(isEqualObj, isEqualObjClone), &#039;Both objects implement identical `isEqual` methods&#039;);
    ok(_.isEqual(isEqualObjClone, isEqualObj), &#039;Commutative equality is implemented for objects with custom `isEqual` methods&#039;);
    ok(!_.isEqual(isEqualObj, {}), &#039;Objects that do not implement equivalent `isEqual` methods are not equal&#039;);
    ok(!_.isEqual({}, isEqualObj), &#039;Commutative equality is implemented for objects with different `isEqual` methods&#039;);

    // Objects from another frame.
    ok(_.isEqual({}, iObject));
  });

  test(&quot;isEmpty&quot;, function() {
    ok(!_([1]).isEmpty(), &#039;[1] is not empty&#039;);
    ok(_.isEmpty([]), &#039;[] is empty&#039;);
    ok(!_.isEmpty({one : 1}), &#039;{one : 1} is not empty&#039;);
    ok(_.isEmpty({}), &#039;{} is empty&#039;);
    ok(_.isEmpty(new RegExp(&#039;&#039;)), &#039;objects with prototype properties are empty&#039;);
    ok(_.isEmpty(null), &#039;null is empty&#039;);
    ok(_.isEmpty(), &#039;undefined is empty&#039;);
    ok(_.isEmpty(&#039;&#039;), &#039;the empty string is empty&#039;);
    ok(!_.isEmpty(&#039;moe&#039;), &#039;but other strings are not&#039;);

    var obj = {one : 1};
    delete obj.one;
    ok(_.isEmpty(obj), &#039;deleting all the keys from an object empties it&#039;);
  });

  // Setup remote variables for iFrame tests.
  var iframe = document.createElement(&#039;iframe&#039;);
  jQuery(iframe).appendTo(document.body);
  var iDoc = iframe.contentDocument || iframe.contentWindow.document;
  iDoc.write(
    &quot;&lt;script&gt;\
      parent.iElement   = document.createElement(&#039;div&#039;);\
      parent.iArguments = (function(){ return arguments; })(1, 2, 3);\
      parent.iArray     = [1, 2, 3];\
      parent.iString    = new String(&#039;hello&#039;);\
      parent.iNumber    = new Number(100);\
      parent.iFunction  = (function(){});\
      parent.iDate      = new Date();\
      parent.iRegExp    = /hi/;\
      parent.iNaN       = NaN;\
      parent.iNull      = null;\
      parent.iBoolean   = new Boolean(false);\
      parent.iUndefined = undefined;\
      parent.iObject     = {};\
    &lt;/script&gt;&quot;
  );
  iDoc.close();

  test(&quot;isElement&quot;, function() {
    ok(!_.isElement(&#039;div&#039;), &#039;strings are not dom elements&#039;);
    ok(_.isElement($(&#039;html&#039;)[0]), &#039;the html tag is a DOM element&#039;);
    ok(_.isElement(iElement), &#039;even from another frame&#039;);
  });

  test(&quot;isArguments&quot;, function() {
    var args = (function(){ return arguments; })(1, 2, 3);
    ok(!_.isArguments(&#039;string&#039;), &#039;a string is not an arguments object&#039;);
    ok(!_.isArguments(_.isArguments), &#039;a function is not an arguments object&#039;);
    ok(_.isArguments(args), &#039;but the arguments object is an arguments object&#039;);
    ok(!_.isArguments(_.toArray(args)), &#039;but not when it\&#039;s converted into an array&#039;);
    ok(!_.isArguments([1,2,3]), &#039;and not vanilla arrays.&#039;);
    ok(_.isArguments(iArguments), &#039;even from another frame&#039;);
  });

  test(&quot;isObject&quot;, function() {
    ok(_.isObject(arguments), &#039;the arguments object is object&#039;);
    ok(_.isObject([1, 2, 3]), &#039;and arrays&#039;);
    ok(_.isObject($(&#039;html&#039;)[0]), &#039;and DOM element&#039;);
    ok(_.isObject(iElement), &#039;even from another frame&#039;);
    ok(_.isObject(function () {}), &#039;and functions&#039;);
    ok(_.isObject(iFunction), &#039;even from another frame&#039;);
    ok(!_.isObject(null), &#039;but not null&#039;);
    ok(!_.isObject(undefined), &#039;and not undefined&#039;);
    ok(!_.isObject(&#039;string&#039;), &#039;and not string&#039;);
    ok(!_.isObject(12), &#039;and not number&#039;);
    ok(!_.isObject(true), &#039;and not boolean&#039;);
    ok(_.isObject(new String(&#039;string&#039;)), &#039;but new String()&#039;);
  });

  test(&quot;isArray&quot;, function() {
    ok(!_.isArray(arguments), &#039;the arguments object is not an array&#039;);
    ok(_.isArray([1, 2, 3]), &#039;but arrays are&#039;);
    ok(_.isArray(iArray), &#039;even from another frame&#039;);
  });

  test(&quot;isString&quot;, function() {
    ok(!_.isString(document.body), &#039;the document body is not a string&#039;);
    ok(_.isString([1, 2, 3].join(&#039;, &#039;)), &#039;but strings are&#039;);
    ok(_.isString(iString), &#039;even from another frame&#039;);
  });

  test(&quot;isNumber&quot;, function() {
    ok(!_.isNumber(&#039;string&#039;), &#039;a string is not a number&#039;);
    ok(!_.isNumber(arguments), &#039;the arguments object is not a number&#039;);
    ok(!_.isNumber(undefined), &#039;undefined is not a number&#039;);
    ok(_.isNumber(3 * 4 - 7 / 10), &#039;but numbers are&#039;);
    ok(_.isNumber(NaN), &#039;NaN *is* a number&#039;);
    ok(_.isNumber(Infinity), &#039;Infinity is a number&#039;);
    ok(_.isNumber(iNumber), &#039;even from another frame&#039;);
    ok(!_.isNumber(&#039;1&#039;), &#039;numeric strings are not numbers&#039;);
  });

  test(&quot;isBoolean&quot;, function() {
    ok(!_.isBoolean(2), &#039;a number is not a boolean&#039;);
    ok(!_.isBoolean(&quot;string&quot;), &#039;a string is not a boolean&#039;);
    ok(!_.isBoolean(&quot;false&quot;), &#039;the string &quot;false&quot; is not a boolean&#039;);
    ok(!_.isBoolean(&quot;true&quot;), &#039;the string &quot;true&quot; is not a boolean&#039;);
    ok(!_.isBoolean(arguments), &#039;the arguments object is not a boolean&#039;);
    ok(!_.isBoolean(undefined), &#039;undefined is not a boolean&#039;);
    ok(!_.isBoolean(NaN), &#039;NaN is not a boolean&#039;);
    ok(!_.isBoolean(null), &#039;null is not a boolean&#039;);
    ok(_.isBoolean(true), &#039;but true is&#039;);
    ok(_.isBoolean(false), &#039;and so is false&#039;);
    ok(_.isBoolean(iBoolean), &#039;even from another frame&#039;);
  });

  test(&quot;isFunction&quot;, function() {
    ok(!_.isFunction([1, 2, 3]), &#039;arrays are not functions&#039;);
    ok(!_.isFunction(&#039;moe&#039;), &#039;strings are not functions&#039;);
    ok(_.isFunction(_.isFunction), &#039;but functions are&#039;);
    ok(_.isFunction(iFunction), &#039;even from another frame&#039;);
  });

  test(&quot;isDate&quot;, function() {
    ok(!_.isDate(100), &#039;numbers are not dates&#039;);
    ok(!_.isDate({}), &#039;objects are not dates&#039;);
    ok(_.isDate(new Date()), &#039;but dates are&#039;);
    ok(_.isDate(iDate), &#039;even from another frame&#039;);
  });

  test(&quot;isRegExp&quot;, function() {
    ok(!_.isRegExp(_.identity), &#039;functions are not RegExps&#039;);
    ok(_.isRegExp(/identity/), &#039;but RegExps are&#039;);
    ok(_.isRegExp(iRegExp), &#039;even from another frame&#039;);
  });

  test(&quot;isFinite&quot;, function() {
    ok(!_.isFinite(undefined), &#039;undefined is not Finite&#039;);
    ok(!_.isFinite(null), &#039;null is not Finite&#039;);
    ok(!_.isFinite(NaN), &#039;NaN is not Finite&#039;);
    ok(!_.isFinite(Infinity), &#039;Infinity is not Finite&#039;);
    ok(!_.isFinite(-Infinity), &#039;-Infinity is not Finite&#039;);
    ok(!_.isFinite(&#039;12&#039;), &#039;Strings are not numbers&#039;);
    var obj = new Number(5);
    ok(_.isFinite(obj), &#039;Number instances can be finite&#039;);
    ok(_.isFinite(0), &#039;0 is Finite&#039;);
    ok(_.isFinite(123), &#039;Ints are Finite&#039;);
    ok(_.isFinite(-12.44), &#039;Floats are Finite&#039;);
  });

  test(&quot;isNaN&quot;, function() {
    ok(!_.isNaN(undefined), &#039;undefined is not NaN&#039;);
    ok(!_.isNaN(null), &#039;null is not NaN&#039;);
    ok(!_.isNaN(0), &#039;0 is not NaN&#039;);
    ok(_.isNaN(NaN), &#039;but NaN is&#039;);
    ok(_.isNaN(iNaN), &#039;even from another frame&#039;);
    ok(_.isNaN(new Number(NaN)), &#039;wrapped NaN is still NaN&#039;);
  });

  test(&quot;isNull&quot;, function() {
    ok(!_.isNull(undefined), &#039;undefined is not null&#039;);
    ok(!_.isNull(NaN), &#039;NaN is not null&#039;);
    ok(_.isNull(null), &#039;but null is&#039;);
    ok(_.isNull(iNull), &#039;even from another frame&#039;);
  });

  test(&quot;isUndefined&quot;, function() {
    ok(!_.isUndefined(1), &#039;numbers are defined&#039;);
    ok(!_.isUndefined(null), &#039;null is defined&#039;);
    ok(!_.isUndefined(false), &#039;false is defined&#039;);
    ok(!_.isUndefined(NaN), &#039;NaN is defined&#039;);
    ok(_.isUndefined(), &#039;nothing is undefined&#039;);
    ok(_.isUndefined(undefined), &#039;undefined is undefined&#039;);
    ok(_.isUndefined(iUndefined), &#039;even from another frame&#039;);
  });

  if (window.ActiveXObject) {
    test(&quot;IE host objects&quot;, function() {
      var xml = new ActiveXObject(&quot;Msxml2.DOMDocument.3.0&quot;);
      ok(!_.isNumber(xml));
      ok(!_.isBoolean(xml));
      ok(!_.isNaN(xml));
      ok(!_.isFunction(xml));
      ok(!_.isNull(xml));
      ok(!_.isUndefined(xml));
    });
  }

  test(&quot;tap&quot;, function() {
    var intercepted = null;
    var interceptor = function(obj) { intercepted = obj; };
    var returned = _.tap(1, interceptor);
    equal(intercepted, 1, &quot;passes tapped object to interceptor&quot;);
    equal(returned, 1, &quot;returns tapped object&quot;);

    returned = _([1,2,3]).chain().
      map(function(n){ return n * 2; }).
      max().
      tap(interceptor).
      value();
    ok(returned == 6 &amp;&amp; intercepted == 6, &#039;can use tapped objects in a chain&#039;);
  });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
