<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/grunt-legacy-util/test/index.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/grunt-legacy-util/test/index.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">67.18</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">554</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">65.63</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">8.33</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&#039;use strict&#039;;

var util = require(&#039;../&#039;);

var fs = require(&#039;fs&#039;);
var path = require(&#039;path&#039;);

var Tempfile = require(&#039;temporary/lib/file&#039;);

exports[&#039;util.callbackify&#039;] = {
  &#039;return&#039;: function(test) {
    test.expect(1);
    // This function returns a value.
    function add(a, b) {
      return a + b;
    }
    util.callbackify(add)(1, 2, function(result) {
      test.equal(result, 3, &#039;should be the correct result.&#039;);
      test.done();
    });
  },
  &#039;callback (sync)&#039;: function(test) {
    test.expect(1);
    // This function accepts a callback which it calls synchronously.
    function add(a, b, done) {
      done(a + b);
    }
    util.callbackify(add)(1, 2, function(result) {
      test.equal(result, 3, &#039;should be the correct result.&#039;);
      test.done();
    });
  },
  &#039;callback (async)&#039;: function(test) {
    test.expect(1);
    // This function accepts a callback which it calls asynchronously.
    function add(a, b, done) {
      setTimeout(done.bind(null, a + b), 0);
    }
    util.callbackify(add)(1, 2, function(result) {
      test.equal(result, 3, &#039;should be the correct result.&#039;);
      test.done();
    });
  }
};

exports[&#039;util&#039;] = {
  &#039;error&#039;: function(test) {
    test.expect(9);
    var origError = new Error(&#039;Original error.&#039;);

    var err = util.error(&#039;Test message.&#039;);
    test.ok(err instanceof Error, &#039;Should be an Error.&#039;);
    test.equal(err.name, &#039;Error&#039;, &#039;Should be an Error.&#039;);
    test.equal(err.message, &#039;Test message.&#039;, &#039;Should have the correct message.&#039;);

    err = util.error(&#039;Test message.&#039;, origError);
    test.ok(err instanceof Error, &#039;Should be an Error.&#039;);
    test.equal(err.name, &#039;Error&#039;, &#039;Should be an Error.&#039;);
    test.equal(err.message, &#039;Test message.&#039;, &#039;Should have the correct message.&#039;);
    test.equal(err.origError, origError, &#039;Should reflect the original error.&#039;);

    var newError = new Error(&#039;Test message.&#039;);
    err = util.error(newError, origError);
    test.equal(err, newError, &#039;Should be the passed-in Error.&#039;);
    test.equal(err.origError, origError, &#039;Should reflect the original error.&#039;);
    test.done();
  },
  &#039;linefeed&#039;: function(test) {
    test.expect(1);
    if (process.platform === &#039;win32&#039;) {
      test.equal(util.linefeed, &#039;\r\n&#039;, &#039;linefeed should be operating-system appropriate.&#039;);
    } else {
      test.equal(util.linefeed, &#039;\n&#039;, &#039;linefeed should be operating-system appropriate.&#039;);
    }
    test.done();
  },
  &#039;normalizelf&#039;: function(test) {
    test.expect(1);
    if (process.platform === &#039;win32&#039;) {
      test.equal(util.normalizelf(&#039;foo\nbar\r\nbaz\r\n\r\nqux\n\nquux&#039;), &#039;foo\r\nbar\r\nbaz\r\n\r\nqux\r\n\r\nquux&#039;, &#039;linefeeds should be normalized&#039;);
    } else {
      test.equal(util.normalizelf(&#039;foo\nbar\r\nbaz\r\n\r\nqux\n\nquux&#039;), &#039;foo\nbar\nbaz\n\nqux\n\nquux&#039;, &#039;linefeeds should be normalized&#039;);
    }
    test.done();
  }
};

exports[&#039;util.spawn&#039;] = {
  setUp: function(done) {
    this.script = path.resolve(&#039;test/fixtures/spawn.js&#039;);
    done();
  },
  &#039;exit code 0&#039;: function(test) {
    test.expect(6);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script, 0 ],
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, &#039;stdout&#039;);
      test.equals(result.stderr, &#039;stderr&#039;);
      test.equals(result.code, 0);
      test.equals(String(result), &#039;stdout&#039;);
      test.done();
    });
  },
  &#039;exit code 0, fallback&#039;: function(test) {
    test.expect(6);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script, 0 ],
      fallback: &#039;ignored if exit code is 0&#039;
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, &#039;stdout&#039;);
      test.equals(result.stderr, &#039;stderr&#039;);
      test.equals(result.code, 0);
      test.equals(String(result), &#039;stdout&#039;);
      test.done();
    });
  },
  &#039;non-zero exit code&#039;: function(test) {
    test.expect(7);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script, 123 ],
    }, function(err, result, code) {
      test.ok(err instanceof Error);
      test.equals(err.message, &#039;stderr&#039;);
      test.equals(code, 123);
      test.equals(result.stdout, &#039;stdout&#039;);
      test.equals(result.stderr, &#039;stderr&#039;);
      test.equals(result.code, 123);
      test.equals(String(result), &#039;stderr&#039;);
      test.done();
    });
  },
  &#039;non-zero exit code, fallback&#039;: function(test) {
    test.expect(6);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script, 123 ],
      fallback: &#039;custom fallback&#039;
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 123);
      test.equals(result.stdout, &#039;stdout&#039;);
      test.equals(result.stderr, &#039;stderr&#039;);
      test.equals(result.code, 123);
      test.equals(String(result), &#039;custom fallback&#039;);
      test.done();
    });
  },
  &#039;cmd not found&#039;: function(test) {
    test.expect(3);
    util.spawn({
      cmd: &#039;nodewtfmisspelled&#039;,
    }, function(err, result, code) {
      test.ok(err instanceof Error);
      test.equals(code, 127);
      test.equals(result.code, 127);
      test.done();
    });
  },
  &#039;cmd not found, fallback&#039;: function(test) {
    test.expect(4);
    util.spawn({
      cmd: &#039;nodewtfmisspelled&#039;,
      fallback: &#039;use a fallback or good luck&#039;
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 127);
      test.equals(result.code, 127);
      test.equals(String(result), &#039;use a fallback or good luck&#039;);
      test.done();
    });
  },
  &#039;cmd not in path&#039;: function(test) {
    test.expect(6);
    var win32 = process.platform === &#039;win32&#039;;
    util.spawn({
      cmd: &#039;test\\fixtures\\exec&#039; + (win32 ? &#039;.cmd&#039; : &#039;.sh&#039;),
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, &#039;done&#039;);
      test.equals(result.stderr, &#039;&#039;);
      test.equals(result.code, 0);
      test.equals(String(result), &#039;done&#039;);
      test.done();
    });
  },
  &#039;cmd not in path (with cwd)&#039;: function(test) {
    test.expect(6);
    var win32 = process.platform === &#039;win32&#039;;
    util.spawn({
      cmd: &#039;./exec&#039; + (win32 ? &#039;.cmd&#039; : &#039;.sh&#039;),
      opts: {cwd: &#039;test/fixtures&#039;},
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, &#039;done&#039;);
      test.equals(result.stderr, &#039;&#039;);
      test.equals(result.code, 0);
      test.equals(String(result), &#039;done&#039;);
      test.done();
    });
  },
  &#039;grunt&#039;: function(test) {
    test.expect(3);
    util.spawn({
      grunt: true,
      args: [ &#039;--gruntfile&#039;, &#039;test/fixtures/Gruntfile-print-text.js&#039;, &#039;print:foo&#039; ],
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.ok(/^OUTPUT: foo/m.test(result.stdout), &#039;stdout should contain output indicating the grunt task was run.&#039;);
      test.done();
    });
  },
  &#039;grunt (with cwd)&#039;: function(test) {
    test.expect(3);
    util.spawn({
      grunt: true,
      args: [ &#039;--gruntfile&#039;, &#039;Gruntfile-print-text.js&#039;, &#039;print:foo&#039; ],
      opts: {cwd: &#039;test/fixtures&#039;},
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.ok(/^OUTPUT: foo/m.test(result.stdout), &#039;stdout should contain output indicating the grunt task was run.&#039;);
      test.done();
    });
  },
  &#039;grunt passes execArgv&#039;: function(test) {
    test.expect(3);
    util.spawn({
      cmd: process.execPath,
      args: [ &#039;--harmony&#039;, process.argv[1], &#039;--gruntfile&#039;, &#039;test/fixtures/Gruntfile-execArgv.js&#039;],
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.ok(/^OUTPUT: --harmony/m.test(result.stdout), &#039;stdout should contain passed-through process.execArgv.&#039;);
      test.done();
    });
  },
  &#039;grunt result.toString() with error&#039;: function(test) {
    // grunt.log.error uses standard out, to be fixed in 0.5.
    test.expect(4);
    util.spawn({
      grunt: true,
      args: [ &#039;nonexistentTask&#039; ]
    }, function(err, result, code) {
      test.ok(err instanceof Error, &#039;Should be an Error.&#039;);
      test.equal(err.name, &#039;Error&#039;, &#039;Should be an Error.&#039;);
      test.equals(code, 3);
      test.ok(/Warning: Task &quot;nonexistentTask&quot; not found./m.test(result.toString()), &#039;stdout should contain output indicating the grunt task was (attempted to be) run.&#039;);
      test.done();
    });
  },
  &#039;custom stdio stream(s)&#039;: function(test) {
    test.expect(6);
    var stdoutFile = new Tempfile();
    var stderrFile = new Tempfile();
    var stdout = fs.openSync(stdoutFile.path, &#039;a&#039;);
    var stderr = fs.openSync(stderrFile.path, &#039;a&#039;);
    var child = util.spawn({
      cmd: process.execPath,
      args: [ this.script, 0 ],
      opts: {stdio: [null, stdout, stderr]},
    }, function(err, result, code) {
      test.equals(code, 0);
      test.equals(String(fs.readFileSync(stdoutFile.path)), &#039;stdout\n&#039;, &#039;Child process stdout should have been captured via custom stream.&#039;);
      test.equals(String(fs.readFileSync(stderrFile.path)), &#039;stderr\n&#039;, &#039;Child process stderr should have been captured via custom stream.&#039;);
      stdoutFile.unlinkSync();
      stderrFile.unlinkSync();
      test.equals(result.stdout, &#039;&#039;, &#039;Nothing will be passed to the stdout string when spawn stdio is a custom stream.&#039;);
      test.done();
    });
    test.ok(!child.stdout, &#039;child should not have a stdout property.&#039;);
    test.ok(!child.stderr, &#039;child should not have a stderr property.&#039;);
  },
};

exports[&#039;util.spawn.multibyte&#039;] = {
  setUp: function(done) {
    this.script = path.resolve(&#039;test/fixtures/spawn-multibyte.js&#039;);
    done();
  },
  &#039;partial stdout&#039;: function(test) {
    test.expect(4);
    util.spawn({
      cmd: process.execPath,
      args: [ this.script ],
    }, function(err, result, code) {
      test.equals(err, null);
      test.equals(code, 0);
      test.equals(result.stdout, &#039;こんにちは&#039;);
      test.equals(result.stderr, &#039;こんにちは&#039;);
      test.done();
    });
  }
};

exports[&#039;util.underscore.string&#039;] = function(test) {
  test.expect(4);
  test.equals(util._.trim(&#039;    foo     &#039;), &#039;foo&#039;, &#039;Should have trimmed the string.&#039;);
  test.equals(util._.capitalize(&#039;foo&#039;), &#039;Foo&#039;, &#039;Should have capitalized the first letter.&#039;);
  test.equals(util._.words(&#039;one two three&#039;).length, 3, &#039;Should have counted three words.&#039;);
  test.ok(util._.isBlank(&#039; &#039;), &#039;Should be blank.&#039;);
  test.done();
};

function getType(val) {
  if (Buffer.isBuffer(val)) { return &#039;buffer&#039;; }
  return Object.prototype.toString.call(val).slice(8, -1).toLowerCase();
}

exports[&#039;util.recurse&#039;] = {
  setUp: function(done) {
    this.typeValue = function(value) {
      return {
        value: value,
        type: getType(value),
      };
    };
    done();
  },
  &#039;primitives&#039;: function(test) {
    test.expect(1);
    var actual = util.recurse({
      bool: true,
      num: 1,
      str: &#039;foo&#039;,
      nul: null,
      undef: undefined,
    }, this.typeValue);
    var expected = {
      bool: {type: &#039;boolean&#039;, value: true},
      num: {type: &#039;number&#039;, value: 1},
      str: {type: &#039;string&#039;, value: &#039;foo&#039;},
      nul: {type: &#039;null&#039;, value: null},
      undef: {type: &#039;undefined&#039;, value: undefined},
    };
    test.deepEqual(actual, expected, &#039;Should process primitive values.&#039;);
    test.done();
  },
  &#039;array&#039;: function(test) {
    test.expect(1);
    var actual = util.recurse({
      arr: [
        true,
        1,
        &#039;foo&#039;,
        null,
        undefined,
        [
          true,
          1,
          &#039;foo&#039;,
          null,
          undefined,
        ],
      ],
    }, this.typeValue);
    var expected = {
      arr: [
        {type: &#039;boolean&#039;, value: true},
        {type: &#039;number&#039;, value: 1},
        {type: &#039;string&#039;, value: &#039;foo&#039;},
        {type: &#039;null&#039;, value: null},
        {type: &#039;undefined&#039;, value: undefined},
        [
          {type: &#039;boolean&#039;, value: true},
          {type: &#039;number&#039;, value: 1},
          {type: &#039;string&#039;, value: &#039;foo&#039;},
          {type: &#039;null&#039;, value: null},
          {type: &#039;undefined&#039;, value: undefined},
        ],
      ],
    };
    test.deepEqual(actual, expected, &#039;Should recurse over arrays.&#039;);
    test.done();
  },
  &#039;object&#039;: function(test) {
    test.expect(1);
    var actual = util.recurse({
      obj: {
        bool: true,
        num: 1,
        str: &#039;foo&#039;,
        nul: null,
        undef: undefined,
        obj: {
          bool: true,
          num: 1,
          str: &#039;foo&#039;,
          nul: null,
          undef: undefined,
        },
      },
    }, this.typeValue);
    var expected = {
      obj: {
        bool: {type: &#039;boolean&#039;, value: true},
        num: {type: &#039;number&#039;, value: 1},
        str: {type: &#039;string&#039;, value: &#039;foo&#039;},
        nul: {type: &#039;null&#039;, value: null},
        undef: {type: &#039;undefined&#039;, value: undefined},
        obj: {
          bool: {type: &#039;boolean&#039;, value: true},
          num: {type: &#039;number&#039;, value: 1},
          str: {type: &#039;string&#039;, value: &#039;foo&#039;},
          nul: {type: &#039;null&#039;, value: null},
          undef: {type: &#039;undefined&#039;, value: undefined},
        },
      },
    };
    test.deepEqual(actual, expected, &#039;Should recurse over objects.&#039;);
    test.done();
  },
  &#039;array in object&#039;: function(test) {
    test.expect(1);
    var actual = util.recurse({
      obj: {
        arr: [
          true,
          1,
          &#039;foo&#039;,
          null,
          undefined,
        ],
      },
    }, this.typeValue);
    var expected = {
      obj: {
        arr: [
          {type: &#039;boolean&#039;, value: true},
          {type: &#039;number&#039;, value: 1},
          {type: &#039;string&#039;, value: &#039;foo&#039;},
          {type: &#039;null&#039;, value: null},
          {type: &#039;undefined&#039;, value: undefined},
        ],
      },
    };
    test.deepEqual(actual, expected, &#039;Should recurse over arrays in objects.&#039;);
    test.done();
  },
  &#039;object in array&#039;: function(test) {
    test.expect(1);
    var actual = util.recurse({
      arr: [
        true,
        {
          num: 1,
          str: &#039;foo&#039;,
        },
        null,
        undefined,
      ],
    }, this.typeValue);
    var expected = {
      arr: [
        {type: &#039;boolean&#039;, value: true},
        {
          num: {type: &#039;number&#039;, value: 1},
          str: {type: &#039;string&#039;, value: &#039;foo&#039;},
        },
        {type: &#039;null&#039;, value: null},
        {type: &#039;undefined&#039;, value: undefined},
      ],
    };
    test.deepEqual(actual, expected, &#039;Should recurse over objects in arrays.&#039;);
    test.done();
  },
  &#039;buffer&#039;: function(test) {
    test.expect(1);
    var actual = util.recurse({
      buf: new Buffer(&#039;buf&#039;),
    }, this.typeValue);
    var expected = {
      buf: {type: &#039;buffer&#039;, value: new Buffer(&#039;buf&#039;)},
    };
    test.deepEqual(actual, expected, &#039;Should not mangle Buffer instances.&#039;);
    test.done();
  },
  &#039;inherited properties&#039;: function(test) {
    test.expect(1);
    var actual = util.recurse({
      obj: Object.create({num: 1}, {
        str: {value: &#039;foo&#039;, enumerable: true},
        ignored: {value: &#039;ignored&#039;, enumerable: false},
      }),
    }, this.typeValue);
    var expected = {
      obj: {
        num: {type: &#039;number&#039;, value: 1},
        str: {type: &#039;string&#039;, value: &#039;foo&#039;},
      }
    };
    test.deepEqual(actual, expected, &#039;Should enumerate inherited object properties.&#039;);
    test.done();
  },
  &#039;circular references&#039;: function(test) {
    test.expect(6);
    function assertErrorWithPath(expectedPath) {
      return function(actual) {
        return actual.path === expectedPath &amp;&amp;
          actual.message === &#039;Circular reference detected (&#039; + expectedPath + &#039;)&#039;;
      };
    }
    test.doesNotThrow(function() {
      var obj = {
        // wat
        a:[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]],
        // does
        b:[[[[],[[[],[[[[],[[[],[[[],[[[],[[[],[[[[],[[]]]]]]]]]]]]]]]]]]]]],
        // it
        c:{d:{e:{f:{g:{h:{i:{j:{k:{l:{m:{n:{o:{p:{q:{r:{s:{}}}}}}}}}}}}}}}}},
        // mean
        t:[{u:[{v:[[[[],[[[],[[[{w:[{x:[[[],[[[{y:[[1]]}]]]]]}]}]]]]]]]]}]}],
      };
      util.recurse(obj, function(v) { return v; });
    }, &#039;Should not throw when no circular reference is detected.&#039;);
    test.throws(function() {
      var obj = {a: 1, b: 2};
      obj.obj = obj;
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath(&#039;.obj&#039;), &#039;Should throw when a circular reference is detected.&#039;);
    test.throws(function() {
      var obj = {a:{&#039;b b&#039;:{&#039;c-c&#039;:{d_d:{e:{f:{g:{h:{i:{j:{k:{l:{}}}}}}}}}}}}};
      obj.a[&#039;b b&#039;][&#039;c-c&#039;].d_d.e.f.g.h.i.j.k.l.obj = obj;
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath(&#039;.a[&quot;b b&quot;][&quot;c-c&quot;].d_d.e.f.g.h.i.j.k.l.obj&#039;), &#039;Should throw when a circular reference is detected.&#039;);
    test.throws(function() {
      var obj = {a: 1, b: 2};
      obj.arr = [1, 2, obj, 3, 4];
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath(&#039;.arr[2]&#039;), &#039;Should throw when a circular reference is detected.&#039;);
    test.throws(function() {
      var obj = {a: 1, b: 2};
      obj.arr = [{a:[1,{b:[2,{c:[3,obj,4]},5]},6]},7];
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath(&#039;.arr[0].a[1].b[1].c[1]&#039;), &#039;Should throw when a circular reference is detected.&#039;);
    test.throws(function() {
      var obj = {a: 1, b: 2};
      obj.arr = [];
      obj.arr.push(0,{a:[1,{b:[2,{c:[3,obj.arr,4]},5]},6]},7);
      util.recurse(obj, function(v) { return v; });
    }, assertErrorWithPath(&#039;.arr[1].a[1].b[1].c[1]&#039;), &#039;Should throw when a circular reference is detected.&#039;);
    test.done();
  },
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
