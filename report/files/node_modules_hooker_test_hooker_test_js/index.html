<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/hooker/test/hooker_test.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/hooker/test/hooker_test.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">71.37</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">434</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">77.00</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.95</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*global require:true */
var hooker = require(&#039;../lib/hooker&#039;);

exports[&#039;hook&#039;] = {
  setUp: function(done) {
    this.order = [];
    this.track = function() {
      [].push.apply(this.order, arguments);
    };

    this.prop = 1;
    this.add = function(a, b) {
      this.track(&quot;add&quot;, this.prop, a, b);
      return this.prop + a + b;
    };

    this.obj = {
      that: this,
      prop: 1,
      add1: function(a, b) {
        this.that.track(&quot;add1&quot;, this.prop, a, b);
        return this.prop + a + b;
      },
      add2: function(a, b) {
        this.that.track(&quot;add2&quot;, this.prop, a, b);
        return this.prop + a + b;
      },
      add3: function(a, b) {
        this.that.track(&quot;add3&quot;, this.prop, a, b);
        return this.prop + a + b;
      }
    };

    done();
  },
  &#039;orig&#039;: function(test) {
    test.expect(1);
    var orig = this.add;
    hooker.hook(this, &quot;add&quot;, function() {});
    test.strictEqual(hooker.orig(this, &quot;add&quot;), orig, &quot;should return a refernce to the original function.&quot;);
    test.done();
  },
  &#039;once&#039;: function(test) {
    test.expect(5);
    var orig = this.add;
    hooker.hook(this, &quot;add&quot;, {
      once: true,
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
      }
    });
    test.strictEqual(this.add(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add&quot;, 1, 2, 3], &quot;functions should execute in-order.&quot;);
    test.strictEqual(this.add, orig, &quot;should automatically unhook when once is specified.&quot;);
    this.order = [];
    test.strictEqual(this.add(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;add&quot;, 1, 2, 3], &quot;only the original function should execute.&quot;);
    test.done();
  },
  &#039;pre-hook (simple syntax)&#039;: function(test) {
    test.expect(3);
    // Pre-hook.
    var result = hooker.hook(this, &quot;add&quot;, function(a, b) {
      // Arguments are passed into pre-hook as specified.
      this.track(&quot;before&quot;, this.prop, a, b);
    });
    test.deepEqual(result, [&quot;add&quot;], &quot;add should have been hooked.&quot;);
    test.strictEqual(this.add(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add&quot;, 1, 2, 3], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre-hook&#039;: function(test) {
    test.expect(3);
    // Pre-hook.
    var result = hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
      }
    });
    test.deepEqual(result, [&quot;add&quot;], &quot;add should have been hooked.&quot;);
    test.strictEqual(this.add(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add&quot;, 1, 2, 3], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;post-hook&#039;: function(test) {
    test.expect(3);
    // Post-hook.
    var result = hooker.hook(this, &quot;add&quot;, {
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.track(&quot;after&quot;, this.prop, a, b, result);
      }
    });
    test.deepEqual(result, [&quot;add&quot;], &quot;add should have been hooked.&quot;);
    test.strictEqual(this.add(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;add&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre- &amp; post-hook&#039;: function(test) {
    test.expect(2);
    // Pre- &amp; post-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
      },
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.track(&quot;after&quot;, this.prop, a, b, result);
      }
    });
    test.strictEqual(this.add(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    test.done();
  },

  &#039;pre-hook, return value override&#039;: function(test) {
    test.expect(2);
    // Pre-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
        // This return value will override the original function&#039;s return value.
        return hooker.override(&quot;b&quot; + this.prop + a + b);
      }
    });
    test.strictEqual(this.add(2, 3), &quot;b123&quot;, &quot;should return the overridden result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add&quot;, 1, 2, 3], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;post-hook, return value override&#039;: function(test) {
    test.expect(2);
    // Post-hook.
    hooker.hook(this, &quot;add&quot;, {
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.track(&quot;after&quot;, this.prop, a, b, result);
        // This return value will override the original function&#039;s return value.
        return hooker.override(&quot;a&quot; + this.prop + a + b + result);
      }
    });
    test.strictEqual(this.add(2, 3), &quot;a1236&quot;, &quot;should return the post-hook overridden result.&quot;);
    test.deepEqual(this.order, [&quot;add&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre- &amp; post-hook, return value override&#039;: function(test) {
    test.expect(2);
    // Pre- &amp; post-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
        // This return value will override the original function&#039;s return value.
        return hooker.override(&quot;b&quot; + this.prop + a + b);
      },
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.track(&quot;after&quot;, this.prop, a, b, result);
        // This return value will override the original function&#039;s return value
        // AND the pre-hook&#039;s return value.
        return hooker.override(&quot;a&quot; + this.prop + a + b + result);
      }
    });
    test.strictEqual(this.add(2, 3), &quot;a1236&quot;, &quot;should return the overridden result, and post-hook result should take precedence over pre-hook result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    test.done();
  },

  &#039;pre-hook, filtering arguments&#039;: function(test) {
    test.expect(2);
    // Pre-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
        // Return hooker.filter(context, arguments) and they will be passed into
        // the original function. The &quot;track&quot; and &quot;order&quot; propterites are just
        // set here for the same of this unit test.
        return hooker.filter({prop: &quot;x&quot;, track: this.track, order: this.order}, [&quot;y&quot;, &quot;z&quot;]);
      }
    });
    test.strictEqual(this.add(2, 3), &quot;xyz&quot;, &quot;should return the original function&#039;s result, given filtered context and arguments.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre- &amp; post-hook, filtering arguments&#039;: function(test) {
    test.expect(2);
    // Pre- &amp; post-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
        // Return hooker.filter(context, arguments) and they will be passed into
        // the original function. The &quot;track&quot; and &quot;order&quot; propterites are just
        // set here for the same of this unit test.
        return hooker.filter({prop: &quot;x&quot;, track: this.track, order: this.order}, [&quot;y&quot;, &quot;z&quot;]);
      },
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.track(&quot;after&quot;, this.prop, a, b, result);
      }
    });
    test.strictEqual(this.add(2, 3), &quot;xyz&quot;, &quot;should return the original function&#039;s result, given filtered context and arguments.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;after&quot;, 1, 2, 3, &quot;xyz&quot;], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre- &amp; post-hook, filtering arguments, return value override&#039;: function(test) {
    test.expect(2);
    // Pre- &amp; post-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
        // Return hooker.filter(context, arguments) and they will be passed into
        // the original function. The &quot;track&quot; and &quot;order&quot; propterites are just
        // set here for the same of this unit test.
        return hooker.filter({prop: &quot;x&quot;, track: this.track, order: this.order}, [&quot;y&quot;, &quot;z&quot;]);
      },
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.track(&quot;after&quot;, this.prop, a, b, result);
        // This return value will override the original function&#039;s return value
        // AND the pre-hook&#039;s return value.
        return hooker.override(&quot;a&quot; + this.prop + a + b + result);
      }
    });
    test.strictEqual(this.add(2, 3), &quot;a123xyz&quot;, &quot;should return the post-hook overridden result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add&quot;, &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;after&quot;, 1, 2, 3, &quot;xyz&quot;], &quot;functions should execute in-order.&quot;);
    test.done();
  },

  &#039;pre-hook, preempt original function&#039;: function(test) {
    test.expect(2);
    // Pre-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
        // Returning hooker.preempt will prevent the original function from being
        // invoked and optionally set a return value.
        return hooker.preempt();
      }
    });
    test.strictEqual(this.add(2, 3), undefined, &quot;should return the value passed to preempt.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre-hook, preempt original function with value&#039;: function(test) {
    test.expect(2);
    // Pre-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
        // Returning hooker.preempt will prevent the original function from being
        // invoked and optionally set a return value.
        return hooker.preempt(9000);
      }
    });
    test.strictEqual(this.add(2, 3), 9000, &quot;should return the value passed to preempt.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre- &amp; post-hook, preempt original function with value&#039;: function(test) {
    test.expect(2);
    // Pre- &amp; post-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
        // Returning hooker.preempt will prevent the original function from being
        // invoked and optionally set a return value.
        return hooker.preempt(9000);
      },
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.track(&quot;after&quot;, this.prop, a, b, result);
      }
    });
    test.strictEqual(this.add(2, 3), 9000, &quot;should return the value passed to preempt.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 9000], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre- &amp; post-hook, preempt original function with value, return value override&#039;: function(test) {
    test.expect(2);
    // Pre- &amp; post-hook.
    hooker.hook(this, &quot;add&quot;, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.track(&quot;before&quot;, this.prop, a, b);
        // Returning hooker.preempt will prevent the original function from being
        // invoked and optionally set a return value.
        return hooker.preempt(9000);
      },
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.track(&quot;after&quot;, this.prop, a, b, result);
        // This return value will override any preempt value set in pre-hook.
        return hooker.override(&quot;a&quot; + this.prop + a + b + result);
      }
    });
    test.strictEqual(this.add(2, 3), &quot;a1239000&quot;, &quot;should return the overridden result, and post-hook result should take precedence over preempt value.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 9000], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre- &amp; post-hook, some properties&#039;: function(test) {
    test.expect(7);
    // Pre- &amp; post-hook.
    var result = hooker.hook(this.obj, [&quot;add1&quot;, &quot;add2&quot;], {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.that.track(&quot;before&quot;, this.prop, a, b);
      },
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.that.track(&quot;after&quot;, this.prop, a, b, result);
      }
    });
    test.deepEqual(result.sort(), [&quot;add1&quot;, &quot;add2&quot;], &quot;both functions should have been hooked.&quot;);
    test.strictEqual(this.obj.add1(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add1&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    this.order = [];
    test.strictEqual(this.obj.add2(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add2&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    this.order = [];
    test.strictEqual(this.obj.add3(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;add3&quot;, 1, 2, 3], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre- &amp; post-hook, all properties&#039;: function(test) {
    test.expect(7);
    // Pre- &amp; post-hook.
    var result = hooker.hook(this.obj, {
      pre: function(a, b) {
        // Arguments are passed into pre-hook as specified.
        this.that.track(&quot;before&quot;, this.prop, a, b);
      },
      post: function(result, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.that.track(&quot;after&quot;, this.prop, a, b, result);
      }
    });
    test.deepEqual(result.sort(), [&quot;add1&quot;, &quot;add2&quot;, &quot;add3&quot;], &quot;all functions should have been hooked.&quot;);
    test.strictEqual(this.obj.add1(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add1&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    this.order = [];
    test.strictEqual(this.obj.add2(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add2&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    this.order = [];
    test.strictEqual(this.obj.add3(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, 2, 3, &quot;add3&quot;, 1, 2, 3, &quot;after&quot;, 1, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;pre- &amp; post-hook, all properties, passName&#039;: function(test) {
    test.expect(6);
    // Pre- &amp; post-hook.
    hooker.hook(this.obj, {
      passName: true,
      pre: function(name, a, b) {
        // Arguments are passed into pre-hook as specified.
        this.that.track(&quot;before&quot;, this.prop, name, a, b);
      },
      post: function(result, name, a, b) {
        // Arguments to post-hook are the original function&#039;s return value,
        // followed by the specified function arguments.
        this.that.track(&quot;after&quot;, this.prop, name, a, b, result);
      }
    });
    test.strictEqual(this.obj.add1(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, &quot;add1&quot;, 2, 3, &quot;add1&quot;, 1, 2, 3, &quot;after&quot;, 1, &quot;add1&quot;, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    this.order = [];
    test.strictEqual(this.obj.add2(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, &quot;add2&quot;, 2, 3, &quot;add2&quot;, 1, 2, 3, &quot;after&quot;, 1, &quot;add2&quot;, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    this.order = [];
    test.strictEqual(this.obj.add3(2, 3), 6, &quot;should return the original function&#039;s result.&quot;);
    test.deepEqual(this.order, [&quot;before&quot;, 1, &quot;add3&quot;, 2, 3, &quot;add3&quot;, 1, 2, 3, &quot;after&quot;, 1, &quot;add3&quot;, 2, 3, 6], &quot;functions should execute in-order.&quot;);
    test.done();
  },
  &#039;unhook one property&#039;: function(test) {
    test.expect(5);
    var orig = this.add;
    hooker.hook(this, &quot;add&quot;, function() {});
    var result = hooker.unhook(this, &quot;add&quot;);
    test.deepEqual(result, [&quot;add&quot;], &quot;one function should have been unhooked.&quot;);
    test.strictEqual(this.add, orig, &quot;should have unhooked, restoring the original function&quot;);
    result = hooker.unhook(this, &quot;add&quot;);
    test.deepEqual(result, [], &quot;nothing should have been unhooked.&quot;);
    test.strictEqual(this.add, orig, &quot;shouldn&#039;t explode if already unhooked&quot;);
    test.strictEqual(this.add.orig, undefined, &quot;original function shouldn&#039;t have an orig property&quot;);
    test.done();
  },
  &#039;unhook some properties&#039;: function(test) {
    test.expect(6);
    var add1 = this.obj.add1;
    var add2 = this.obj.add2;
    hooker.hook(this.obj, [&quot;add1&quot;, &quot;add2&quot;], function() {});
    test.strictEqual(hooker.orig(this.obj, &quot;add1&quot;), add1, &quot;should return a refernce to the original function&quot;);
    test.strictEqual(hooker.orig(this.obj, &quot;add2&quot;), add2, &quot;should return a refernce to the original function&quot;);
    test.strictEqual(hooker.orig(this.obj, &quot;add3&quot;), undefined, &quot;should not have been hooked, so should not have an original function&quot;);
    var result = hooker.unhook(this.obj, [&quot;add1&quot;, &quot;add2&quot;]);
    test.deepEqual(result.sort(), [&quot;add1&quot;, &quot;add2&quot;], &quot;both functions should have been unhooked.&quot;);
    test.strictEqual(this.obj.add1, add1, &quot;should have unhooked, restoring the original function&quot;);
    test.strictEqual(this.obj.add2, add2, &quot;should have unhooked, restoring the original function&quot;);
    test.done();
  },
  &#039;unhook all properties&#039;: function(test) {
    test.expect(7);
    var add1 = this.obj.add1;
    var add2 = this.obj.add2;
    var add3 = this.obj.add3;
    hooker.hook(this.obj, function() {});
    test.strictEqual(hooker.orig(this.obj, &quot;add1&quot;), add1, &quot;should return a refernce to the original function&quot;);
    test.strictEqual(hooker.orig(this.obj, &quot;add2&quot;), add2, &quot;should return a refernce to the original function&quot;);
    test.strictEqual(hooker.orig(this.obj, &quot;add3&quot;), add3, &quot;should return a refernce to the original function&quot;);
    var result = hooker.unhook(this.obj);
    test.deepEqual(result.sort(), [&quot;add1&quot;, &quot;add2&quot;, &quot;add3&quot;], &quot;all functions should have been unhooked.&quot;);
    test.strictEqual(this.obj.add1, add1, &quot;should have unhooked, restoring the original function&quot;);
    test.strictEqual(this.obj.add2, add2, &quot;should have unhooked, restoring the original function&quot;);
    test.strictEqual(this.obj.add3, add3, &quot;should have unhooked, restoring the original function&quot;);
    test.done();
  }
};</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
