<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jshint/node_modules/minimatch/browser.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jshint/node_modules/minimatch/browser.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">57.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1159</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">128.67</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">11.03</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">(function(f){if(typeof exports===&quot;object&quot;&amp;&amp;typeof module!==&quot;undefined&quot;){module.exports=f()}else if(typeof define===&quot;function&quot;&amp;&amp;define.amd){define([],f)}else{var g;if(typeof window!==&quot;undefined&quot;){g=window}else if(typeof global!==&quot;undefined&quot;){g=global}else if(typeof self!==&quot;undefined&quot;){g=self}else{g=this}g.minimatch = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==&quot;function&quot;&amp;&amp;require;if(!u&amp;&amp;a)return a(o,!0);if(i)return i(o,!0);var f=new Error(&quot;Cannot find module &#039;&quot;+o+&quot;&#039;&quot;);throw f.code=&quot;MODULE_NOT_FOUND&quot;,f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==&quot;function&quot;&amp;&amp;require;for(var o=0;o&lt;r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: &#039;/&#039; }
try {
  path = require(&#039;path&#039;)
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require(&#039;brace-expansion&#039;)

// any single thing other than /
// don&#039;t need to escape / when using new RegExp()
var qmark = &#039;[^/]&#039;

// * =&gt; any number of characters
var star = qmark + &#039;*?&#039;

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = &#039;(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?&#039;

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = &#039;(?:(?!(?:\\\/|^)\\.).)*?&#039;

// characters that need to be escaped in RegExp.
var reSpecials = charSet(&#039;().*{}+?[]^$\\!&#039;)

// &quot;abc&quot; -&gt; { a:true, b:true, c:true }
function charSet (s) {
  return s.split(&#039;&#039;).reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== &#039;string&#039;) {
    throw new TypeError(&#039;glob pattern string required&#039;)
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment &amp;&amp; pattern.charAt(0) === &#039;#&#039;) {
    return false
  }

  // &quot;&quot; only matches &quot;&quot;
  if (pattern.trim() === &#039;&#039;) return p === &#039;&#039;

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== &#039;string&#039;) {
    throw new TypeError(&#039;glob pattern string required&#039;)
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== &#039;/&#039;) {
    pattern = pattern.split(path.sep).join(&#039;/&#039;)
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don&#039;t do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment &amp;&amp; pattern.charAt(0) === &#039;#&#039;) {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of &quot;**&quot;, which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --&gt; regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn&#039;t compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i &lt; l &amp;&amp; pattern.charAt(i) === &#039;!&#039;
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -&gt; abd acd
// a{b,}c -&gt; abc ac
// a{0..3}d -&gt; a0d a1d a2d a3d
// a{b,c{d,e}f}g -&gt; abg acdfg acefg
// a{b,c}d{e,f}g -&gt; abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -&gt; a{2..}b
// a{b}c -&gt; a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === &#039;undefined&#039;
    ? this.pattern : pattern

  if (typeof pattern === &#039;undefined&#039;) {
    throw new Error(&#039;undefined pattern&#039;)
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain &quot;/&quot; in it
// so we&#039;re going to return a 2d array, where each entry is the full
// pattern, split on &#039;/&#039;, and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that &quot;**&quot; only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  var options = this.options

  // shortcuts
  if (!options.noglobstar &amp;&amp; pattern === &#039;**&#039;) return GLOBSTAR
  if (pattern === &#039;&#039;) return &#039;&#039;

  var re = &#039;&#039;
  var hasMagic = !!options.nocase
  var escaping = false
  // ? =&gt; one single character
  var patternListStack = []
  var negativeLists = []
  var plType
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn&#039;t start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === &#039;.&#039; ? &#039;&#039; // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? &#039;(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))&#039;
  : &#039;(?!\\.)&#039;
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn&#039;t consumed by this pass.
      switch (stateChar) {
        case &#039;*&#039;:
          re += star
          hasMagic = true
        break
        case &#039;?&#039;:
          re += qmark
          hasMagic = true
        break
        default:
          re += &#039;\\&#039; + stateChar
        break
      }
      self.debug(&#039;clearStateChar %j %j&#039;, stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i &lt; len) &amp;&amp; (c = pattern.charAt(i))
    ; i++) {
    this.debug(&#039;%s\t%s %s %j&#039;, pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping &amp;&amp; reSpecials[c]) {
      re += &#039;\\&#039; + c
      escaping = false
      continue
    }

    switch (c) {
      case &#039;/&#039;:
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case &#039;\\&#039;:
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the &quot;extglob&quot; stuff.
      case &#039;?&#039;:
      case &#039;*&#039;:
      case &#039;+&#039;:
      case &#039;@&#039;:
      case &#039;!&#039;:
        this.debug(&#039;%s\t%s %s %j &lt;-- stateChar&#039;, pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug(&#039;  in class&#039;)
          if (c === &#039;!&#039; &amp;&amp; i === classStart + 1) c = &#039;^&#039;
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug(&#039;call clearStateChar %j&#039;, stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn&#039;t a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case &#039;(&#039;:
        if (inClass) {
          re += &#039;(&#039;
          continue
        }

        if (!stateChar) {
          re += &#039;\\(&#039;
          continue
        }

        plType = stateChar
        patternListStack.push({
          type: plType,
          start: i - 1,
          reStart: re.length
        })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === &#039;!&#039; ? &#039;(?:(?!(?:&#039; : &#039;(?:&#039;
        this.debug(&#039;plType %j %j&#039;, stateChar, re)
        stateChar = false
      continue

      case &#039;)&#039;:
        if (inClass || !patternListStack.length) {
          re += &#039;\\)&#039;
          continue
        }

        clearStateChar()
        hasMagic = true
        re += &#039;)&#039;
        var pl = patternListStack.pop()
        plType = pl.type
        // negation is (?:(?!js)[^/]*)
        // The others are (?:&lt;pattern&gt;)&lt;type&gt;
        switch (plType) {
          case &#039;!&#039;:
            negativeLists.push(pl)
            re += &#039;)[^/]*?)&#039;
            pl.reEnd = re.length
            break
          case &#039;?&#039;:
          case &#039;+&#039;:
          case &#039;*&#039;:
            re += plType
            break
          case &#039;@&#039;: break // the default anyway
        }
      continue

      case &#039;|&#039;:
        if (inClass || !patternListStack.length || escaping) {
          re += &#039;\\|&#039;
          escaping = false
          continue
        }

        clearStateChar()
        re += &#039;|&#039;
      continue

      // these are mostly the same in regexp and glob
      case &#039;[&#039;:
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += &#039;\\&#039; + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case &#039;]&#039;:
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += &#039;\\&#039; + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // &quot;[z-a]&quot; is valid, equivalent to &quot;\[z-a\]&quot;
        if (inClass) {
          // split where the last [ was, make sure we don&#039;t have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it&#039;s tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp(&#039;[&#039; + cs + &#039;]&#039;)
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + &#039;\\[&#039; + sp[0] + &#039;\\]&#039;
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn&#039;t consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          &amp;&amp; !(c === &#039;^&#039; &amp;&amp; inClass)) {
          re += &#039;\\&#039;
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // &quot;[abc&quot; is valid, equivalent to &quot;\[abc&quot;
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + &#039;\\[&#039; + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + 3)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn&#039;t already escaped, so escape it.
        $2 = &#039;\\&#039;
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That&#039;s why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + &#039;|&#039;
    })

    this.debug(&#039;tail=%j\n   %s&#039;, tail, tail)
    var t = pl.type === &#039;*&#039; ? star
      : pl.type === &#039;?&#039; ? qmark
      : &#039;\\&#039; + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + &#039;\\(&#039; + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += &#039;\\\\&#039;
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case &#039;.&#039;:
    case &#039;[&#039;:
    case &#039;(&#039;: addPatternStart = true
  }

  // Hack to work around lack of negative lookbehind in JS
  // A pattern like: *.!(x).!(y|z) needs to ensure that a name
  // like &#039;a.xyz.yz&#039; doesn&#039;t match.  So, the first negative
  // lookahead, has to look ALL the way ahead, to the end of
  // the pattern.
  for (var n = negativeLists.length - 1; n &gt; -1; n--) {
    var nl = negativeLists[n]

    var nlBefore = re.slice(0, nl.reStart)
    var nlFirst = re.slice(nl.reStart, nl.reEnd - 8)
    var nlLast = re.slice(nl.reEnd - 8, nl.reEnd)
    var nlAfter = re.slice(nl.reEnd)

    nlLast += nlAfter

    // Handle nested stuff like *(*.js|!(*.json)), where open parens
    // mean that we should *not* include the ) in the bit that is considered
    // &quot;after&quot; the negated section.
    var openParensBefore = nlBefore.split(&#039;(&#039;).length - 1
    var cleanAfter = nlAfter
    for (i = 0; i &lt; openParensBefore; i++) {
      cleanAfter = cleanAfter.replace(/\)[+*?]?/, &#039;&#039;)
    }
    nlAfter = cleanAfter

    var dollar = &#039;&#039;
    if (nlAfter === &#039;&#039; &amp;&amp; isSub !== SUBPARSE) {
      dollar = &#039;$&#039;
    }
    var newRe = nlBefore + nlFirst + nlAfter + dollar + nlLast
    re = newRe
  }

  // if the re is not &quot;&quot; at this point, then we need to make sure
  // it doesn&#039;t match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== &#039;&#039; &amp;&amp; hasMagic) {
    re = &#039;(?=.)&#039; + re
  }

  if (addPatternStart) {
    re = patternStart + re
  }

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it&#039;ll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? &#039;i&#039; : &#039;&#039;
  var regExp = new RegExp(&#039;^&#039; + re + &#039;$&#039;, flags)

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or &quot;**&quot;.
  //
  // It&#039;s better to use .match().  This function shouldn&#039;t
  // be used, really, but it&#039;s pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? &#039;i&#039; : &#039;&#039;

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === &#039;string&#039;) ? regExpEscape(p)
      : p._src
    }).join(&#039;\\\/&#039;)
  }).join(&#039;|&#039;)

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = &#039;^(?:&#039; + re + &#039;)$&#039;

  // can match anything, as long as it&#039;s not this.
  if (this.negate) re = &#039;^(?!&#039; + re + &#039;).*$&#039;

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull &amp;&amp; !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug(&#039;match&#039;, f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === &#039;&#039;

  if (f === &#039;/&#039; &amp;&amp; partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== &#039;/&#039;) {
    f = f.split(path.sep).join(&#039;/&#039;)
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, &#039;split&#039;, f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, &#039;set&#039;, set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i &gt;= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i &lt; set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase &amp;&amp; pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn&#039;t get any hits.  this is success if it&#039;s a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// &quot;/a/b&quot; matches the start of &quot;/*/b/*/d&quot;
// Partial means, if you run out of file before you run
// out of pattern, then that&#039;s fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug(&#039;matchOne&#039;,
    { &#039;this&#039;: this, file: file, pattern: pattern })

  this.debug(&#039;matchOne&#039;, file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi &lt; fl) &amp;&amp; (pi &lt; pl)
      ; fi++, pi++) {
    this.debug(&#039;matchOne loop&#039;)
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug(&#039;GLOBSTAR&#039;, [pattern, p, f])

      // &quot;**&quot;
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** &quot;swallows&quot; a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -&gt; no
      //       - matchOne(y/z/c, c) -&gt; no
      //       - matchOne(z/c, c) -&gt; no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug(&#039;** at the end&#039;)
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi &lt; fl; fi++) {
          if (file[fi] === &#039;.&#039; || file[fi] === &#039;..&#039; ||
            (!options.dot &amp;&amp; file[fi].charAt(0) === &#039;.&#039;)) return false
        }
        return true
      }

      // ok, let&#039;s see if we can swallow whatever we can.
      while (fr &lt; fl) {
        var swallowee = file[fr]

        this.debug(&#039;\nglobstar while&#039;, file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug(&#039;globstar found match!&#039;, fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can&#039;t swallow &quot;.&quot; or &quot;..&quot; ever.
          // can only swallow &quot;.foo&quot; when explicitly asked.
          if (swallowee === &#039;.&#039; || swallowee === &#039;..&#039; ||
            (!options.dot &amp;&amp; swallowee.charAt(0) === &#039;.&#039;)) {
            this.debug(&#039;dot detected!&#039;, file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug(&#039;globstar swallow a segment, and continue&#039;)
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can&#039;t say this is necessarily over.
      // If there&#039;s more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug(&#039;\n&gt;&gt;&gt; no match, partial?&#039;, file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === &#039;string&#039;) {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug(&#039;string match&#039;, p, f, hit)
    } else {
      hit = f.match(p)
      this.debug(&#039;pattern match&#039;, p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we&#039;ll get a final &quot;&quot;
  // at the end of the pattern.  This can only match a
  // corresponding &quot;&quot; at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn&#039;t have any more for it. But, a/b/ should *not*
  // match &quot;a/b/*&quot;, even though &quot;&quot; matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we&#039;re done.
  if (fi === fl &amp;&amp; pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we&#039;re doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we&#039;re on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) &amp;&amp; (file[fi] === &#039;&#039;)
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error(&#039;wtf?&#039;)
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, &#039;$1&#039;)
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, &#039;\\$&amp;&#039;)
}

},{&quot;brace-expansion&quot;:2,&quot;path&quot;:undefined}],2:[function(require,module,exports){
var concatMap = require(&#039;concat-map&#039;);
var balanced = require(&#039;balanced-match&#039;);

module.exports = expandTop;

var escSlash = &#039;\0SLASH&#039;+Math.random()+&#039;\0&#039;;
var escOpen = &#039;\0OPEN&#039;+Math.random()+&#039;\0&#039;;
var escClose = &#039;\0CLOSE&#039;+Math.random()+&#039;\0&#039;;
var escComma = &#039;\0COMMA&#039;+Math.random()+&#039;\0&#039;;
var escPeriod = &#039;\0PERIOD&#039;+Math.random()+&#039;\0&#039;;

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split(&#039;\\\\&#039;).join(escSlash)
            .split(&#039;\\{&#039;).join(escOpen)
            .split(&#039;\\}&#039;).join(escClose)
            .split(&#039;\\,&#039;).join(escComma)
            .split(&#039;\\.&#039;).join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join(&#039;\\&#039;)
            .split(escOpen).join(&#039;{&#039;)
            .split(escClose).join(&#039;}&#039;)
            .split(escComma).join(&#039;,&#039;)
            .split(escPeriod).join(&#039;.&#039;);
}


// Basically just str.split(&quot;,&quot;), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [&#039;&#039;];

  var parts = [];
  var m = balanced(&#039;{&#039;, &#039;}&#039;, str);

  if (!m)
    return str.split(&#039;,&#039;);

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(&#039;,&#039;);

  p[p.length-1] += &#039;{&#039; + body + &#039;}&#039;;
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  var expansions = expand(escapeBraces(str));
  return expansions.filter(identity).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return &#039;{&#039; + str + &#039;}&#039;;
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i &lt;= y;
}
function gte(i, y) {
  return i &gt;= y;
}

function expand(str) {
  var expansions = [];

  var m = balanced(&#039;{&#039;, &#039;}&#039;, str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
  if (!isSequence &amp;&amp; !isOptions) {
    // {a},b}
    if (m.post.match(/,.*}/)) {
      str = m.pre + &#039;{&#039; + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==&gt; x{a}y x{b}y
      n = expand(n[0]).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post)
          : [&#039;&#039;];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it&#039;s not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post)
    : [&#039;&#039;];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y &lt; x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === &#039;\\&#039;)
          c = &#039;&#039;;
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need &gt; 0) {
            var z = new Array(need + 1).join(&#039;0&#039;);
            if (i &lt; 0)
              c = &#039;-&#039; + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el) });
  }

  for (var j = 0; j &lt; N.length; j++) {
    for (var k = 0; k &lt; post.length; k++) {
      expansions.push([pre, N[j], post[k]].join(&#039;&#039;))
    }
  }

  return expansions;
}


},{&quot;balanced-match&quot;:3,&quot;concat-map&quot;:4}],3:[function(require,module,exports){
module.exports = balanced;
function balanced(a, b, str) {
  var bal = 0;
  var m = {};
  var ended = false;

  for (var i = 0; i &lt; str.length; i++) {
    if (a == str.substr(i, a.length)) {
      if (!(&#039;start&#039; in m)) m.start = i;
      bal++;
    }
    else if (b == str.substr(i, b.length) &amp;&amp; &#039;start&#039; in m) {
      ended = true;
      bal--;
      if (!bal) {
        m.end = i;
        m.pre = str.substr(0, m.start);
        m.body = (m.end - m.start &gt; 1)
          ? str.substring(m.start + a.length, m.end)
          : &#039;&#039;;
        m.post = str.slice(m.end + b.length);
        return m;
      }
    }
  }

  // if we opened more than we closed, find the one we closed
  if (bal &amp;&amp; ended) {
    var start = m.start + a.length;
    m = balanced(a, b, str.substr(start));
    if (m) {
      m.start += start;
      m.end += start;
      m.pre = str.slice(0, start) + m.pre;
    }
    return m;
  }
}

},{}],4:[function(require,module,exports){
module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i &lt; xs.length; i++) {
        var x = fn(xs[i], i);
        if (Array.isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

},{}]},{},[1])(1)
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
