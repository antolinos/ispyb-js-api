<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jshint/src/cli.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jshint/src/cli.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">65.32</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">769</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">66.37</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">5.89</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

var _                 = require(&quot;lodash&quot;);
var fs                = require(&quot;fs&quot;);
var cli               = require(&quot;cli&quot;);
var path              = require(&quot;path&quot;);
var shjs              = require(&quot;shelljs&quot;);
var minimatch         = require(&quot;minimatch&quot;);
var htmlparser        = require(&quot;htmlparser2&quot;);
var exit              = require(&quot;exit&quot;);
var stripJsonComments = require(&quot;strip-json-comments&quot;);
var JSHINT            = require(&quot;./jshint.js&quot;).JSHINT;
var defReporter       = require(&quot;./reporters/default&quot;).reporter;

var OPTIONS = {
  &quot;config&quot;: [&quot;c&quot;, &quot;Custom configuration file&quot;, &quot;string&quot;, false ],
  &quot;reporter&quot;: [&quot;reporter&quot;, &quot;Custom reporter (&lt;PATH&gt;|jslint|checkstyle|unix)&quot;, &quot;string&quot;, undefined ],
  &quot;prereq&quot;: [
    &quot;prereq&quot;,
    &quot;Comma-separate list of prerequisite (paths). E.g. files which include&quot; +
    &quot;definitions of global variabls used throughout your project&quot;,
    &quot;string&quot;,
    null
  ],
  &quot;exclude&quot;: [&quot;exclude&quot;,
    &quot;Exclude files matching the given filename pattern (same as .jshintignore)&quot;, &quot;string&quot;, null],
  &quot;exclude-path&quot;: [&quot;exclude-path&quot;, &quot;Pass in a custom jshintignore file path&quot;, &quot;string&quot;, null],
  &quot;filename&quot;: [&quot;filename&quot;,
    &quot;Pass in a filename when using STDIN to emulate config lookup for that file name&quot;,
    &quot;string&quot;, null],
  &quot;verbose&quot;: [&quot;verbose&quot;, &quot;Show message codes&quot;],
  &quot;show-non-errors&quot;: [&quot;show-non-errors&quot;, &quot;Show additional data generated by jshint&quot;],
  &quot;extra-ext&quot;: [&quot;e&quot;,
    &quot;Comma-separated list of file extensions to use (default is .js)&quot;, &quot;string&quot;, &quot;&quot;],

  &quot;extract&quot;: [
    &quot;extract&quot;,
    &quot;Extract inline scripts contained in HTML (auto|always|never, default to never)&quot;,
    &quot;string&quot;,
    &quot;never&quot;
  ],

  // Deprecated options.
  &quot;jslint-reporter&quot;: [
    &quot;jslint-reporter&quot;,
    deprecated(&quot;Use a jslint compatible reporter&quot;, &quot;--reporter=jslint&quot;)
  ],

  &quot;checkstyle-reporter&quot;: [
    &quot;checkstyle-reporter&quot;,
    deprecated(&quot;Use a CheckStyle compatible XML reporter&quot;, &quot;--reporter=checkstyle&quot;)
  ]
};

/**
 * Returns the same text but with a deprecation notice.
 * Useful for options descriptions.
 *
 * @param {string} text
 * @param {string} alt (optional) Alternative command to include in the
 *                 deprecation notice.
 *
 * @returns {string}
 */
function deprecated(text, alt) {
  if (!alt) {
    return text + &quot; (DEPRECATED)&quot;;
  }

  return text + &quot; (DEPRECATED, use &quot; + alt + &quot; instead)&quot;;
}

/**
 * Tries to find a configuration file in either project directory
 * or in the home directory. Configuration files are named
 * &#039;.jshintrc&#039;.
 *
 * @param {string} file path to the file to be linted
 * @returns {string} a path to the config file
 */
function findConfig(file) {
  var dir  = path.dirname(path.resolve(file));
  var envs = getHomeDir();
  var proj = findFile(&quot;.jshintrc&quot;, dir);
  var home;

  if (proj)
    return proj;

  else if (envs) {
    home = path.normalize(path.join(envs, &quot;.jshintrc&quot;));

    if (shjs.test(&quot;-e&quot;, home))
      return home;
  }

  return null;
}

function getHomeDir() {
  var homePath = &quot;&quot;;
  var environment = global.process.env;
  var paths = [
    environment.USERPROFILE,
    environment.HOME,
    environment.HOMEPATH,
    environment.HOMEDRIVE + environment.HOMEPATH
  ];

  while (paths.length) {
    homePath = paths.shift();
    if (fs.existsSync(homePath)) {
      return homePath;
    }
  }
}

/**
 * Tries to find JSHint configuration within a package.json file
 * (if any). It search in the current directory and then goes up
 * all the way to the root just like findFile.
 *
 * @param   {string} file path to the file to be linted
 * @returns {object} config object
 */
function loadNpmConfig(file) {
  var dir = path.dirname(path.resolve(file));
  var fp  = findFile(&quot;package.json&quot;, dir);

  if (!fp)
    return null;

  try {
    return require(fp).jshintConfig;
  } catch (e) {
    return null;
  }
}

/**
 * Tries to import a reporter file and returns its reference.
 *
 * @param {string} fp a path to the reporter file
 * @returns {object} imported module for the reporter or &#039;null&#039;
 *                   if a module cannot be imported.
 */
function loadReporter(fp) {
  try {
    return require(fp).reporter;
  } catch (err) {
    return null;
  }
}

// Storage for memoized results from find file
// Should prevent lots of directory traversal &amp;
// lookups when liniting an entire project
var findFileResults = {};

/**
 * Searches for a file with a specified name starting with
 * &#039;dir&#039; and going all the way up either until it finds the file
 * or hits the root.
 *
 * @param {string} name filename to search for (e.g. .jshintrc)
 * @param {string} dir  directory to start search from (default:
 *                      current working directory)
 *
 * @returns {string} normalized filename
 */
function findFile(name, cwd) {
  cwd = cwd || process.cwd();

  var filename = path.normalize(path.join(cwd, name));
  if (findFileResults[filename] !== undefined) {
    return findFileResults[filename];
  }

  var parent = path.resolve(cwd, &quot;../&quot;);

  if (shjs.test(&quot;-e&quot;, filename)) {
    findFileResults[filename] = filename;
    return filename;
  }

  if (cwd === parent) {
    findFileResults[filename] = null;
    return null;
  }

  return findFile(name, parent);
}

/**
 * Loads a list of files that have to be skipped. JSHint assumes that
 * the list is located in a file called &#039;.jshintignore&#039;.
 *
 * @return {array} a list of files to ignore.
 */
function loadIgnores(params) {
  var file = findFile(params.excludePath || &quot;.jshintignore&quot;, params.cwd) || &quot;&quot;;

  if (!file &amp;&amp; !params.exclude) {
    return [];
  }

  var lines = (file ? shjs.cat(file) : &quot;&quot;).split(&quot;\n&quot;);
  var exclude = params.exclude || &quot;&quot;;
  lines.unshift.apply(lines, exclude.split(&quot;,&quot;));

  return lines
    .filter(function(line) {
      return !!line.trim();
    })
    .map(function(line) {
      if (line[0] === &quot;!&quot;)
        return &quot;!&quot; + path.resolve(path.dirname(file), line.substr(1).trim());

      return path.join(path.dirname(file), line.trim());
    });
}

/**
 * Checks whether we should ignore a file or not.
 *
 * @param {string} fp       a path to a file
 * @param {array}  patterns a list of patterns for files to ignore
 *
 * @return {boolean} &#039;true&#039; if file should be ignored, &#039;false&#039; otherwise.
 */
function isIgnored(fp, patterns) {
  return patterns.some(function(ip) {
    if (minimatch(path.resolve(fp), ip, { nocase: true })) {
      return true;
    }

    if (path.resolve(fp) === ip) {
      return true;
    }

    if (shjs.test(&quot;-d&quot;, fp) &amp;&amp; ip.match(/^[^\/]*\/?$/) &amp;&amp;
      fp.match(new RegExp(&quot;^&quot; + ip + &quot;.*&quot;))) {
      return true;
    }
  });
}

/**
 * Extract JS code from a given source code. The source code my be either HTML
 * code or JS code. In the latter case, no extraction will be done unless
 * &#039;always&#039; is given.
 *
 * @param {string} code a piece of code
 * @param {string} when &#039;always&#039; will extract the JS code, no matter what.
 * &#039;never&#039; won&#039;t do anything. &#039;auto&#039; will check if the code looks like HTML
 * before extracting it.
 *
 * @return {string} the extracted code
 */
function extract(code, when) {
  // A JS file won&#039;t start with a less-than character, whereas a HTML file
  // should always start with that.
  if (when !== &quot;always&quot; &amp;&amp; (when !== &quot;auto&quot; || !/^\s*&lt;/.test(code)))
    return code;

  var inscript = false;
  var index = 0;
  var js = [];
  var startOffset;

  // Test if current tag is a valid &lt;script&gt; tag.
  function onopen(name, attrs) {
    if (name !== &quot;script&quot;)
      return;

    if (attrs.type &amp;&amp; !/text\/javascript/.test(attrs.type.toLowerCase()))
      return;

    // Mark that we&#039;re inside a &lt;script&gt; a tag and push all new lines
    // in between the last &lt;/script&gt; tag and this &lt;script&gt; tag to preserve
    // location information.
    inscript = true;
    js.push.apply(js, code.slice(index, parser.endIndex).match(/\n\r|\n|\r/g));
    startOffset = null;
  }

  function onclose(name) {
    if (name !== &quot;script&quot; || !inscript)
      return;

    inscript = false;
    index = parser.startIndex;
    startOffset = null;
  }

  function ontext(data) {
    if (!inscript)
      return;

    var lines = data.split(/\n\r|\n|\r/);

    if (!startOffset) {
      lines.some(function(line) {
        if (!line) return;
        startOffset = /^(\s*)/.exec(line)[1];
        return true;
      });
    }

    // check for startOffset again to remove leading white space from first line
    if (startOffset) {
      lines = lines.map(function(line) {
        return line.replace(startOffset, &quot;&quot;);
      });
      data = lines.join(&quot;\n&quot;);
    }

    js.push(data); // Collect JavaScript code.
  }

  var parser = new htmlparser.Parser({ onopentag: onopen, onclosetag: onclose, ontext: ontext });
  parser.parseComplete(code);

  return js.join(&quot;&quot;);
}

/**
 * Crude version of source maps: extract how much JavaSscript in HTML
 * was shifted based on first JS line. For example if first js line
 * is offset by 4 spaces, each line in this js fragment will have offset 4
 * to restore the original column.
 *
 * @param {string} code a piece of code
 * @param {string} when &#039;always&#039; will extract the JS code, no matter what.
 * &#039;never&#039; won&#039;t do anything. &#039;auto&#039; will check if the code looks like HTML
 * before extracting it.
 *
 * @return {Array} extracted offsets
 */
function extractOffsets(code, when) {
  // A JS file won&#039;t start with a less-than character, whereas a HTML file
  // should always start with that.
  if (when !== &quot;always&quot; &amp;&amp; (when !== &quot;auto&quot; || !/^\s*&lt;/.test(code)))
    return;

  var inscript = false;
  var index = 0;
  var lineCounter = 0;
  var startOffset;
  var offsets = [];

  // Test if current tag is a valid &lt;script&gt; tag.
  function onopen(name, attrs) {
    if (name !== &quot;script&quot;)
      return;

    if (attrs.type &amp;&amp; !/text\/javascript/.test(attrs.type.toLowerCase()))
      return;

    // Mark that we&#039;re inside a &lt;script&gt; a tag and push all new lines
    // in between the last &lt;/script&gt; tag and this &lt;script&gt; tag to preserve
    // location information.
    inscript = true;
    var fragment = code.slice(index, parser.endIndex);
    var n = (fragment.match(/\n\r|\n|\r/g) || []).length;
    lineCounter += n;
    startOffset = null;
  }

  function onclose(name) {
    if (name !== &quot;script&quot; || !inscript)
      return;

    inscript = false;
    index = parser.startIndex;
    startOffset = null;
  }

  function ontext(data) {
    if (!inscript)
      return;

    var lines = data.split(/\n\r|\n|\r/);

    if (!startOffset) {
      lines.some(function(line) {
        if (!line) return;
        startOffset = /^(\s*)/.exec(line)[1];
        return true;
      });
    }

    // check for startOffset again to remove leading white space from first line
    lines.forEach(function() {
      lineCounter += 1;
      if (startOffset) {
        offsets[lineCounter] = startOffset.length;
      } else {
        offsets[lineCounter] = 0;
      }
    });
  }

  var parser = new htmlparser.Parser({ onopentag: onopen, onclosetag: onclose, ontext: ontext });
  parser.parseComplete(code);
  return offsets;
}

/**
 * Recursively gather all files that need to be linted,
 * excluding those that user asked to ignore.
 *
 * @param {string} fp      a path to a file or directory to lint
 * @param {array}  files   a pointer to an array that stores a list of files
 * @param {array}  ignores a list of patterns for files to ignore
 * @param {array}  ext     a list of non-dot-js extensions to lint
 */
function collect(fp, files, ignores, ext) {
  if (ignores &amp;&amp; isIgnored(fp, ignores)) {
    return;
  }

  if (!shjs.test(&quot;-e&quot;, fp)) {
    cli.error(&quot;Can&#039;t open &quot; + fp);
    return;
  }

  if (shjs.test(&quot;-d&quot;, fp)) {
    shjs.ls(fp).forEach(function(item) {
      var itempath = path.join(fp, item);
      if (shjs.test(&quot;-d&quot;, itempath) || item.match(ext)) {
        collect(itempath, files, ignores, ext);
      }
    });

    return;
  }

  files.push(fp);
}

/**
 * Runs JSHint against provided file and saves the result
 *
 * @param {string} code    code that needs to be linted
 * @param {object} results a pointer to an object with results
 * @param {object} config  an object with JSHint configuration
 * @param {object} data    a pointer to an object with extra data
 * @param {string} file    (optional) file name that is being linted
 */
function lint(code, results, config, data, file) {
  var globals;
  var lintData;
  var buffer = [];

  config = config || {};
  config = JSON.parse(JSON.stringify(config));

  if (config.prereq) {
    config.prereq.forEach(function(fp) {
      fp = path.join(config.dirname, fp);
      if (shjs.test(&quot;-e&quot;, fp))
        buffer.push(shjs.cat(fp));
    });
    delete config.prereq;
  }

  if (config.globals) {
    globals = config.globals;
    delete config.globals;
  }

  if (config.overrides) {
    if (file) {
      _.each(config.overrides, function(options, pattern) {
        if (minimatch(path.normalize(file), pattern, { nocase: true, matchBase: true })) {
          if (options.globals) {
            globals = _.extend(globals || {}, options.globals);
            delete options.globals;
          }
          _.extend(config, options);
        }
      });
    }

    delete config.overrides;
  }

  delete config.dirname;

  buffer.push(code);
  buffer = buffer.join(&quot;\n&quot;);
  buffer = buffer.replace(/^\uFEFF/, &quot;&quot;); // Remove potential Unicode BOM.

  if (!JSHINT(buffer, config, globals)) {
    JSHINT.errors.forEach(function(err) {
      if (err) {
        results.push({ file: file || &quot;stdin&quot;, error: err });
      }
    });
  }

  lintData = JSHINT.data();

  if (lintData) {
    lintData.file = file || &quot;stdin&quot;;
    data.push(lintData);
  }
}

var exports = {
  extract: extract,
  exit: exit,

  /**
   * Returns a configuration file or nothing, if it can&#039;t be found.
   */
  getConfig: function(fp) {
    return loadNpmConfig(fp) || exports.loadConfig(findConfig(fp));
  },

  /**
   * Loads and parses a configuration file.
   *
   * @param {string} fp a path to the config file
   * @returns {object} config object
   */
  loadConfig: function(fp) {
    if (!fp) {
      return {};
    }

    if (!shjs.test(&quot;-e&quot;, fp)) {
      cli.error(&quot;Can&#039;t find config file: &quot; + fp);
      exports.exit(1);
    }

    try {
      var config = JSON.parse(stripJsonComments(shjs.cat(fp)));
      config.dirname = path.dirname(fp);

      if (config[&#039;extends&#039;]) {
        var baseConfig = exports.loadConfig(path.resolve(config.dirname, config[&#039;extends&#039;]));
        config = _.merge({}, baseConfig, config, function(a, b) {
          if (_.isArray(a)) {
            return a.concat(b);
          }
        });
        delete config[&#039;extends&#039;];
      }

      return config;
    } catch (err) {
      cli.error(&quot;Can&#039;t parse config file: &quot; + fp + &quot;\nError:&quot; + err);
      exports.exit(1);
    }
  },

  /**
   * Gathers all files that need to be linted
   *
   * @param {object} post-processed options from &#039;interpret&#039;:
   *                   args     - CLI arguments
   *                   ignores  - A list of files/dirs to ignore (defaults to .jshintignores)
   *                   extensions - A list of non-dot-js extensions to check
   */
  gather: function(opts) {
    var files = [];

    var reg = new RegExp(&quot;\\.(js&quot; +
      (!opts.extensions ? &quot;&quot; : &quot;|&quot; +
        opts.extensions.replace(/,/g, &quot;|&quot;).replace(/[\. ]/g, &quot;&quot;)) + &quot;)$&quot;);

    var ignores = !opts.ignores ? loadIgnores({ cwd: opts.cwd }) :
                                  opts.ignores.map(function(target) {
                                    return path.resolve(target);
                                  });

    opts.args.forEach(function(target) {
      collect(target, files, ignores, reg);
    });

    return files;
  },

  /**
   * Gathers all files that need to be linted, lints them, sends them to
   * a reporter and returns the overall result.
   *
   * @param {object} post-processed options from &#039;interpret&#039;:
   *                 args     - CLI arguments
   *                 config   - Configuration object
   *                 reporter - Reporter function
   *                 ignores  - A list of files/dirs to ignore
   *                 extensions - A list of non-dot-js extensions to check
   * @param {function} cb a callback to call when function is finished
   *                   asynchronously.
   *
   * @returns {bool} &#039;true&#039; if all files passed, &#039;false&#039; otherwise and &#039;null&#039;
   *                 when function will be finished asynchronously.
   */
  run: function(opts, cb) {
    var files = exports.gather(opts);
    var results = [];
    var data = [];

    function mergeCLIPrereq(config) {
      if (opts.prereq) {
        config.prereq = (config.prereq || []).concat(opts.prereq.split(/\s*,\s*/));
      }
    }

    if (opts.useStdin) {
      cli.withStdin(function(code) {
        var config = opts.config;
        var filename;

        // There is an if(filename) check in the lint() function called below.
        // passing a filename of undefined is the same as calling the function
        // without a filename.  If there is no opts.filename, filename remains
        // undefined and lint() is effectively called with 4 parameters.
        if (opts.filename) {
          filename = path.resolve(opts.filename);
        }

        if (filename &amp;&amp; !config) {
          config = exports.getConfig(filename);
        }

        config = config || {};

        mergeCLIPrereq(config);

        lint(extract(code, opts.extract), results, config, data, filename);
        (opts.reporter || defReporter)(results, data, { verbose: opts.verbose });
        cb(results.length === 0);
      });

      return null;
    }

    files.forEach(function(file) {
      var config = opts.config || exports.getConfig(file);
      var code;

      try {
        code = shjs.cat(file);
      } catch (err) {
        cli.error(&quot;Can&#039;t open &quot; + file);
        exports.exit(1);
      }

      mergeCLIPrereq(config);

      lint(extract(code, opts.extract), results, config, data, file);

      if (results.length) {
        var offsets = extractOffsets(code, opts.extract);
        if (offsets &amp;&amp; offsets.length) {
          results.forEach(function(errorInfo) {
            var line = errorInfo.error.line;
            if (line &gt;= 0 &amp;&amp; line &lt; offsets.length) {
              var offset = +offsets[line];
              errorInfo.error.character += offset;
            }
          });
        }
      }
    });

    (opts.reporter || defReporter)(results, data, { verbose: opts.verbose });
    return results.length === 0;
  },

  /**
   * Helper exposed for testing.
   * Used to determine is stdout has any buffered output before exiting the program
   */
  getBufferSize: function() {
    return process.stdout.bufferSize;
  },

  /**
   * Main entrance function. Parses arguments and calls &#039;run&#039; when
   * its done. This function is called from bin/jshint file.
   *
   * @param {object} args, arguments in the process.argv format.
   */
  interpret: function(args) {
    cli.setArgv(args);
    cli.options = {};

    cli.enable(&quot;version&quot;, &quot;glob&quot;, &quot;help&quot;);
    cli.setApp(path.resolve(__dirname + &quot;/../package.json&quot;));

    var options = cli.parse(OPTIONS);
    // Use config file if specified
    var config;
    if (options.config) {
      config = exports.loadConfig(options.config);
    }

    switch (true) {
    // JSLint reporter
    case options.reporter === &quot;jslint&quot;:
    case options[&quot;jslint-reporter&quot;]:
      options.reporter = &quot;./reporters/jslint_xml.js&quot;;
      break;

    // CheckStyle (XML) reporter
    case options.reporter === &quot;checkstyle&quot;:
    case options[&quot;checkstyle-reporter&quot;]:
      options.reporter = &quot;./reporters/checkstyle.js&quot;;
      break;

    // Unix reporter
    case options.reporter === &quot;unix&quot;:
      options.reporter = &quot;./reporters/unix.js&quot;;
      break;

    // Reporter that displays additional JSHint data
    case options[&quot;show-non-errors&quot;]:
      options.reporter = &quot;./reporters/non_error.js&quot;;
      break;

    // Custom reporter
    case options.reporter !== undefined:
      options.reporter = path.resolve(process.cwd(), options.reporter);
    }

    var reporter;
    if (options.reporter) {
      reporter = loadReporter(options.reporter);

      if (reporter === null) {
        cli.error(&quot;Can&#039;t load reporter file: &quot; + options.reporter);
        exports.exit(1);
      }
    }

    // This is a hack. exports.run is both sync and async function
    // because I needed stdin support (and cli.withStdin is async)
    // and was too lazy to change tests.

    function done(passed) {
      /*jshint eqnull:true */

      if (passed == null)
        return;

      exports.exit(passed ? 0 : 2);
    }

    done(exports.run({
      args:       cli.args,
      config:     config,
      reporter:   reporter,
      ignores:    loadIgnores({ exclude: options.exclude, excludePath: options[&quot;exclude-path&quot;] }),
      extensions: options[&quot;extra-ext&quot;],
      verbose:    options.verbose,
      extract:    options.extract,
      filename:   options.filename,
      prereq:     options.prereq,
      useStdin:   { &quot;-&quot;: true, &quot;/dev/stdin&quot;: true }[args[args.length - 1]]
    }, done));
  }
};

module.exports = exports;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
