<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jshint/src/lex.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jshint/src/lex.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">55.20</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">1850</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">120.90</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">16.12</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">/*
 * Lexical analysis and token construction.
 */

&quot;use strict&quot;;

var _      = require(&quot;lodash&quot;);
var events = require(&quot;events&quot;);
var reg    = require(&quot;./reg.js&quot;);
var state  = require(&quot;./state.js&quot;).state;

var unicodeData = require(&quot;../data/ascii-identifier-data.js&quot;);
var asciiIdentifierStartTable = unicodeData.asciiIdentifierStartTable;
var asciiIdentifierPartTable = unicodeData.asciiIdentifierPartTable;
var nonAsciiIdentifierStartTable = require(&quot;../data/non-ascii-identifier-start.js&quot;);
var nonAsciiIdentifierPartTable = require(&quot;../data/non-ascii-identifier-part-only.js&quot;);

// Some of these token types are from JavaScript Parser API
// while others are specific to JSHint parser.
// JS Parser API: https://developer.mozilla.org/en-US/docs/SpiderMonkey/Parser_API

var Token = {
  Identifier: 1,
  Punctuator: 2,
  NumericLiteral: 3,
  StringLiteral: 4,
  Comment: 5,
  Keyword: 6,
  NullLiteral: 7,
  BooleanLiteral: 8,
  RegExp: 9,
  TemplateHead: 10,
  TemplateMiddle: 11,
  TemplateTail: 12,
  NoSubstTemplate: 13
};

var Context = {
  Block: 1,
  Template: 2
};

// Object that handles postponed lexing verifications that checks the parsed
// environment state.

function asyncTrigger() {
  var _checks = [];

  return {
    push: function(fn) {
      _checks.push(fn);
    },

    check: function() {
      for (var check = 0; check &lt; _checks.length; ++check) {
        _checks[check]();
      }

      _checks.splice(0, _checks.length);
    }
  };
}

/*
 * Lexer for JSHint.
 *
 * This object does a char-by-char scan of the provided source code
 * and produces a sequence of tokens.
 *
 *   var lex = new Lexer(&quot;var i = 0;&quot;);
 *   lex.start();
 *   lex.token(); // returns the next token
 *
 * You have to use the token() method to move the lexer forward
 * but you don&#039;t have to use its return value to get tokens. In addition
 * to token() method returning the next token, the Lexer object also
 * emits events.
 *
 *   lex.on(&quot;Identifier&quot;, function(data) {
 *     if (data.name.indexOf(&quot;_&quot;) &gt;= 0) {
 *       // Produce a warning.
 *     }
 *   });
 *
 * Note that the token() method returns tokens in a JSLint-compatible
 * format while the event emitter uses a slightly modified version of
 * Mozilla&#039;s JavaScript Parser API. Eventually, we will move away from
 * JSLint format.
 */
function Lexer(source) {
  var lines = source;

  if (typeof lines === &quot;string&quot;) {
    lines = lines
      .replace(/\r\n/g, &quot;\n&quot;)
      .replace(/\r/g, &quot;\n&quot;)
      .split(&quot;\n&quot;);
  }

  // If the first line is a shebang (#!), make it a blank and move on.
  // Shebangs are used by Node scripts.

  if (lines[0] &amp;&amp; lines[0].substr(0, 2) === &quot;#!&quot;) {
    if (lines[0].indexOf(&quot;node&quot;) !== -1) {
      state.option.node = true;
    }
    lines[0] = &quot;&quot;;
  }

  this.emitter = new events.EventEmitter();
  this.source = source;
  this.setLines(lines);
  this.prereg = true;

  this.line = 0;
  this.char = 1;
  this.from = 1;
  this.input = &quot;&quot;;
  this.inComment = false;
  this.context = [];
  this.templateStarts = [];

  for (var i = 0; i &lt; state.option.indent; i += 1) {
    state.tab += &quot; &quot;;
  }
}

Lexer.prototype = {
  _lines: [],

  inContext: function(ctxType) {
    return this.context.length &gt; 0 &amp;&amp; this.context[this.context.length - 1].type === ctxType;
  },

  pushContext: function(ctxType) {
    this.context.push({ type: ctxType });
  },

  popContext: function() {
    return this.context.pop();
  },

  isContext: function(context) {
    return this.context.length &gt; 0 &amp;&amp; this.context[this.context.length - 1] === context;
  },

  currentContext: function() {
    return this.context.length &gt; 0 &amp;&amp; this.context[this.context.length - 1];
  },

  getLines: function() {
    this._lines = state.lines;
    return this._lines;
  },

  setLines: function(val) {
    this._lines = val;
    state.lines = this._lines;
  },

  /*
   * Return the next i character without actually moving the
   * char pointer.
   */
  peek: function(i) {
    return this.input.charAt(i || 0);
  },

  /*
   * Move the char pointer forward i times.
   */
  skip: function(i) {
    i = i || 1;
    this.char += i;
    this.input = this.input.slice(i);
  },

  /*
   * Subscribe to a token event. The API for this method is similar
   * Underscore.js i.e. you can subscribe to multiple events with
   * one call:
   *
   *   lex.on(&quot;Identifier Number&quot;, function(data) {
   *     // ...
   *   });
   */
  on: function(names, listener) {
    names.split(&quot; &quot;).forEach(function(name) {
      this.emitter.on(name, listener);
    }.bind(this));
  },

  /*
   * Trigger a token event. All arguments will be passed to each
   * listener.
   */
  trigger: function() {
    this.emitter.emit.apply(this.emitter, Array.prototype.slice.call(arguments));
  },

  /*
   * Postpone a token event. the checking condition is set as
   * last parameter, and the trigger function is called in a
   * stored callback. To be later called using the check() function
   * by the parser. This avoids parser&#039;s peek() to give the lexer
   * a false context.
   */
  triggerAsync: function(type, args, checks, fn) {
    checks.push(function() {
      if (fn()) {
        this.trigger(type, args);
      }
    }.bind(this));
  },

  /*
   * Extract a punctuator out of the next sequence of characters
   * or return &#039;null&#039; if its not possible.
   *
   * This method&#039;s implementation was heavily influenced by the
   * scanPunctuator function in the Esprima parser&#039;s source code.
   */
  scanPunctuator: function() {
    var ch1 = this.peek();
    var ch2, ch3, ch4;

    switch (ch1) {
    // Most common single-character punctuators
    case &quot;.&quot;:
      if ((/^[0-9]$/).test(this.peek(1))) {
        return null;
      }
      if (this.peek(1) === &quot;.&quot; &amp;&amp; this.peek(2) === &quot;.&quot;) {
        return {
          type: Token.Punctuator,
          value: &quot;...&quot;
        };
      }
      /* falls through */
    case &quot;(&quot;:
    case &quot;)&quot;:
    case &quot;;&quot;:
    case &quot;,&quot;:
    case &quot;[&quot;:
    case &quot;]&quot;:
    case &quot;:&quot;:
    case &quot;~&quot;:
    case &quot;?&quot;:
      return {
        type: Token.Punctuator,
        value: ch1
      };

    // A block/object opener
    case &quot;{&quot;:
      this.pushContext(Context.Block);
      return {
        type: Token.Punctuator,
        value: ch1
      };

    // A block/object closer
    case &quot;}&quot;:
      if (this.inContext(Context.Block)) {
        this.popContext();
      }
      return {
        type: Token.Punctuator,
        value: ch1
      };

    // A pound sign (for Node shebangs)
    case &quot;#&quot;:
      return {
        type: Token.Punctuator,
        value: ch1
      };

    // We&#039;re at the end of input
    case &quot;&quot;:
      return null;
    }

    // Peek more characters

    ch2 = this.peek(1);
    ch3 = this.peek(2);
    ch4 = this.peek(3);

    // 4-character punctuator: &gt;&gt;&gt;=

    if (ch1 === &quot;&gt;&quot; &amp;&amp; ch2 === &quot;&gt;&quot; &amp;&amp; ch3 === &quot;&gt;&quot; &amp;&amp; ch4 === &quot;=&quot;) {
      return {
        type: Token.Punctuator,
        value: &quot;&gt;&gt;&gt;=&quot;
      };
    }

    // 3-character punctuators: === !== &gt;&gt;&gt; &lt;&lt;= &gt;&gt;=

    if (ch1 === &quot;=&quot; &amp;&amp; ch2 === &quot;=&quot; &amp;&amp; ch3 === &quot;=&quot;) {
      return {
        type: Token.Punctuator,
        value: &quot;===&quot;
      };
    }

    if (ch1 === &quot;!&quot; &amp;&amp; ch2 === &quot;=&quot; &amp;&amp; ch3 === &quot;=&quot;) {
      return {
        type: Token.Punctuator,
        value: &quot;!==&quot;
      };
    }

    if (ch1 === &quot;&gt;&quot; &amp;&amp; ch2 === &quot;&gt;&quot; &amp;&amp; ch3 === &quot;&gt;&quot;) {
      return {
        type: Token.Punctuator,
        value: &quot;&gt;&gt;&gt;&quot;
      };
    }

    if (ch1 === &quot;&lt;&quot; &amp;&amp; ch2 === &quot;&lt;&quot; &amp;&amp; ch3 === &quot;=&quot;) {
      return {
        type: Token.Punctuator,
        value: &quot;&lt;&lt;=&quot;
      };
    }

    if (ch1 === &quot;&gt;&quot; &amp;&amp; ch2 === &quot;&gt;&quot; &amp;&amp; ch3 === &quot;=&quot;) {
      return {
        type: Token.Punctuator,
        value: &quot;&gt;&gt;=&quot;
      };
    }

    // Fat arrow punctuator
    if (ch1 === &quot;=&quot; &amp;&amp; ch2 === &quot;&gt;&quot;) {
      return {
        type: Token.Punctuator,
        value: ch1 + ch2
      };
    }

    // 2-character punctuators: &lt;= &gt;= == != ++ -- &lt;&lt; &gt;&gt; &amp;&amp; ||
    // += -= *= %= &amp;= |= ^= /=
    if (ch1 === ch2 &amp;&amp; (&quot;+-&lt;&gt;&amp;|&quot;.indexOf(ch1) &gt;= 0)) {
      return {
        type: Token.Punctuator,
        value: ch1 + ch2
      };
    }

    if (&quot;&lt;&gt;=!+-*%&amp;|^/&quot;.indexOf(ch1) &gt;= 0) {
      if (ch2 === &quot;=&quot;) {
        return {
          type: Token.Punctuator,
          value: ch1 + ch2
        };
      }

      return {
        type: Token.Punctuator,
        value: ch1
      };
    }

    return null;
  },

  /*
   * Extract a comment out of the next sequence of characters and/or
   * lines or return &#039;null&#039; if its not possible. Since comments can
   * span across multiple lines this method has to move the char
   * pointer.
   *
   * In addition to normal JavaScript comments (// and /*) this method
   * also recognizes JSHint- and JSLint-specific comments such as
   * /*jshint, /*jslint, /*globals and so on.
   */
  scanComments: function() {
    var ch1 = this.peek();
    var ch2 = this.peek(1);
    var rest = this.input.substr(2);
    var startLine = this.line;
    var startChar = this.char;
    var self = this;

    // Create a comment token object and make sure it
    // has all the data JSHint needs to work with special
    // comments.

    function commentToken(label, body, opt) {
      var special = [&quot;jshint&quot;, &quot;jslint&quot;, &quot;members&quot;, &quot;member&quot;, &quot;globals&quot;, &quot;global&quot;, &quot;exported&quot;];
      var isSpecial = false;
      var value = label + body;
      var commentType = &quot;plain&quot;;
      opt = opt || {};

      if (opt.isMultiline) {
        value += &quot;*/&quot;;
      }

      body = body.replace(/\n/g, &quot; &quot;);

      if (label === &quot;/*&quot; &amp;&amp; reg.fallsThrough.test(body)) {
        isSpecial = true;
        commentType = &quot;falls through&quot;;
      }

      special.forEach(function(str) {
        if (isSpecial) {
          return;
        }

        // Don&#039;t recognize any special comments other than jshint for single-line
        // comments. This introduced many problems with legit comments.
        if (label === &quot;//&quot; &amp;&amp; str !== &quot;jshint&quot;) {
          return;
        }

        if (body.charAt(str.length) === &quot; &quot; &amp;&amp; body.substr(0, str.length) === str) {
          isSpecial = true;
          label = label + str;
          body = body.substr(str.length);
        }

        if (!isSpecial &amp;&amp; body.charAt(0) === &quot; &quot; &amp;&amp; body.charAt(str.length + 1) === &quot; &quot; &amp;&amp;
          body.substr(1, str.length) === str) {
          isSpecial = true;
          label = label + &quot; &quot; + str;
          body = body.substr(str.length + 1);
        }

        if (!isSpecial) {
          return;
        }

        switch (str) {
        case &quot;member&quot;:
          commentType = &quot;members&quot;;
          break;
        case &quot;global&quot;:
          commentType = &quot;globals&quot;;
          break;
        default:
          var options = body.split(&quot;:&quot;).map(function(v) {
            return v.replace(/^\s+/, &quot;&quot;).replace(/\s+$/, &quot;&quot;);
          });

          if (options.length === 2) {
            switch (options[0]) {
            case &quot;ignore&quot;:
              switch (options[1]) {
              case &quot;start&quot;:
                self.ignoringLinterErrors = true;
                isSpecial = false;
                break;
              case &quot;end&quot;:
                self.ignoringLinterErrors = false;
                isSpecial = false;
                break;
              }
            }
          }

          commentType = str;
        }
      });

      return {
        type: Token.Comment,
        commentType: commentType,
        value: value,
        body: body,
        isSpecial: isSpecial,
        isMultiline: opt.isMultiline || false,
        isMalformed: opt.isMalformed || false
      };
    }

    // End of unbegun comment. Raise an error and skip that input.
    if (ch1 === &quot;*&quot; &amp;&amp; ch2 === &quot;/&quot;) {
      this.trigger(&quot;error&quot;, {
        code: &quot;E018&quot;,
        line: startLine,
        character: startChar
      });

      this.skip(2);
      return null;
    }

    // Comments must start either with // or /*
    if (ch1 !== &quot;/&quot; || (ch2 !== &quot;*&quot; &amp;&amp; ch2 !== &quot;/&quot;)) {
      return null;
    }

    // One-line comment
    if (ch2 === &quot;/&quot;) {
      this.skip(this.input.length); // Skip to the EOL.
      return commentToken(&quot;//&quot;, rest);
    }

    var body = &quot;&quot;;

    /* Multi-line comment */
    if (ch2 === &quot;*&quot;) {
      this.inComment = true;
      this.skip(2);

      while (this.peek() !== &quot;*&quot; || this.peek(1) !== &quot;/&quot;) {
        if (this.peek() === &quot;&quot;) { // End of Line
          body += &quot;\n&quot;;

          // If we hit EOF and our comment is still unclosed,
          // trigger an error and end the comment implicitly.
          if (!this.nextLine()) {
            this.trigger(&quot;error&quot;, {
              code: &quot;E017&quot;,
              line: startLine,
              character: startChar
            });

            this.inComment = false;
            return commentToken(&quot;/*&quot;, body, {
              isMultiline: true,
              isMalformed: true
            });
          }
        } else {
          body += this.peek();
          this.skip();
        }
      }

      this.skip(2);
      this.inComment = false;
      return commentToken(&quot;/*&quot;, body, { isMultiline: true });
    }
  },

  /*
   * Extract a keyword out of the next sequence of characters or
   * return &#039;null&#039; if its not possible.
   */
  scanKeyword: function() {
    var result = /^[a-zA-Z_$][a-zA-Z0-9_$]*/.exec(this.input);
    var keywords = [
      &quot;if&quot;, &quot;in&quot;, &quot;do&quot;, &quot;var&quot;, &quot;for&quot;, &quot;new&quot;,
      &quot;try&quot;, &quot;let&quot;, &quot;this&quot;, &quot;else&quot;, &quot;case&quot;,
      &quot;void&quot;, &quot;with&quot;, &quot;enum&quot;, &quot;while&quot;, &quot;break&quot;,
      &quot;catch&quot;, &quot;throw&quot;, &quot;const&quot;, &quot;yield&quot;, &quot;class&quot;,
      &quot;super&quot;, &quot;return&quot;, &quot;typeof&quot;, &quot;delete&quot;,
      &quot;switch&quot;, &quot;export&quot;, &quot;import&quot;, &quot;default&quot;,
      &quot;finally&quot;, &quot;extends&quot;, &quot;function&quot;, &quot;continue&quot;,
      &quot;debugger&quot;, &quot;instanceof&quot;
    ];

    if (result &amp;&amp; keywords.indexOf(result[0]) &gt;= 0) {
      return {
        type: Token.Keyword,
        value: result[0]
      };
    }

    return null;
  },

  /*
   * Extract a JavaScript identifier out of the next sequence of
   * characters or return &#039;null&#039; if its not possible. In addition,
   * to Identifier this method can also produce BooleanLiteral
   * (true/false) and NullLiteral (null).
   */
  scanIdentifier: function() {
    var id = &quot;&quot;;
    var index = 0;
    var type, char;

    function isNonAsciiIdentifierStart(code) {
      return nonAsciiIdentifierStartTable.indexOf(code) &gt; -1;
    }

    function isNonAsciiIdentifierPart(code) {
      return isNonAsciiIdentifierStart(code) || nonAsciiIdentifierPartTable.indexOf(code) &gt; -1;
    }

    function isHexDigit(str) {
      return (/^[0-9a-fA-F]$/).test(str);
    }

    var readUnicodeEscapeSequence = function() {
      /*jshint validthis:true */
      index += 1;

      if (this.peek(index) !== &quot;u&quot;) {
        return null;
      }

      var ch1 = this.peek(index + 1);
      var ch2 = this.peek(index + 2);
      var ch3 = this.peek(index + 3);
      var ch4 = this.peek(index + 4);
      var code;

      if (isHexDigit(ch1) &amp;&amp; isHexDigit(ch2) &amp;&amp; isHexDigit(ch3) &amp;&amp; isHexDigit(ch4)) {
        code = parseInt(ch1 + ch2 + ch3 + ch4, 16);

        if (asciiIdentifierPartTable[code] || isNonAsciiIdentifierPart(code)) {
          index += 5;
          return &quot;\\u&quot; + ch1 + ch2 + ch3 + ch4;
        }

        return null;
      }

      return null;
    }.bind(this);

    var getIdentifierStart = function() {
      /*jshint validthis:true */
      var chr = this.peek(index);
      var code = chr.charCodeAt(0);

      if (code === 92) {
        return readUnicodeEscapeSequence();
      }

      if (code &lt; 128) {
        if (asciiIdentifierStartTable[code]) {
          index += 1;
          return chr;
        }

        return null;
      }

      if (isNonAsciiIdentifierStart(code)) {
        index += 1;
        return chr;
      }

      return null;
    }.bind(this);

    var getIdentifierPart = function() {
      /*jshint validthis:true */
      var chr = this.peek(index);
      var code = chr.charCodeAt(0);

      if (code === 92) {
        return readUnicodeEscapeSequence();
      }

      if (code &lt; 128) {
        if (asciiIdentifierPartTable[code]) {
          index += 1;
          return chr;
        }

        return null;
      }

      if (isNonAsciiIdentifierPart(code)) {
        index += 1;
        return chr;
      }

      return null;
    }.bind(this);

    function removeEscapeSequences(id) {
      return id.replace(/\\u([0-9a-fA-F]{4})/g, function(m0, codepoint) {
        return String.fromCharCode(parseInt(codepoint, 16));
      });
    }

    char = getIdentifierStart();
    if (char === null) {
      return null;
    }

    id = char;
    for (;;) {
      char = getIdentifierPart();

      if (char === null) {
        break;
      }

      id += char;
    }

    switch (id) {
    case &quot;true&quot;:
    case &quot;false&quot;:
      type = Token.BooleanLiteral;
      break;
    case &quot;null&quot;:
      type = Token.NullLiteral;
      break;
    default:
      type = Token.Identifier;
    }

    return {
      type: type,
      value: removeEscapeSequences(id),
      text: id,
      tokenLength: id.length
    };
  },

  /*
   * Extract a numeric literal out of the next sequence of
   * characters or return &#039;null&#039; if its not possible. This method
   * supports all numeric literals described in section 7.8.3
   * of the EcmaScript 5 specification.
   *
   * This method&#039;s implementation was heavily influenced by the
   * scanNumericLiteral function in the Esprima parser&#039;s source code.
   */
  scanNumericLiteral: function() {
    var index = 0;
    var value = &quot;&quot;;
    var length = this.input.length;
    var char = this.peek(index);
    var bad;
    var isAllowedDigit = isDecimalDigit;
    var base = 10;
    var isLegacy = false;

    function isDecimalDigit(str) {
      return (/^[0-9]$/).test(str);
    }

    function isOctalDigit(str) {
      return (/^[0-7]$/).test(str);
    }

    function isBinaryDigit(str) {
      return (/^[01]$/).test(str);
    }

    function isHexDigit(str) {
      return (/^[0-9a-fA-F]$/).test(str);
    }

    function isIdentifierStart(ch) {
      return (ch === &quot;$&quot;) || (ch === &quot;_&quot;) || (ch === &quot;\\&quot;) ||
        (ch &gt;= &quot;a&quot; &amp;&amp; ch &lt;= &quot;z&quot;) || (ch &gt;= &quot;A&quot; &amp;&amp; ch &lt;= &quot;Z&quot;);
    }

    // Numbers must start either with a decimal digit or a point.

    if (char !== &quot;.&quot; &amp;&amp; !isDecimalDigit(char)) {
      return null;
    }

    if (char !== &quot;.&quot;) {
      value = this.peek(index);
      index += 1;
      char = this.peek(index);

      if (value === &quot;0&quot;) {
        // Base-16 numbers.
        if (char === &quot;x&quot; || char === &quot;X&quot;) {
          isAllowedDigit = isHexDigit;
          base = 16;

          index += 1;
          value += char;
        }

        // Base-8 numbers.
        if (char === &quot;o&quot; || char === &quot;O&quot;) {
          isAllowedDigit = isOctalDigit;
          base = 8;

          if (!state.inES6(true)) {
            this.trigger(&quot;warning&quot;, {
              code: &quot;W119&quot;,
              line: this.line,
              character: this.char,
              data: [ &quot;Octal integer literal&quot;, &quot;6&quot; ]
            });
          }

          index += 1;
          value += char;
        }

        // Base-2 numbers.
        if (char === &quot;b&quot; || char === &quot;B&quot;) {
          isAllowedDigit = isBinaryDigit;
          base = 2;

          if (!state.inES6(true)) {
            this.trigger(&quot;warning&quot;, {
              code: &quot;W119&quot;,
              line: this.line,
              character: this.char,
              data: [ &quot;Binary integer literal&quot;, &quot;6&quot; ]
            });
          }

          index += 1;
          value += char;
        }

        // Legacy base-8 numbers.
        if (isOctalDigit(char)) {
          isAllowedDigit = isOctalDigit;
          base = 8;
          isLegacy = true;
          bad = false;

          index += 1;
          value += char;
        }

        // Decimal numbers that start with &#039;0&#039; such as &#039;09&#039; are illegal
        // but we still parse them and return as malformed.

        if (!isOctalDigit(char) &amp;&amp; isDecimalDigit(char)) {
          index += 1;
          value += char;
        }
      }

      while (index &lt; length) {
        char = this.peek(index);

        if (isLegacy &amp;&amp; isDecimalDigit(char)) {
          // Numbers like &#039;019&#039; (note the 9) are not valid octals
          // but we still parse them and mark as malformed.
          bad = true;
        } else if (!isAllowedDigit(char)) {
          break;
        }
        value += char;
        index += 1;
      }

      if (isAllowedDigit !== isDecimalDigit) {
        if (!isLegacy &amp;&amp; value.length &lt;= 2) { // 0x
          return {
            type: Token.NumericLiteral,
            value: value,
            isMalformed: true
          };
        }

        if (index &lt; length) {
          char = this.peek(index);
          if (isIdentifierStart(char)) {
            return null;
          }
        }

        return {
          type: Token.NumericLiteral,
          value: value,
          base: base,
          isLegacy: isLegacy,
          isMalformed: false
        };
      }
    }

    // Decimal digits.

    if (char === &quot;.&quot;) {
      value += char;
      index += 1;

      while (index &lt; length) {
        char = this.peek(index);
        if (!isDecimalDigit(char)) {
          break;
        }
        value += char;
        index += 1;
      }
    }

    // Exponent part.

    if (char === &quot;e&quot; || char === &quot;E&quot;) {
      value += char;
      index += 1;
      char = this.peek(index);

      if (char === &quot;+&quot; || char === &quot;-&quot;) {
        value += this.peek(index);
        index += 1;
      }

      char = this.peek(index);
      if (isDecimalDigit(char)) {
        value += char;
        index += 1;

        while (index &lt; length) {
          char = this.peek(index);
          if (!isDecimalDigit(char)) {
            break;
          }
          value += char;
          index += 1;
        }
      } else {
        return null;
      }
    }

    if (index &lt; length) {
      char = this.peek(index);
      if (isIdentifierStart(char)) {
        return null;
      }
    }

    return {
      type: Token.NumericLiteral,
      value: value,
      base: base,
      isMalformed: !isFinite(value)
    };
  },


  // Assumes previously parsed character was \ (=== &#039;\\&#039;) and was not skipped.
  scanEscapeSequence: function(checks) {
    var allowNewLine = false;
    var jump = 1;
    this.skip();
    var char = this.peek();

    switch (char) {
    case &quot;&#039;&quot;:
      this.triggerAsync(&quot;warning&quot;, {
        code: &quot;W114&quot;,
        line: this.line,
        character: this.char,
        data: [ &quot;\\&#039;&quot; ]
      }, checks, function() {return state.jsonMode; });
      break;
    case &quot;b&quot;:
      char = &quot;\\b&quot;;
      break;
    case &quot;f&quot;:
      char = &quot;\\f&quot;;
      break;
    case &quot;n&quot;:
      char = &quot;\\n&quot;;
      break;
    case &quot;r&quot;:
      char = &quot;\\r&quot;;
      break;
    case &quot;t&quot;:
      char = &quot;\\t&quot;;
      break;
    case &quot;0&quot;:
      char = &quot;\\0&quot;;

      // Octal literals fail in strict mode.
      // Check if the number is between 00 and 07.
      var n = parseInt(this.peek(1), 10);
      this.triggerAsync(&quot;warning&quot;, {
        code: &quot;W115&quot;,
        line: this.line,
        character: this.char
      }, checks,
      function() { return n &gt;= 0 &amp;&amp; n &lt;= 7 &amp;&amp; state.isStrict(); });
      break;
    case &quot;u&quot;:
      var hexCode = this.input.substr(1, 4);
      var code = parseInt(hexCode, 16);
      if (isNaN(code)) {
        this.trigger(&quot;warning&quot;, {
          code: &quot;W052&quot;,
          line: this.line,
          character: this.char,
          data: [ &quot;u&quot; + hexCode ]
        });
      }
      char = String.fromCharCode(code);
      jump = 5;
      break;
    case &quot;v&quot;:
      this.triggerAsync(&quot;warning&quot;, {
        code: &quot;W114&quot;,
        line: this.line,
        character: this.char,
        data: [ &quot;\\v&quot; ]
      }, checks, function() { return state.jsonMode; });

      char = &quot;\v&quot;;
      break;
    case &quot;x&quot;:
      var  x = parseInt(this.input.substr(1, 2), 16);

      this.triggerAsync(&quot;warning&quot;, {
        code: &quot;W114&quot;,
        line: this.line,
        character: this.char,
        data: [ &quot;\\x-&quot; ]
      }, checks, function() { return state.jsonMode; });

      char = String.fromCharCode(x);
      jump = 3;
      break;
    case &quot;\\&quot;:
      char = &quot;\\\\&quot;;
      break;
    case &quot;\&quot;&quot;:
      char = &quot;\\\&quot;&quot;;
      break;
    case &quot;/&quot;:
      break;
    case &quot;&quot;:
      allowNewLine = true;
      char = &quot;&quot;;
      break;
    }

    return { char: char, jump: jump, allowNewLine: allowNewLine };
  },

  /*
   * Extract a template literal out of the next sequence of characters
   * and/or lines or return &#039;null&#039; if its not possible. Since template
   * literals can span across multiple lines, this method has to move
   * the char pointer.
   */
  scanTemplateLiteral: function(checks) {
    var tokenType;
    var value = &quot;&quot;;
    var ch;
    var startLine = this.line;
    var startChar = this.char;
    var depth = this.templateStarts.length;

    if (this.peek() === &quot;`&quot;) {
      if (!state.inES6(true)) {
        this.trigger(&quot;warning&quot;, {
          code: &quot;W119&quot;,
          line: this.line,
          character: this.char,
          data: [&quot;template literal syntax&quot;, &quot;6&quot;]
        });
      }
      // Template must start with a backtick.
      tokenType = Token.TemplateHead;
      this.templateStarts.push({ line: this.line, char: this.char });
      depth = this.templateStarts.length;
      this.skip(1);
      this.pushContext(Context.Template);
    } else if (this.inContext(Context.Template) &amp;&amp; this.peek() === &quot;}&quot;) {
      // If we&#039;re in a template context, and we have a &#039;}&#039;, lex a TemplateMiddle.
      tokenType = Token.TemplateMiddle;
    } else {
      // Go lex something else.
      return null;
    }

    while (this.peek() !== &quot;`&quot;) {
      while ((ch = this.peek()) === &quot;&quot;) {
        value += &quot;\n&quot;;
        if (!this.nextLine()) {
          // Unclosed template literal --- point to the starting &quot;`&quot;
          var startPos = this.templateStarts.pop();
          this.trigger(&quot;error&quot;, {
            code: &quot;E052&quot;,
            line: startPos.line,
            character: startPos.char
          });
          return {
            type: tokenType,
            value: value,
            startLine: startLine,
            startChar: startChar,
            isUnclosed: true,
            depth: depth,
            context: this.popContext()
          };
        }
      }

      if (ch === &#039;$&#039; &amp;&amp; this.peek(1) === &#039;{&#039;) {
        value += &#039;${&#039;;
        this.skip(2);
        return {
          type: tokenType,
          value: value,
          startLine: startLine,
          startChar: startChar,
          isUnclosed: false,
          depth: depth,
          context: this.currentContext()
        };
      } else if (ch === &#039;\\&#039;) {
        var escape = this.scanEscapeSequence(checks);
        value += escape.char;
        this.skip(escape.jump);
      } else if (ch !== &#039;`&#039;) {
        // Otherwise, append the value and continue.
        value += ch;
        this.skip(1);
      }
    }

    // Final value is either NoSubstTemplate or TemplateTail
    tokenType = tokenType === Token.TemplateHead ? Token.NoSubstTemplate : Token.TemplateTail;
    this.skip(1);
    this.templateStarts.pop();

    return {
      type: tokenType,
      value: value,
      startLine: startLine,
      startChar: startChar,
      isUnclosed: false,
      depth: depth,
      context: this.popContext()
    };
  },

  /*
   * Extract a string out of the next sequence of characters and/or
   * lines or return &#039;null&#039; if its not possible. Since strings can
   * span across multiple lines this method has to move the char
   * pointer.
   *
   * This method recognizes pseudo-multiline JavaScript strings:
   *
   *   var str = &quot;hello\
   *   world&quot;;
   */
  scanStringLiteral: function(checks) {
    /*jshint loopfunc:true */
    var quote = this.peek();

    // String must start with a quote.
    if (quote !== &quot;\&quot;&quot; &amp;&amp; quote !== &quot;&#039;&quot;) {
      return null;
    }

    // In JSON strings must always use double quotes.
    this.triggerAsync(&quot;warning&quot;, {
      code: &quot;W108&quot;,
      line: this.line,
      character: this.char // +1?
    }, checks, function() { return state.jsonMode &amp;&amp; quote !== &quot;\&quot;&quot;; });

    var value = &quot;&quot;;
    var startLine = this.line;
    var startChar = this.char;
    var allowNewLine = false;

    this.skip();

    while (this.peek() !== quote) {
      if (this.peek() === &quot;&quot;) { // End Of Line

        // If an EOL is not preceded by a backslash, show a warning
        // and proceed like it was a legit multi-line string where
        // author simply forgot to escape the newline symbol.
        //
        // Another approach is to implicitly close a string on EOL
        // but it generates too many false positives.

        if (!allowNewLine) {
          this.trigger(&quot;warning&quot;, {
            code: &quot;W112&quot;,
            line: this.line,
            character: this.char
          });
        } else {
          allowNewLine = false;

          // Otherwise show a warning if multistr option was not set.
          // For JSON, show warning no matter what.

          this.triggerAsync(&quot;warning&quot;, {
            code: &quot;W043&quot;,
            line: this.line,
            character: this.char
          }, checks, function() { return !state.option.multistr; });

          this.triggerAsync(&quot;warning&quot;, {
            code: &quot;W042&quot;,
            line: this.line,
            character: this.char
          }, checks, function() { return state.jsonMode &amp;&amp; state.option.multistr; });
        }

        // If we get an EOF inside of an unclosed string, show an
        // error and implicitly close it at the EOF point.

        if (!this.nextLine()) {
          this.trigger(&quot;error&quot;, {
            code: &quot;E029&quot;,
            line: startLine,
            character: startChar
          });

          return {
            type: Token.StringLiteral,
            value: value,
            startLine: startLine,
            startChar: startChar,
            isUnclosed: true,
            quote: quote
          };
        }

      } else { // Any character other than End Of Line

        allowNewLine = false;
        var char = this.peek();
        var jump = 1; // A length of a jump, after we&#039;re done
                      // parsing this character.

        if (char &lt; &quot; &quot;) {
          // Warn about a control character in a string.
          this.trigger(&quot;warning&quot;, {
            code: &quot;W113&quot;,
            line: this.line,
            character: this.char,
            data: [ &quot;&lt;non-printable&gt;&quot; ]
          });
        }

        // Special treatment for some escaped characters.
        if (char === &quot;\\&quot;) {
          var parsed = this.scanEscapeSequence(checks);
          char = parsed.char;
          jump = parsed.jump;
          allowNewLine = parsed.allowNewLine;
        }

        value += char;
        this.skip(jump);
      }
    }

    this.skip();
    return {
      type: Token.StringLiteral,
      value: value,
      startLine: startLine,
      startChar: startChar,
      isUnclosed: false,
      quote: quote
    };
  },

  /*
   * Extract a regular expression out of the next sequence of
   * characters and/or lines or return &#039;null&#039; if its not possible.
   *
   * This method is platform dependent: it accepts almost any
   * regular expression values but then tries to compile and run
   * them using system&#039;s RegExp object. This means that there are
   * rare edge cases where one JavaScript engine complains about
   * your regular expression while others don&#039;t.
   */
  scanRegExp: function() {
    var index = 0;
    var length = this.input.length;
    var char = this.peek();
    var value = char;
    var body = &quot;&quot;;
    var flags = [];
    var malformed = false;
    var isCharSet = false;
    var terminated;

    var scanUnexpectedChars = function() {
      // Unexpected control character
      if (char &lt; &quot; &quot;) {
        malformed = true;
        this.trigger(&quot;warning&quot;, {
          code: &quot;W048&quot;,
          line: this.line,
          character: this.char
        });
      }

      // Unexpected escaped character
      if (char === &quot;&lt;&quot;) {
        malformed = true;
        this.trigger(&quot;warning&quot;, {
          code: &quot;W049&quot;,
          line: this.line,
          character: this.char,
          data: [ char ]
        });
      }
    }.bind(this);

    // Regular expressions must start with &#039;/&#039;
    if (!this.prereg || char !== &quot;/&quot;) {
      return null;
    }

    index += 1;
    terminated = false;

    // Try to get everything in between slashes. A couple of
    // cases aside (see scanUnexpectedChars) we don&#039;t really
    // care whether the resulting expression is valid or not.
    // We will check that later using the RegExp object.

    while (index &lt; length) {
      char = this.peek(index);
      value += char;
      body += char;

      if (isCharSet) {
        if (char === &quot;]&quot;) {
          if (this.peek(index - 1) !== &quot;\\&quot; || this.peek(index - 2) === &quot;\\&quot;) {
            isCharSet = false;
          }
        }

        if (char === &quot;\\&quot;) {
          index += 1;
          char = this.peek(index);
          body += char;
          value += char;

          scanUnexpectedChars();
        }

        index += 1;
        continue;
      }

      if (char === &quot;\\&quot;) {
        index += 1;
        char = this.peek(index);
        body += char;
        value += char;

        scanUnexpectedChars();

        if (char === &quot;/&quot;) {
          index += 1;
          continue;
        }

        if (char === &quot;[&quot;) {
          index += 1;
          continue;
        }
      }

      if (char === &quot;[&quot;) {
        isCharSet = true;
        index += 1;
        continue;
      }

      if (char === &quot;/&quot;) {
        body = body.substr(0, body.length - 1);
        terminated = true;
        index += 1;
        break;
      }

      index += 1;
    }

    // A regular expression that was never closed is an
    // error from which we cannot recover.

    if (!terminated) {
      this.trigger(&quot;error&quot;, {
        code: &quot;E015&quot;,
        line: this.line,
        character: this.from
      });

      return void this.trigger(&quot;fatal&quot;, {
        line: this.line,
        from: this.from
      });
    }

    // Parse flags (if any).

    while (index &lt; length) {
      char = this.peek(index);
      if (!/[gim]/.test(char)) {
        break;
      }
      flags.push(char);
      value += char;
      index += 1;
    }

    // Check regular expression for correctness.

    try {
      new RegExp(body, flags.join(&quot;&quot;));
    } catch (err) {
      malformed = true;
      this.trigger(&quot;error&quot;, {
        code: &quot;E016&quot;,
        line: this.line,
        character: this.char,
        data: [ err.message ] // Platform dependent!
      });
    }

    return {
      type: Token.RegExp,
      value: value,
      flags: flags,
      isMalformed: malformed
    };
  },

  /*
   * Scan for any occurrence of non-breaking spaces. Non-breaking spaces
   * can be mistakenly typed on OS X with option-space. Non UTF-8 web
   * pages with non-breaking pages produce syntax errors.
   */
  scanNonBreakingSpaces: function() {
    return state.option.nonbsp ?
      this.input.search(/(\u00A0)/) : -1;
  },

  /*
   * Scan for characters that get silently deleted by one or more browsers.
   */
  scanUnsafeChars: function() {
    return this.input.search(reg.unsafeChars);
  },

  /*
   * Produce the next raw token or return &#039;null&#039; if no tokens can be matched.
   * This method skips over all space characters.
   */
  next: function(checks) {
    this.from = this.char;

    // Move to the next non-space character.
    while (/\s/.test(this.peek())) {
      this.from += 1;
      this.skip();
    }

    // Methods that work with multi-line structures and move the
    // character pointer.

    var match = this.scanComments() ||
      this.scanStringLiteral(checks) ||
      this.scanTemplateLiteral(checks);

    if (match) {
      return match;
    }

    // Methods that don&#039;t move the character pointer.

    match =
      this.scanRegExp() ||
      this.scanPunctuator() ||
      this.scanKeyword() ||
      this.scanIdentifier() ||
      this.scanNumericLiteral();

    if (match) {
      this.skip(match.tokenLength || match.value.length);
      return match;
    }

    // No token could be matched, give up.

    return null;
  },

  /*
   * Switch to the next line and reset all char pointers. Once
   * switched, this method also checks for other minor warnings.
   */
  nextLine: function() {
    var char;

    if (this.line &gt;= this.getLines().length) {
      return false;
    }

    this.input = this.getLines()[this.line];
    this.line += 1;
    this.char = 1;
    this.from = 1;

    var inputTrimmed = this.input.trim();

    var startsWith = function() {
      return _.some(arguments, function(prefix) {
        return inputTrimmed.indexOf(prefix) === 0;
      });
    };

    var endsWith = function() {
      return _.some(arguments, function(suffix) {
        return inputTrimmed.indexOf(suffix, inputTrimmed.length - suffix.length) !== -1;
      });
    };

    // If we are ignoring linter errors, replace the input with empty string
    // if it doesn&#039;t already at least start or end a multi-line comment
    if (this.ignoringLinterErrors === true) {
      if (!startsWith(&quot;/*&quot;, &quot;//&quot;) &amp;&amp; !(this.inComment &amp;&amp; endsWith(&quot;*/&quot;))) {
        this.input = &quot;&quot;;
      }
    }

    char = this.scanNonBreakingSpaces();
    if (char &gt;= 0) {
      this.trigger(&quot;warning&quot;, { code: &quot;W125&quot;, line: this.line, character: char + 1 });
    }

    this.input = this.input.replace(/\t/g, state.tab);
    char = this.scanUnsafeChars();

    if (char &gt;= 0) {
      this.trigger(&quot;warning&quot;, { code: &quot;W100&quot;, line: this.line, character: char });
    }

    // If there is a limit on line length, warn when lines get too
    // long.

    if (!this.ignoringLinterErrors &amp;&amp; state.option.maxlen &amp;&amp;
      state.option.maxlen &lt; this.input.length) {
      var inComment = this.inComment ||
        startsWith.call(inputTrimmed, &quot;//&quot;) ||
        startsWith.call(inputTrimmed, &quot;/*&quot;);

      var shouldTriggerError = !inComment || !reg.maxlenException.test(inputTrimmed);

      if (shouldTriggerError) {
        this.trigger(&quot;warning&quot;, { code: &quot;W101&quot;, line: this.line, character: this.input.length });
      }
    }

    return true;
  },

  /*
   * This is simply a synonym for nextLine() method with a friendlier
   * public name.
   */
  start: function() {
    this.nextLine();
  },

  /*
   * Produce the next token. This function is called by advance() to get
   * the next token. It returns a token in a JSLint-compatible format.
   */
  token: function() {
    /*jshint loopfunc:true */
    var checks = asyncTrigger();
    var token;


    function isReserved(token, isProperty) {
      if (!token.reserved) {
        return false;
      }
      var meta = token.meta;

      if (meta &amp;&amp; meta.isFutureReservedWord &amp;&amp; state.inES5()) {
        // ES3 FutureReservedWord in an ES5 environment.
        if (!meta.es5) {
          return false;
        }

        // Some ES5 FutureReservedWord identifiers are active only
        // within a strict mode environment.
        if (meta.strictOnly) {
          if (!state.option.strict &amp;&amp; !state.isStrict()) {
            return false;
          }
        }

        if (isProperty) {
          return false;
        }
      }

      return true;
    }

    // Produce a token object.
    var create = function(type, value, isProperty, token) {
      /*jshint validthis:true */
      var obj;

      if (type !== &quot;(endline)&quot; &amp;&amp; type !== &quot;(end)&quot;) {
        this.prereg = false;
      }

      if (type === &quot;(punctuator)&quot;) {
        switch (value) {
        case &quot;.&quot;:
        case &quot;)&quot;:
        case &quot;~&quot;:
        case &quot;#&quot;:
        case &quot;]&quot;:
        case &quot;++&quot;:
        case &quot;--&quot;:
          this.prereg = false;
          break;
        default:
          this.prereg = true;
        }

        obj = Object.create(state.syntax[value] || state.syntax[&quot;(error)&quot;]);
      }

      if (type === &quot;(identifier)&quot;) {
        if (value === &quot;return&quot; || value === &quot;case&quot; || value === &quot;typeof&quot;) {
          this.prereg = true;
        }

        if (_.has(state.syntax, value)) {
          obj = Object.create(state.syntax[value] || state.syntax[&quot;(error)&quot;]);

          // If this can&#039;t be a reserved keyword, reset the object.
          if (!isReserved(obj, isProperty &amp;&amp; type === &quot;(identifier)&quot;)) {
            obj = null;
          }
        }
      }

      if (!obj) {
        obj = Object.create(state.syntax[type]);
      }

      obj.identifier = (type === &quot;(identifier)&quot;);
      obj.type = obj.type || type;
      obj.value = value;
      obj.line = this.line;
      obj.character = this.char;
      obj.from = this.from;
      if (obj.identifier &amp;&amp; token) obj.raw_text = token.text || token.value;
      if (token &amp;&amp; token.startLine &amp;&amp; token.startLine !== this.line) {
        obj.startLine = token.startLine;
      }
      if (token &amp;&amp; token.context) {
        // Context of current token
        obj.context = token.context;
      }
      if (token &amp;&amp; token.depth) {
        // Nested template depth
        obj.depth = token.depth;
      }
      if (token &amp;&amp; token.isUnclosed) {
        // Mark token as unclosed string / template literal
        obj.isUnclosed = token.isUnclosed;
      }

      if (isProperty &amp;&amp; obj.identifier) {
        obj.isProperty = isProperty;
      }

      obj.check = checks.check;

      return obj;
    }.bind(this);

    for (;;) {
      if (!this.input.length) {
        if (this.nextLine()) {
          return create(&quot;(endline)&quot;, &quot;&quot;);
        }

        if (this.exhausted) {
          return null;
        }

        this.exhausted = true;
        return create(&quot;(end)&quot;, &quot;&quot;);
      }

      token = this.next(checks);

      if (!token) {
        if (this.input.length) {
          // Unexpected character.
          this.trigger(&quot;error&quot;, {
            code: &quot;E024&quot;,
            line: this.line,
            character: this.char,
            data: [ this.peek() ]
          });

          this.input = &quot;&quot;;
        }

        continue;
      }

      switch (token.type) {
      case Token.StringLiteral:
        this.triggerAsync(&quot;String&quot;, {
          line: this.line,
          char: this.char,
          from: this.from,
          startLine: token.startLine,
          startChar: token.startChar,
          value: token.value,
          quote: token.quote
        }, checks, function() { return true; });

        return create(&quot;(string)&quot;, token.value, null, token);

      case Token.TemplateHead:
        this.trigger(&quot;TemplateHead&quot;, {
          line: this.line,
          char: this.char,
          from: this.from,
          startLine: token.startLine,
          startChar: token.startChar,
          value: token.value
        });
        return create(&quot;(template)&quot;, token.value, null, token);

      case Token.TemplateMiddle:
        this.trigger(&quot;TemplateMiddle&quot;, {
          line: this.line,
          char: this.char,
          from: this.from,
          startLine: token.startLine,
          startChar: token.startChar,
          value: token.value
        });
        return create(&quot;(template middle)&quot;, token.value, null, token);

      case Token.TemplateTail:
        this.trigger(&quot;TemplateTail&quot;, {
          line: this.line,
          char: this.char,
          from: this.from,
          startLine: token.startLine,
          startChar: token.startChar,
          value: token.value
        });
        return create(&quot;(template tail)&quot;, token.value, null, token);

      case Token.NoSubstTemplate:
        this.trigger(&quot;NoSubstTemplate&quot;, {
          line: this.line,
          char: this.char,
          from: this.from,
          startLine: token.startLine,
          startChar: token.startChar,
          value: token.value
        });
        return create(&quot;(no subst template)&quot;, token.value, null, token);

      case Token.Identifier:
        this.triggerAsync(&quot;Identifier&quot;, {
          line: this.line,
          char: this.char,
          from: this.form,
          name: token.value,
          raw_name: token.text,
          isProperty: state.tokens.curr.id === &quot;.&quot;
        }, checks, function() { return true; });

        /* falls through */
      case Token.Keyword:
      case Token.NullLiteral:
      case Token.BooleanLiteral:
        return create(&quot;(identifier)&quot;, token.value, state.tokens.curr.id === &quot;.&quot;, token);

      case Token.NumericLiteral:
        if (token.isMalformed) {
          this.trigger(&quot;warning&quot;, {
            code: &quot;W045&quot;,
            line: this.line,
            character: this.char,
            data: [ token.value ]
          });
        }

        this.triggerAsync(&quot;warning&quot;, {
          code: &quot;W114&quot;,
          line: this.line,
          character: this.char,
          data: [ &quot;0x-&quot; ]
        }, checks, function() { return token.base === 16 &amp;&amp; state.jsonMode; });

        this.triggerAsync(&quot;warning&quot;, {
          code: &quot;W115&quot;,
          line: this.line,
          character: this.char
        }, checks, function() {
          return state.isStrict() &amp;&amp; token.base === 8 &amp;&amp; token.isLegacy;
        });

        this.trigger(&quot;Number&quot;, {
          line: this.line,
          char: this.char,
          from: this.from,
          value: token.value,
          base: token.base,
          isMalformed: token.malformed
        });

        return create(&quot;(number)&quot;, token.value);

      case Token.RegExp:
        return create(&quot;(regexp)&quot;, token.value);

      case Token.Comment:
        state.tokens.curr.comment = true;

        if (token.isSpecial) {
          return {
            id: &#039;(comment)&#039;,
            value: token.value,
            body: token.body,
            type: token.commentType,
            isSpecial: token.isSpecial,
            line: this.line,
            character: this.char,
            from: this.from
          };
        }

        break;

      case &quot;&quot;:
        break;

      default:
        return create(&quot;(punctuator)&quot;, token.value);
      }
    }
  }
};

exports.Lexer = Lexer;
exports.Context = Context;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
