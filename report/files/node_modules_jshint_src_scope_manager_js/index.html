<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/jshint/src/scope-manager.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/jshint/src/scope-manager.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">60.33</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">855</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">106.80</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">6.75</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">&quot;use strict&quot;;

var _      = require(&quot;lodash&quot;);
var events = require(&quot;events&quot;);

// Used to denote membership in lookup tables (a primitive value such as `true`
// would be silently rejected for the property name &quot;__proto__&quot; in some
// environments)
var marker = {};

/**
 * Creates a scope manager that handles variables and labels, storing usages
 * and resolving when variables are used and undefined
 */
var scopeManager = function(state, predefined, exported, declared) {

  var _current;
  var _scopeStack = [];

  function _newScope(type) {
    _current = {
      &quot;(labels)&quot;: Object.create(null),
      &quot;(usages)&quot;: Object.create(null),
      &quot;(breakLabels)&quot;: Object.create(null),
      &quot;(parent)&quot;: _current,
      &quot;(type)&quot;: type,
      &quot;(params)&quot;: (type === &quot;functionparams&quot; || type === &quot;catchparams&quot;) ? [] : null
    };
    _scopeStack.push(_current);
  }

  _newScope(&quot;global&quot;);
  _current[&quot;(predefined)&quot;] = predefined;

  var _currentFunctBody = _current; // this is the block after the params = function

  var usedPredefinedAndGlobals = Object.create(null);
  var impliedGlobals = Object.create(null);
  var unuseds = [];
  var emitter = new events.EventEmitter();

  function warning(code, token) {
    emitter.emit(&quot;warning&quot;, {
      code: code,
      token: token,
      data: _.slice(arguments, 2)
    });
  }

  function error(code, token) {
    emitter.emit(&quot;warning&quot;, {
      code: code,
      token: token,
      data: _.slice(arguments, 2)
    });
  }

  function _setupUsages(labelName) {
    if (!_current[&quot;(usages)&quot;][labelName]) {
      _current[&quot;(usages)&quot;][labelName] = {
        &quot;(modified)&quot;: [],
        &quot;(reassigned)&quot;: [],
        &quot;(tokens)&quot;: []
      };
    }
  }

  var _getUnusedOption = function(unused_opt) {
    if (unused_opt === undefined) {
      unused_opt = state.option.unused;
    }

    if (unused_opt === true) {
      unused_opt = &quot;last-param&quot;;
    }

    return unused_opt;
  };

  var _warnUnused = function(name, tkn, type, unused_opt) {
    var line = tkn.line;
    var chr  = tkn.from;
    var raw_name = tkn.raw_text || name;

    unused_opt = _getUnusedOption(unused_opt);

    var warnable_types = {
      &quot;vars&quot;: [&quot;var&quot;],
      &quot;last-param&quot;: [&quot;var&quot;, &quot;param&quot;],
      &quot;strict&quot;: [&quot;var&quot;, &quot;param&quot;, &quot;last-param&quot;]
    };

    if (unused_opt) {
      if (warnable_types[unused_opt] &amp;&amp; warnable_types[unused_opt].indexOf(type) !== -1) {
        warning(&quot;W098&quot;, { line: line, from: chr }, raw_name);
      }
    }

    // inconsistent - see gh-1894
    if (unused_opt || type === &quot;var&quot;) {
      unuseds.push({
        name: name,
        line: line,
        character: chr
      });
    }
  };

  /**
   * Checks the current scope for unused identifiers
   */
  function _checkForUnused() {
    // function params are handled specially
    // assume that parameters are the only thing declared in the param scope
    if (_current[&quot;(type)&quot;] === &quot;functionparams&quot;) {
      _checkParams();
      return;
    }
    var curentLabels = _current[&quot;(labels)&quot;];
    for (var labelName in curentLabels) {
      if (curentLabels[labelName]) {
        if (curentLabels[labelName][&quot;(type)&quot;] !== &quot;exception&quot; &amp;&amp;
          curentLabels[labelName][&quot;(unused)&quot;]) {
          _warnUnused(labelName, curentLabels[labelName][&quot;(token)&quot;], &quot;var&quot;);
        }
      }
    }
  }

  /**
   * Checks the current scope for unused parameters
   * Must be called in a function parameter scope
   */
  function _checkParams() {
    var params = _current[&quot;(params)&quot;];

    if (!params) {
      return;
    }

    var param = params.pop();
    var unused_opt;

    while (param) {
      var label = _current[&quot;(labels)&quot;][param];

      unused_opt = _getUnusedOption(state.funct[&quot;(unusedOption)&quot;]);

      // &#039;undefined&#039; is a special case for (function(window, undefined) { ... })();
      // patterns.
      if (param === &quot;undefined&quot;)
        return;

      if (label[&quot;(unused)&quot;]) {
        _warnUnused(param, label[&quot;(token)&quot;], &quot;param&quot;, state.funct[&quot;(unusedOption)&quot;]);
      } else if (unused_opt === &quot;last-param&quot;) {
        return;
      }

      param = params.pop();
    }
  }

  /**
   * Finds the relevant label&#039;s scope, searching from nearest outwards
   * @returns {Object} the scope the label was found in
   */
  function _getLabel(labelName) {
    for (var i = _scopeStack.length - 1 ; i &gt;= 0; --i) {
      var scopeLabels = _scopeStack[i][&quot;(labels)&quot;];
      if (scopeLabels[labelName]) {
        return scopeLabels;
      }
    }
  }

  function usedSoFarInCurrentFunction(labelName) {
    // used so far in this whole function and any sub functions
    for (var i = _scopeStack.length - 1; i &gt;= 0; i--) {
      var current = _scopeStack[i];
      if (current[&quot;(usages)&quot;][labelName]) {
        return current[&quot;(usages)&quot;][labelName];
      }
      if (current === _currentFunctBody) {
        break;
      }
    }
    return false;
  }

  function _checkOuterShadow(labelName, token) {

    // only check if shadow is outer
    if (state.option.shadow !== &quot;outer&quot;) {
      return;
    }

    var isGlobal = _currentFunctBody[&quot;(type)&quot;] === &quot;global&quot;,
      isNewFunction = _current[&quot;(type)&quot;] === &quot;functionparams&quot;;

    var outsideCurrentFunction = !isGlobal;
    for (var i = 0; i &lt; _scopeStack.length; i++) {
      var stackItem = _scopeStack[i];

      if (!isNewFunction &amp;&amp; _scopeStack[i + 1] === _currentFunctBody) {
        outsideCurrentFunction = false;
      }
      if (outsideCurrentFunction &amp;&amp; stackItem[&quot;(labels)&quot;][labelName]) {
        warning(&quot;W123&quot;, token, labelName);
      }
      if (stackItem[&quot;(breakLabels)&quot;][labelName]) {
        warning(&quot;W123&quot;, token, labelName);
      }
    }
  }

  function _latedefWarning(type, labelName, token) {
    if (state.option.latedef) {
      // if either latedef is strict and this is a function
      //    or this is not a function
      if ((state.option.latedef === true &amp;&amp; type === &quot;function&quot;) ||
        type !== &quot;function&quot;) {
        warning(&quot;W003&quot;, token, labelName);
      }
    }
  }

  var scopeManagerInst = {

    on: function(names, listener) {
      names.split(&quot; &quot;).forEach(function(name) {
        emitter.on(name, listener);
      });
    },

    isPredefined: function(labelName) {
      return !this.has(labelName) &amp;&amp; _.has(_scopeStack[0][&quot;(predefined)&quot;], labelName);
    },

    /**
     * Tell the manager we are entering a new block of code
     * @param {string} [type] - The type of the block. Valid values are
     *                          &quot;functionparams&quot;, &quot;catchparams&quot; and
     *                          &quot;functionouter&quot;
     */
    stack: function(type) {
      var previousScope = _current;
      _newScope(type);

      if (!type &amp;&amp; previousScope[&quot;(type)&quot;] === &quot;functionparams&quot;) {

        _current[&quot;(isFuncBody)&quot;] = true;
        _current[&quot;(context)&quot;] = _currentFunctBody;
        _currentFunctBody = _current;
      }
    },

    unstack: function() {
      // jshint proto: true
      var subScope = _scopeStack.length &gt; 1 ? _scopeStack[_scopeStack.length - 2] : null;
      var isUnstackingFunctionBody = _current === _currentFunctBody,
        isUnstackingFunctionParams = _current[&quot;(type)&quot;] === &quot;functionparams&quot;,
        isUnstackingFunctionOuter = _current[&quot;(type)&quot;] === &quot;functionouter&quot;;

      var i, j;
      var currentUsages = _current[&quot;(usages)&quot;];
      var currentLabels = _current[&quot;(labels)&quot;];
      var usedLabelNameList = Object.keys(currentUsages);

      if (currentUsages.__proto__ &amp;&amp; usedLabelNameList.indexOf(&quot;__proto__&quot;) === -1) {
        usedLabelNameList.push(&quot;__proto__&quot;);
      }

      for (i = 0; i &lt; usedLabelNameList.length; i++) {
        var usedLabelName = usedLabelNameList[i];

        var usage = currentUsages[usedLabelName];
        var usedLabel = currentLabels[usedLabelName];
        if (usedLabel) {
          var usedLabelType = usedLabel[&quot;(type)&quot;];

          if (usedLabel[&quot;(useOutsideOfScope)&quot;] &amp;&amp; !state.option.funcscope) {
            var usedTokens = usage[&quot;(tokens)&quot;];
            if (usedTokens) {
              for (j = 0; j &lt; usedTokens.length; j++) {
                // Keep the consistency of https://github.com/jshint/jshint/issues/2409
                if (usedLabel[&quot;(function)&quot;] === usedTokens[j][&quot;(function)&quot;]) {
                  error(&quot;W038&quot;, usedTokens[j], usedLabelName);
                }
              }
            }
          }

          // mark the label used
          _current[&quot;(labels)&quot;][usedLabelName][&quot;(unused)&quot;] = false;

          // check for modifying a const
          if (usedLabelType === &quot;const&quot; &amp;&amp; usage[&quot;(modified)&quot;]) {
            for (j = 0; j &lt; usage[&quot;(modified)&quot;].length; j++) {
              error(&quot;E013&quot;, usage[&quot;(modified)&quot;][j], usedLabelName);
            }
          }

          // check for re-assigning a function declaration
          if ((usedLabelType === &quot;function&quot; || usedLabelType === &quot;class&quot;) &amp;&amp;
              usage[&quot;(reassigned)&quot;]) {
            for (j = 0; j &lt; usage[&quot;(reassigned)&quot;].length; j++) {
              if (!usage[&quot;(reassigned)&quot;][j].ignoreW021) {
                warning(&quot;W021&quot;, usage[&quot;(reassigned)&quot;][j], usedLabelName, usedLabelType);
              }
            }
          }
          continue;
        }

        if (isUnstackingFunctionOuter) {
          state.funct[&quot;(isCapturing)&quot;] = true;
        }

        if (subScope) {
          // not exiting the global scope, so copy the usage down in case its an out of scope usage
          if (!subScope[&quot;(usages)&quot;][usedLabelName]) {
            subScope[&quot;(usages)&quot;][usedLabelName] = usage;
            if (isUnstackingFunctionBody) {
              subScope[&quot;(usages)&quot;][usedLabelName][&quot;(onlyUsedSubFunction)&quot;] = true;
            }
          } else {
            var subScopeUsage = subScope[&quot;(usages)&quot;][usedLabelName];
            subScopeUsage[&quot;(modified)&quot;] = subScopeUsage[&quot;(modified)&quot;].concat(usage[&quot;(modified)&quot;]);
            subScopeUsage[&quot;(tokens)&quot;] = subScopeUsage[&quot;(tokens)&quot;].concat(usage[&quot;(tokens)&quot;]);
            subScopeUsage[&quot;(reassigned)&quot;] =
              subScopeUsage[&quot;(reassigned)&quot;].concat(usage[&quot;(reassigned)&quot;]);
            subScopeUsage[&quot;(onlyUsedSubFunction)&quot;] = false;
          }
        } else {
          // this is exiting global scope, so we finalise everything here - we are at the end of the file
          if (typeof _current[&quot;(predefined)&quot;][usedLabelName] === &quot;boolean&quot;) {

            // remove the declared token, so we know it is used
            delete declared[usedLabelName];

            // note it as used so it can be reported
            usedPredefinedAndGlobals[usedLabelName] = marker;

            // check for re-assigning a read-only (set to false) predefined
            if (_current[&quot;(predefined)&quot;][usedLabelName] === false &amp;&amp; usage[&quot;(reassigned)&quot;]) {
              for (j = 0; j &lt; usage[&quot;(reassigned)&quot;].length; j++) {
                if (!usage[&quot;(reassigned)&quot;][j].ignoreW020) {
                  warning(&quot;W020&quot;, usage[&quot;(reassigned)&quot;][j]);
                }
              }
            }
          }
          else {
            // label usage is not predefined and we have not found a declaration
            // so report as undeclared
            if (usage[&quot;(tokens)&quot;]) {
              for (j = 0; j &lt; usage[&quot;(tokens)&quot;].length; j++) {
                var undefinedToken = usage[&quot;(tokens)&quot;][j];
                // if its not a forgiven undefined (e.g. typof x)
                if (!undefinedToken.forgiveUndef) {
                  // if undef is on and undef was on when the token was defined
                  if (state.option.undef &amp;&amp; !undefinedToken.ignoreUndef) {
                    warning(&quot;W117&quot;, undefinedToken, usedLabelName);
                  }
                  if (impliedGlobals[usedLabelName]) {
                    impliedGlobals[usedLabelName].line.push(undefinedToken.line);
                  } else {
                    impliedGlobals[usedLabelName] = {
                      name: usedLabelName,
                      line: [undefinedToken.line]
                    };
                  }
                }
              }
            }
          }
        }
      }

      // if exiting the global scope, we can warn about declared globals that haven&#039;t been used yet
      if (!subScope) {
        Object.keys(declared)
          .forEach(function(labelNotUsed) {
            _warnUnused(labelNotUsed, declared[labelNotUsed], &quot;var&quot;);
          });
      }

      // If this is not a function boundary, transfer function-scoped labels to
      // the parent block (a rough simulation of variable hoisting). Previously
      // existing labels in the parent block should take precedence so that things and stuff.
      if (subScope &amp;&amp; !isUnstackingFunctionBody &amp;&amp;
        !isUnstackingFunctionParams &amp;&amp; !isUnstackingFunctionOuter) {
        var labelNames = Object.keys(currentLabels);
        for (i = 0; i &lt; labelNames.length; i++) {

          var defLabelName = labelNames[i];
          var defLabel = currentLabels[defLabelName];

          if (!defLabel[&quot;(blockscoped)&quot;] &amp;&amp; defLabel[&quot;(type)&quot;] !== &quot;exception&quot;) {
            var shadowed = subScope[&quot;(labels)&quot;][defLabelName];

            // Do not overwrite a label if it exists in the parent scope
            // because it is shared by adjacent blocks. Copy the `unused`
            // property so that any references found within the current block
            // are counted toward that higher-level declaration.
            if (shadowed) {
              shadowed[&quot;(unused)&quot;] &amp;= defLabel[&quot;(unused)&quot;];

            // &quot;Hoist&quot; the variable to the parent block, decorating the label
            // so that future references, though technically valid, can be
            // reported as &quot;out-of-scope&quot; in the absence of the `funcscope`
            // option.
            } else {
              defLabel[&quot;(useOutsideOfScope)&quot;] =
                // Do not warn about out-of-scope usages in the global scope
                _currentFunctBody[&quot;(type)&quot;] !== &quot;global&quot; &amp;&amp;
                // When a higher scope contains a binding for the label, the
                // label is a re-declaration and should not prompt &quot;used
                // out-of-scope&quot; warnings.
                !this.funct.has(defLabelName, { excludeCurrent: true });

              subScope[&quot;(labels)&quot;][defLabelName] = defLabel;
            }

            delete currentLabels[defLabelName];
          }
        }
      }

      _checkForUnused();

      _scopeStack.pop();
      if (isUnstackingFunctionBody) {
        _currentFunctBody = _scopeStack[_.findLastIndex(_scopeStack, function(scope) {
          // if function or if global (which is at the bottom so it will only return true if we call back)
          return scope[&quot;(isFuncBody)&quot;] || scope[&quot;(type)&quot;] === &quot;global&quot;;
        })];
      }

      _current = subScope;
    },

    /**
     * Add a param to the current scope
     * @param {string} labelName
     * @param {Token} token
     * @param {string} [type=&quot;param&quot;] param type
     */
    addParam: function(labelName, token, type) {
      type = type || &quot;param&quot;;

      if (type === &quot;exception&quot;) {
        // if defined in the current function
        var previouslyDefinedLabelType = this.funct.labeltype(labelName);
        if (previouslyDefinedLabelType &amp;&amp; previouslyDefinedLabelType !== &quot;exception&quot;) {
          // and has not been used yet in the current function scope
          if (!state.option.node) {
            warning(&quot;W002&quot;, state.tokens.next, labelName);
          }
        }
      }

      // The variable was declared in the current scope
      if (_.has(_current[&quot;(labels)&quot;], labelName)) {
        _current[&quot;(labels)&quot;][labelName].duplicated = true;

      // The variable was declared in an outer scope
      } else {
        // if this scope has the variable defined, it&#039;s a re-definition error
        _checkOuterShadow(labelName, token, type);

        _current[&quot;(labels)&quot;][labelName] = {
          &quot;(type)&quot; : type,
          &quot;(token)&quot;: token,
          &quot;(unused)&quot;: true };

        _current[&quot;(params)&quot;].push(labelName);
      }

      if (_.has(_current[&quot;(usages)&quot;], labelName)) {
        var usage = _current[&quot;(usages)&quot;][labelName];
        // if its in a sub function it is not necessarily an error, just latedef
        if (usage[&quot;(onlyUsedSubFunction)&quot;]) {
          _latedefWarning(type, labelName, token);
        } else {
          // this is a clear illegal usage for block scoped variables
          warning(&quot;E056&quot;, token, labelName, type);
        }
      }
    },

    validateParams: function() {
      // This method only concerns errors for function parameters
      if (_currentFunctBody[&quot;(type)&quot;] === &quot;global&quot;) {
        return;
      }

      var isStrict = state.isStrict();
      var currentFunctParamScope = _currentFunctBody[&quot;(parent)&quot;];

      if (!currentFunctParamScope[&quot;(params)&quot;]) {
        return;
      }

      currentFunctParamScope[&quot;(params)&quot;].forEach(function(labelName) {
        var label = currentFunctParamScope[&quot;(labels)&quot;][labelName];

        if (label &amp;&amp; label.duplicated) {
          if (isStrict) {
            warning(&quot;E011&quot;, label[&quot;(token)&quot;], labelName);
          } else if (state.option.shadow !== true) {
            warning(&quot;W004&quot;, label[&quot;(token)&quot;], labelName);
          }
        }
      });
    },

    getUsedOrDefinedGlobals: function() {
      // jshint proto: true
      var list = Object.keys(usedPredefinedAndGlobals);

      // If `__proto__` is used as a global variable name, its entry in the
      // lookup table may not be enumerated by `Object.keys` (depending on the
      // environment).
      if (usedPredefinedAndGlobals.__proto__ === marker &amp;&amp;
        list.indexOf(&quot;__proto__&quot;) === -1) {
        list.push(&quot;__proto__&quot;);
      }

      return list;
    },

    /**
     * Gets an array of implied globals
     * @returns {Array.&lt;{ name: string, line: Array.&lt;number&gt;}&gt;}
     */
    getImpliedGlobals: function() {
      // jshint proto: true
      var values = _.values(impliedGlobals);
      var hasProto = false;

      // If `__proto__` is an implied global variable, its entry in the lookup
      // table may not be enumerated by `_.values` (depending on the
      // environment).
      if (impliedGlobals.__proto__) {
        hasProto = values.some(function(value) {
          return value.name === &quot;__proto__&quot;;
        });

        if (!hasProto) {
          values.push(impliedGlobals.__proto__);
        }
      }

      return values;
    },

    /**
     * Returns a list of unused variables
     * @returns {Array}
     */
    getUnuseds: function() {
      return unuseds;
    },

    has: function(labelName) {
      return Boolean(_getLabel(labelName));
    },

    labeltype: function(labelName) {
      // returns a labels type or null if not present
      var scopeLabels = _getLabel(labelName);
      if (scopeLabels) {
        return scopeLabels[labelName][&quot;(type)&quot;];
      }
      return null;
    },

    /**
     * for the exported options, indicating a variable is used outside the file
     */
    addExported: function(labelName) {
      var globalLabels = _scopeStack[0][&quot;(labels)&quot;];
      if (_.has(declared, labelName)) {
        // remove the declared token, so we know it is used
        delete declared[labelName];
      } else if (_.has(globalLabels, labelName)) {
        globalLabels[labelName][&quot;(unused)&quot;] = false;
      } else {
        for (var i = 1; i &lt; _scopeStack.length; i++) {
          var scope = _scopeStack[i];
          // if `scope.(type)` is not defined, it is a block scope
          if (!scope[&quot;(type)&quot;]) {
            if (_.has(scope[&quot;(labels)&quot;], labelName) &amp;&amp;
                !scope[&quot;(labels)&quot;][labelName][&quot;(blockscoped)&quot;]) {
              scope[&quot;(labels)&quot;][labelName][&quot;(unused)&quot;] = false;
              return;
            }
          } else {
            break;
          }
        }
        exported[labelName] = true;
      }
    },

    /**
     * Mark an indentifier as es6 module exported
     */
    setExported: function(labelName, token) {
      this.block.use(labelName, token);
    },

    /**
     * adds an indentifier to the relevant current scope and creates warnings/errors as necessary
     * @param {string} labelName
     * @param {Object} opts
     * @param {String} opts.type - the type of the label e.g. &quot;param&quot;, &quot;var&quot;, &quot;let, &quot;const&quot;, &quot;function&quot;
     * @param {Token} opts.token - the token pointing at the declaration
     */
    addlabel: function(labelName, opts) {

      var type  = opts.type;
      var token = opts.token;
      var isblockscoped = type === &quot;let&quot; || type === &quot;const&quot; || type === &quot;class&quot;;
      var isexported    = (isblockscoped ? _current : _currentFunctBody)[&quot;(type)&quot;] === &quot;global&quot; &amp;&amp;
                          _.has(exported, labelName);

      // outer shadow check (inner is only on non-block scoped)
      _checkOuterShadow(labelName, token, type);

      // if is block scoped (let or const)
      if (isblockscoped) {

        var declaredInCurrentScope = _current[&quot;(labels)&quot;][labelName];
        // for block scoped variables, params are seen in the current scope as the root function
        // scope, so check these too.
        if (!declaredInCurrentScope &amp;&amp; _current === _currentFunctBody &amp;&amp;
          _current[&quot;(type)&quot;] !== &quot;global&quot;) {
          declaredInCurrentScope = !!_currentFunctBody[&quot;(parent)&quot;][&quot;(labels)&quot;][labelName];
        }

        // if its not already defined (which is an error, so ignore) and is used in TDZ
        if (!declaredInCurrentScope &amp;&amp; _current[&quot;(usages)&quot;][labelName]) {
          var usage = _current[&quot;(usages)&quot;][labelName];
          // if its in a sub function it is not necessarily an error, just latedef
          if (usage[&quot;(onlyUsedSubFunction)&quot;]) {
            _latedefWarning(type, labelName, token);
          } else {
            // this is a clear illegal usage for block scoped variables
            warning(&quot;E056&quot;, token, labelName, type);
          }
        }

        // if this scope has the variable defined, its a re-definition error
        if (declaredInCurrentScope) {
          warning(&quot;E011&quot;, token, labelName);
        }
        else if (state.option.shadow === &quot;outer&quot;) {

          // if shadow is outer, for block scope we want to detect any shadowing within this function
          if (scopeManagerInst.funct.has(labelName)) {
            warning(&quot;W004&quot;, token, labelName);
          }
        }

        scopeManagerInst.block.add(labelName, type, token, !isexported);

      } else {

        var declaredInCurrentFunctionScope = scopeManagerInst.funct.has(labelName);

        // check for late definition, ignore if already declared
        if (!declaredInCurrentFunctionScope &amp;&amp; usedSoFarInCurrentFunction(labelName)) {
          _latedefWarning(type, labelName, token);
        }

        // defining with a var or a function when a block scope variable of the same name
        // is in scope is an error
        if (scopeManagerInst.funct.has(labelName, { onlyBlockscoped: true })) {
          warning(&quot;E011&quot;, token, labelName);
        } else if (state.option.shadow !== true) {
          // now since we didn&#039;t get any block scope variables, test for var/function
          // shadowing
          if (declaredInCurrentFunctionScope &amp;&amp; labelName !== &quot;__proto__&quot;) {

            // see https://github.com/jshint/jshint/issues/2400
            if (_currentFunctBody[&quot;(type)&quot;] !== &quot;global&quot;) {
              warning(&quot;W004&quot;, token, labelName);
            }
          }
        }

        scopeManagerInst.funct.add(labelName, type, token, !isexported);

        if (_currentFunctBody[&quot;(type)&quot;] === &quot;global&quot;) {
          usedPredefinedAndGlobals[labelName] = marker;
        }
      }
    },

    funct: {
      /**
       * Returns the label type given certain options
       * @param labelName
       * @param {Object=} options
       * @param {Boolean=} options.onlyBlockscoped - only include block scoped labels
       * @param {Boolean=} options.excludeParams - exclude the param scope
       * @param {Boolean=} options.excludeCurrent - exclude the current scope
       * @returns {String}
       */
      labeltype: function(labelName, options) {
        var onlyBlockscoped = options &amp;&amp; options.onlyBlockscoped;
        var excludeParams = options &amp;&amp; options.excludeParams;
        var currentScopeIndex = _scopeStack.length - (options &amp;&amp; options.excludeCurrent ? 2 : 1);
        for (var i = currentScopeIndex; i &gt;= 0; i--) {
          var current = _scopeStack[i];
          if (current[&quot;(labels)&quot;][labelName] &amp;&amp;
            (!onlyBlockscoped || current[&quot;(labels)&quot;][labelName][&quot;(blockscoped)&quot;])) {
            return current[&quot;(labels)&quot;][labelName][&quot;(type)&quot;];
          }
          var scopeCheck = excludeParams ? _scopeStack[ i - 1 ] : current;
          if (scopeCheck &amp;&amp; scopeCheck[&quot;(type)&quot;] === &quot;functionparams&quot;) {
            return null;
          }
        }
        return null;
      },
      /**
       * Returns if a break label exists in the function scope
       * @param {string} labelName
       * @returns {boolean}
       */
      hasBreakLabel: function(labelName) {
        for (var i = _scopeStack.length - 1; i &gt;= 0; i--) {
          var current = _scopeStack[i];

          if (current[&quot;(breakLabels)&quot;][labelName]) {
            return true;
          }
          if (current[&quot;(type)&quot;] === &quot;functionparams&quot;) {
            return false;
          }
        }
        return false;
      },
      /**
       * Returns if the label is in the current function scope
       * See scopeManager.funct.labelType for options
       */
      has: function(labelName, options) {
        return Boolean(this.labeltype(labelName, options));
      },

      /**
       * Adds a new function scoped variable
       * see block.add for block scoped
       */
      add: function(labelName, type, tok, unused) {
        _current[&quot;(labels)&quot;][labelName] = {
          &quot;(type)&quot; : type,
          &quot;(token)&quot;: tok,
          &quot;(blockscoped)&quot;: false,
          &quot;(function)&quot;: _currentFunctBody,
          &quot;(unused)&quot;: unused };
      }
    },

    block: {

      /**
       * is the current block global?
       * @returns Boolean
       */
      isGlobal: function() {
        return _current[&quot;(type)&quot;] === &quot;global&quot;;
      },

      use: function(labelName, token) {

        // if resolves to current function params, then do not store usage just resolve
        // this is because function(a) { var a; a = a; } will resolve to the param, not
        // to the unset var
        // first check the param is used
        var paramScope = _currentFunctBody[&quot;(parent)&quot;];
        if (paramScope &amp;&amp; paramScope[&quot;(labels)&quot;][labelName] &amp;&amp;
          paramScope[&quot;(labels)&quot;][labelName][&quot;(type)&quot;] === &quot;param&quot;) {

          // then check its not declared by a block scope variable
          if (!scopeManagerInst.funct.has(labelName,
                { excludeParams: true, onlyBlockscoped: true })) {
            paramScope[&quot;(labels)&quot;][labelName][&quot;(unused)&quot;] = false;
          }
        }

        if (token &amp;&amp; (state.ignored.W117 || state.option.undef === false)) {
          token.ignoreUndef = true;
        }

        _setupUsages(labelName);

        if (token) {
          token[&quot;(function)&quot;] = _currentFunctBody;
          _current[&quot;(usages)&quot;][labelName][&quot;(tokens)&quot;].push(token);
        }
      },

      reassign: function(labelName, token) {
        token.ignoreW020 = state.ignored.W020;
        token.ignoreW021 = state.ignored.W021;

        this.modify(labelName, token);

        _current[&quot;(usages)&quot;][labelName][&quot;(reassigned)&quot;].push(token);
      },

      modify: function(labelName, token) {

        _setupUsages(labelName);

        _current[&quot;(usages)&quot;][labelName][&quot;(modified)&quot;].push(token);
      },

      /**
       * Adds a new variable
       */
      add: function(labelName, type, tok, unused) {
        _current[&quot;(labels)&quot;][labelName] = {
          &quot;(type)&quot; : type,
          &quot;(token)&quot;: tok,
          &quot;(blockscoped)&quot;: true,
          &quot;(unused)&quot;: unused };
      },

      addBreakLabel: function(labelName, opts) {
        var token = opts.token;
        if (scopeManagerInst.funct.hasBreakLabel(labelName)) {
          warning(&quot;E011&quot;, token, labelName);
        }
        else if (state.option.shadow === &quot;outer&quot;) {
          if (scopeManagerInst.funct.has(labelName)) {
            warning(&quot;W004&quot;, token, labelName);
          } else {
            _checkOuterShadow(labelName, token);
          }
        }
        _current[&quot;(breakLabels)&quot;][labelName] = token;
      }
    }
  };
  return scopeManagerInst;
};

module.exports = scopeManager;</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
