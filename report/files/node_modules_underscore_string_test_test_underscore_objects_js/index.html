<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Plato - node_modules/underscore.string/test/test_underscore/objects.js</title>

  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="">
  <meta name="author" content="">

  <!--[if lt IE 9]>
  <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->

  <link href="../../assets/css/vendor/morris.css" rel="stylesheet">
  <link href="../../assets/css/vendor/bootstrap.css" rel="stylesheet">
  <link href="../../assets/css/vendor/font-awesome.css" rel="stylesheet">
  <link href="../../assets/css/vendor/codemirror.css" rel="stylesheet">
  <link href="../../assets/css/plato.css" rel="stylesheet">
  <link href="../../assets/css/plato-file.css" rel="stylesheet">

</head>

<body>

<div class="navbar navbar-fixed-top">
  <div class="container">
    <a class="navbar-brand" href="http://github.com/es-analysis/plato">Plato on Github</a>
    <ul class="nav navbar-nav">
      <li>
        <a href="../../index.html">Report Home</a>
      </li>
    </ul>
  </div>
</div>

<div class="jumbotron">
  <div class="container">
    <h1>node_modules/underscore.string/test/test_underscore/objects.js</h1>
  </div>
</div>

<div class="container aggregate-stats">
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Maintainability <a href="http://blogs.msdn.com/b/codeanalysis/archive/2007/11/20/maintainability-index-range-and-meaning.aspx"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="A value between 0 and 100 that represents the relative ease of maintaining the code. A high value means better maintainability." data-original-title="Maintainability Index"  data-container="body"></i></a></h2>
      <p class="stat">58.51</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Lines of code <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h2>
      <p class="stat">535</p>
    </div>
  </div>
  <div class="row historical">
    <div class="col-md-6">
      <p id="chart_historical_maint" class="chart"></p>
    </div>
    <div class="col-md-6">
      <p id="chart_historical_sloc" class="chart"></p>
    </div>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h2 class="header">Difficulty  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="The difficulty measure is related to the difficulty of the program to write or understand." data-original-title="Difficulty" data-container="body"></i></a></h2>
      <p class="stat">58.12</p>
    </div>
    <div class="col-md-6">
      <h2 class="header">Estimated Errors  <a href="http://en.wikipedia.org/wiki/Halstead_complexity_measures"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Halstead's delivered bugs is an estimate for the number of errors in the implementation." data-original-title="Delivered Bugs" data-container="body"></i></a></h2>
      <p class="stat">11.31</p>
    </div>
  </div>
</div>

<div class="container charts">
  <div class="row">
    <h2 class="header">Function weight</h2>
  </div>
  <div class="row">
    <div class="col-md-6">
      <h3 class="chart-header">By Complexity <a href="http://en.wikipedia.org/wiki/Cyclomatic_complexity"><i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="This metric counts the number of distinct paths through a block of code. Lower values are better." data-original-title="Cyclomatic Complexity" data-container="body"></i></a></h3>
      <div id="fn-by-complexity" class="stat"></div>
    </div>
    <div class="col-md-6">
      <h3 class="chart-header">By SLOC  <i class="icon icon-info-sign" rel="popover" data-placement="top" data-trigger="hover" data-content="Source Lines of Code / Logical Lines of Code" data-original-title="SLOC/LSLOC" data-container="body"></i></h3>
      <div id="fn-by-sloc" class="stat"></div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row">
    <textarea id="file-source" class="col-md-12">$(document).ready(function() {

  module(&quot;Objects&quot;);

  test(&quot;objects: keys&quot;, function() {
    var exception = /object/;
    equals(_.keys({one : 1, two : 2}).join(&#039;, &#039;), &#039;one, two&#039;, &#039;can extract the keys from an object&#039;);
    // the test above is not safe because it relies on for-in enumeration order
    var a = []; a[1] = 0;
    equals(_.keys(a).join(&#039;, &#039;), &#039;1&#039;, &#039;is not fooled by sparse arrays; see issue #95&#039;);
    raises(function() { _.keys(null); }, exception, &#039;throws an error for `null` values&#039;);
    raises(function() { _.keys(void 0); }, exception, &#039;throws an error for `undefined` values&#039;);
    raises(function() { _.keys(1); }, exception, &#039;throws an error for number primitives&#039;);
    raises(function() { _.keys(&#039;a&#039;); }, exception, &#039;throws an error for string primitives&#039;);
    raises(function() { _.keys(true); }, exception, &#039;throws an error for boolean primitives&#039;);
  });

  test(&quot;objects: values&quot;, function() {
    equals(_.values({one : 1, two : 2}).join(&#039;, &#039;), &#039;1, 2&#039;, &#039;can extract the values from an object&#039;);
  });

  test(&quot;objects: functions&quot;, function() {
    var obj = {a : &#039;dash&#039;, b : _.map, c : (/yo/), d : _.reduce};
    ok(_.isEqual([&#039;b&#039;, &#039;d&#039;], _.functions(obj)), &#039;can grab the function names of any passed-in object&#039;);

    var Animal = function(){};
    Animal.prototype.run = function(){};
    equals(_.functions(new Animal).join(&#039;&#039;), &#039;run&#039;, &#039;also looks up functions on the prototype&#039;);
  });

  test(&quot;objects: extend&quot;, function() {
    var result;
    equals(_.extend({}, {a:&#039;b&#039;}).a, &#039;b&#039;, &#039;can extend an object with the attributes of another&#039;);
    equals(_.extend({a:&#039;x&#039;}, {a:&#039;b&#039;}).a, &#039;b&#039;, &#039;properties in source override destination&#039;);
    equals(_.extend({x:&#039;x&#039;}, {a:&#039;b&#039;}).x, &#039;x&#039;, &#039;properties not in source dont get overriden&#039;);
    result = _.extend({x:&#039;x&#039;}, {a:&#039;a&#039;}, {b:&#039;b&#039;});
    ok(_.isEqual(result, {x:&#039;x&#039;, a:&#039;a&#039;, b:&#039;b&#039;}), &#039;can extend from multiple source objects&#039;);
    result = _.extend({x:&#039;x&#039;}, {a:&#039;a&#039;, x:2}, {a:&#039;b&#039;});
    ok(_.isEqual(result, {x:2, a:&#039;b&#039;}), &#039;extending from multiple source objects last property trumps&#039;);
    result = _.extend({}, {a: void 0, b: null});
    equals(_.keys(result).join(&#039;&#039;), &#039;ab&#039;, &#039;extend does not copy undefined values&#039;);
  });

  test(&quot;objects: defaults&quot;, function() {
    var result;
    var options = {zero: 0, one: 1, empty: &quot;&quot;, nan: NaN, string: &quot;string&quot;};

    _.defaults(options, {zero: 1, one: 10, twenty: 20});
    equals(options.zero, 0, &#039;value exists&#039;);
    equals(options.one, 1, &#039;value exists&#039;);
    equals(options.twenty, 20, &#039;default applied&#039;);

    _.defaults(options, {empty: &quot;full&quot;}, {nan: &quot;nan&quot;}, {word: &quot;word&quot;}, {word: &quot;dog&quot;});
    equals(options.empty, &quot;&quot;, &#039;value exists&#039;);
    ok(_.isNaN(options.nan), &quot;NaN isn&#039;t overridden&quot;);
    equals(options.word, &quot;word&quot;, &#039;new value is added, first one wins&#039;);
  });

  test(&quot;objects: clone&quot;, function() {
    var moe = {name : &#039;moe&#039;, lucky : [13, 27, 34]};
    var clone = _.clone(moe);
    equals(clone.name, &#039;moe&#039;, &#039;the clone as the attributes of the original&#039;);

    clone.name = &#039;curly&#039;;
    ok(clone.name == &#039;curly&#039; &amp;&amp; moe.name == &#039;moe&#039;, &#039;clones can change shallow attributes without affecting the original&#039;);

    clone.lucky.push(101);
    equals(_.last(moe.lucky), 101, &#039;changes to deep attributes are shared with the original&#039;);

    equals(_.clone(undefined), void 0, &#039;non objects should not be changed by clone&#039;);
    equals(_.clone(1), 1, &#039;non objects should not be changed by clone&#039;);
    equals(_.clone(null), null, &#039;non objects should not be changed by clone&#039;);
  });

  test(&quot;objects: isEqual&quot;, function() {
    function First() {
      this.value = 1;
    }
    First.prototype.value = 1;
    function Second() {
      this.value = 1;
    }
    Second.prototype.value = 2;

    // Basic equality and identity comparisons.
    ok(_.isEqual(null, null), &quot;`null` is equal to `null`&quot;);
    ok(_.isEqual(), &quot;`undefined` is equal to `undefined`&quot;);

    ok(!_.isEqual(0, -0), &quot;`0` is not equal to `-0`&quot;);
    ok(!_.isEqual(-0, 0), &quot;Commutative equality is implemented for `0` and `-0`&quot;);
    ok(!_.isEqual(null, undefined), &quot;`null` is not equal to `undefined`&quot;);
    ok(!_.isEqual(undefined, null), &quot;Commutative equality is implemented for `null` and `undefined`&quot;);

    // String object and primitive comparisons.
    ok(_.isEqual(&quot;Curly&quot;, &quot;Curly&quot;), &quot;Identical string primitives are equal&quot;);
    ok(_.isEqual(new String(&quot;Curly&quot;), new String(&quot;Curly&quot;)), &quot;String objects with identical primitive values are equal&quot;);
    ok(_.isEqual(new String(&quot;Curly&quot;), &quot;Curly&quot;), &quot;String primitives and their corresponding object wrappers are equal&quot;);
    ok(_.isEqual(&quot;Curly&quot;, new String(&quot;Curly&quot;)), &quot;Commutative equality is implemented for string objects and primitives&quot;);

    ok(!_.isEqual(&quot;Curly&quot;, &quot;Larry&quot;), &quot;String primitives with different values are not equal&quot;);
    ok(!_.isEqual(new String(&quot;Curly&quot;), new String(&quot;Larry&quot;)), &quot;String objects with different primitive values are not equal&quot;);
    ok(!_.isEqual(new String(&quot;Curly&quot;), {toString: function(){ return &quot;Curly&quot;; }}), &quot;String objects and objects with a custom `toString` method are not equal&quot;);

    // Number object and primitive comparisons.
    ok(_.isEqual(75, 75), &quot;Identical number primitives are equal&quot;);
    ok(_.isEqual(new Number(75), new Number(75)), &quot;Number objects with identical primitive values are equal&quot;);
    ok(_.isEqual(75, new Number(75)), &quot;Number primitives and their corresponding object wrappers are equal&quot;);
    ok(_.isEqual(new Number(75), 75), &quot;Commutative equality is implemented for number objects and primitives&quot;);
    ok(!_.isEqual(new Number(0), -0), &quot;`new Number(0)` and `-0` are not equal&quot;);
    ok(!_.isEqual(0, new Number(-0)), &quot;Commutative equality is implemented for `new Number(0)` and `-0`&quot;);

    ok(!_.isEqual(new Number(75), new Number(63)), &quot;Number objects with different primitive values are not equal&quot;);
    ok(!_.isEqual(new Number(63), {valueOf: function(){ return 63; }}), &quot;Number objects and objects with a `valueOf` method are not equal&quot;);

    // Comparisons involving `NaN`.
    ok(_.isEqual(NaN, NaN), &quot;`NaN` is equal to `NaN`&quot;);
    ok(!_.isEqual(61, NaN), &quot;A number primitive is not equal to `NaN`&quot;);
    ok(!_.isEqual(new Number(79), NaN), &quot;A number object is not equal to `NaN`&quot;);
    ok(!_.isEqual(Infinity, NaN), &quot;`Infinity` is not equal to `NaN`&quot;);

    // Boolean object and primitive comparisons.
    ok(_.isEqual(true, true), &quot;Identical boolean primitives are equal&quot;);
    ok(_.isEqual(new Boolean, new Boolean), &quot;Boolean objects with identical primitive values are equal&quot;);
    ok(_.isEqual(true, new Boolean(true)), &quot;Boolean primitives and their corresponding object wrappers are equal&quot;);
    ok(_.isEqual(new Boolean(true), true), &quot;Commutative equality is implemented for booleans&quot;);
    ok(!_.isEqual(new Boolean(true), new Boolean), &quot;Boolean objects with different primitive values are not equal&quot;);

    // Common type coercions.
    ok(!_.isEqual(true, new Boolean(false)), &quot;Boolean objects are not equal to the boolean primitive `true`&quot;);
    ok(!_.isEqual(&quot;75&quot;, 75), &quot;String and number primitives with like values are not equal&quot;);
    ok(!_.isEqual(new Number(63), new String(63)), &quot;String and number objects with like values are not equal&quot;);
    ok(!_.isEqual(75, &quot;75&quot;), &quot;Commutative equality is implemented for like string and number values&quot;);
    ok(!_.isEqual(0, &quot;&quot;), &quot;Number and string primitives with like values are not equal&quot;);
    ok(!_.isEqual(1, true), &quot;Number and boolean primitives with like values are not equal&quot;);
    ok(!_.isEqual(new Boolean(false), new Number(0)), &quot;Boolean and number objects with like values are not equal&quot;);
    ok(!_.isEqual(false, new String(&quot;&quot;)), &quot;Boolean primitives and string objects with like values are not equal&quot;);
    ok(!_.isEqual(12564504e5, new Date(2009, 9, 25)), &quot;Dates and their corresponding numeric primitive values are not equal&quot;);

    // Dates.
    ok(_.isEqual(new Date(2009, 9, 25), new Date(2009, 9, 25)), &quot;Date objects referencing identical times are equal&quot;);
    ok(!_.isEqual(new Date(2009, 9, 25), new Date(2009, 11, 13)), &quot;Date objects referencing different times are not equal&quot;);
    ok(!_.isEqual(new Date(2009, 11, 13), {
      getTime: function(){
        return 12606876e5;
      }
    }), &quot;Date objects and objects with a `getTime` method are not equal&quot;);
    ok(!_.isEqual(new Date(&quot;Curly&quot;), new Date(&quot;Curly&quot;)), &quot;Invalid dates are not equal&quot;);

    // Functions.
    ok(!_.isEqual(First, Second), &quot;Different functions with identical bodies and source code representations are not equal&quot;);

    // RegExps.
    ok(_.isEqual(/(?:)/gim, /(?:)/gim), &quot;RegExps with equivalent patterns and flags are equal&quot;);
    ok(!_.isEqual(/(?:)/g, /(?:)/gi), &quot;RegExps with equivalent patterns and different flags are not equal&quot;);
    ok(!_.isEqual(/Moe/gim, /Curly/gim), &quot;RegExps with different patterns and equivalent flags are not equal&quot;);
    ok(!_.isEqual(/(?:)/gi, /(?:)/g), &quot;Commutative equality is implemented for RegExps&quot;);
    ok(!_.isEqual(/Curly/g, {source: &quot;Larry&quot;, global: true, ignoreCase: false, multiline: false}), &quot;RegExps and RegExp-like objects are not equal&quot;);

    // Empty arrays, array-like objects, and object literals.
    ok(_.isEqual({}, {}), &quot;Empty object literals are equal&quot;);
    ok(_.isEqual([], []), &quot;Empty array literals are equal&quot;);
    ok(_.isEqual([{}], [{}]), &quot;Empty nested arrays and objects are equal&quot;);
    ok(!_.isEqual({length: 0}, []), &quot;Array-like objects and arrays are not equal.&quot;);
    ok(!_.isEqual([], {length: 0}), &quot;Commutative equality is implemented for array-like objects&quot;);

    ok(!_.isEqual({}, []), &quot;Object literals and array literals are not equal&quot;);
    ok(!_.isEqual([], {}), &quot;Commutative equality is implemented for objects and arrays&quot;);

    // Arrays with primitive and object values.
    ok(_.isEqual([1, &quot;Larry&quot;, true], [1, &quot;Larry&quot;, true]), &quot;Arrays containing identical primitives are equal&quot;);
    ok(_.isEqual([/Moe/g, new Date(2009, 9, 25)], [/Moe/g, new Date(2009, 9, 25)]), &quot;Arrays containing equivalent elements are equal&quot;);

    // Multi-dimensional arrays.
    var a = [new Number(47), false, &quot;Larry&quot;, /Moe/, new Date(2009, 11, 13), [&#039;running&#039;, &#039;biking&#039;, new String(&#039;programming&#039;)], {a: 47}];
    var b = [new Number(47), false, &quot;Larry&quot;, /Moe/, new Date(2009, 11, 13), [&#039;running&#039;, &#039;biking&#039;, new String(&#039;programming&#039;)], {a: 47}];
    ok(_.isEqual(a, b), &quot;Arrays containing nested arrays and objects are recursively compared&quot;);

    // Overwrite the methods defined in ES 5.1 section 15.4.4.
    a.forEach = a.map = a.filter = a.every = a.indexOf = a.lastIndexOf = a.some = a.reduce = a.reduceRight = null;
    b.join = b.pop = b.reverse = b.shift = b.slice = b.splice = b.concat = b.sort = b.unshift = null;

    // Array elements and properties.
    ok(_.isEqual(a, b), &quot;Arrays containing equivalent elements and different non-numeric properties are equal&quot;);
    a.push(&quot;White Rocks&quot;);
    ok(!_.isEqual(a, b), &quot;Arrays of different lengths are not equal&quot;);
    a.push(&quot;East Boulder&quot;);
    b.push(&quot;Gunbarrel Ranch&quot;, &quot;Teller Farm&quot;);
    ok(!_.isEqual(a, b), &quot;Arrays of identical lengths containing different elements are not equal&quot;);

    // Sparse arrays.
    ok(_.isEqual(Array(3), Array(3)), &quot;Sparse arrays of identical lengths are equal&quot;);
    ok(!_.isEqual(Array(3), Array(6)), &quot;Sparse arrays of different lengths are not equal when both are empty&quot;);

    // According to the Microsoft deviations spec, section 2.1.26, JScript 5.x treats `undefined`
    // elements in arrays as elisions. Thus, sparse arrays and dense arrays containing `undefined`
    // values are equivalent.
    if (0 in [undefined]) {
      ok(!_.isEqual(Array(3), [undefined, undefined, undefined]), &quot;Sparse and dense arrays are not equal&quot;);
      ok(!_.isEqual([undefined, undefined, undefined], Array(3)), &quot;Commutative equality is implemented for sparse and dense arrays&quot;);
    }

    // Simple objects.
    ok(_.isEqual({a: &quot;Curly&quot;, b: 1, c: true}, {a: &quot;Curly&quot;, b: 1, c: true}), &quot;Objects containing identical primitives are equal&quot;);
    ok(_.isEqual({a: /Curly/g, b: new Date(2009, 11, 13)}, {a: /Curly/g, b: new Date(2009, 11, 13)}), &quot;Objects containing equivalent members are equal&quot;);
    ok(!_.isEqual({a: 63, b: 75}, {a: 61, b: 55}), &quot;Objects of identical sizes with different values are not equal&quot;);
    ok(!_.isEqual({a: 63, b: 75}, {a: 61, c: 55}), &quot;Objects of identical sizes with different property names are not equal&quot;);
    ok(!_.isEqual({a: 1, b: 2}, {a: 1}), &quot;Objects of different sizes are not equal&quot;);
    ok(!_.isEqual({a: 1}, {a: 1, b: 2}), &quot;Commutative equality is implemented for objects&quot;);
    ok(!_.isEqual({x: 1, y: undefined}, {x: 1, z: 2}), &quot;Objects with identical keys and different values are not equivalent&quot;);

    // `A` contains nested objects and arrays.
    a = {
      name: new String(&quot;Moe Howard&quot;),
      age: new Number(77),
      stooge: true,
      hobbies: [&quot;acting&quot;],
      film: {
        name: &quot;Sing a Song of Six Pants&quot;,
        release: new Date(1947, 9, 30),
        stars: [new String(&quot;Larry Fine&quot;), &quot;Shemp Howard&quot;],
        minutes: new Number(16),
        seconds: 54
      }
    };

    // `B` contains equivalent nested objects and arrays.
    b = {
      name: new String(&quot;Moe Howard&quot;),
      age: new Number(77),
      stooge: true,
      hobbies: [&quot;acting&quot;],
      film: {
        name: &quot;Sing a Song of Six Pants&quot;,
        release: new Date(1947, 9, 30),
        stars: [new String(&quot;Larry Fine&quot;), &quot;Shemp Howard&quot;],
        minutes: new Number(16),
        seconds: 54
      }
    };
    ok(_.isEqual(a, b), &quot;Objects with nested equivalent members are recursively compared&quot;);

    // Instances.
    ok(_.isEqual(new First, new First), &quot;Object instances are equal&quot;);
    ok(!_.isEqual(new First, new Second), &quot;Objects with different constructors and identical own properties are not equal&quot;);
    ok(!_.isEqual({value: 1}, new First), &quot;Object instances and objects sharing equivalent properties are not equal&quot;);
    ok(!_.isEqual({value: 2}, new Second), &quot;The prototype chain of objects should not be examined&quot;);

    // Circular Arrays.
    (a = []).push(a);
    (b = []).push(b);
    ok(_.isEqual(a, b), &quot;Arrays containing circular references are equal&quot;);
    a.push(new String(&quot;Larry&quot;));
    b.push(new String(&quot;Larry&quot;));
    ok(_.isEqual(a, b), &quot;Arrays containing circular references and equivalent properties are equal&quot;);
    a.push(&quot;Shemp&quot;);
    b.push(&quot;Curly&quot;);
    ok(!_.isEqual(a, b), &quot;Arrays containing circular references and different properties are not equal&quot;);

    // Circular Objects.
    a = {abc: null};
    b = {abc: null};
    a.abc = a;
    b.abc = b;
    ok(_.isEqual(a, b), &quot;Objects containing circular references are equal&quot;);
    a.def = 75;
    b.def = 75;
    ok(_.isEqual(a, b), &quot;Objects containing circular references and equivalent properties are equal&quot;);
    a.def = new Number(75);
    b.def = new Number(63);
    ok(!_.isEqual(a, b), &quot;Objects containing circular references and different properties are not equal&quot;);

    // Cyclic Structures.
    a = [{abc: null}];
    b = [{abc: null}];
    (a[0].abc = a).push(a);
    (b[0].abc = b).push(b);
    ok(_.isEqual(a, b), &quot;Cyclic structures are equal&quot;);
    a[0].def = &quot;Larry&quot;;
    b[0].def = &quot;Larry&quot;;
    ok(_.isEqual(a, b), &quot;Cyclic structures containing equivalent properties are equal&quot;);
    a[0].def = new String(&quot;Larry&quot;);
    b[0].def = new String(&quot;Curly&quot;);
    ok(!_.isEqual(a, b), &quot;Cyclic structures containing different properties are not equal&quot;);

    // Complex Circular References.
    a = {foo: {b: {foo: {c: {foo: null}}}}};
    b = {foo: {b: {foo: {c: {foo: null}}}}};
    a.foo.b.foo.c.foo = a;
    b.foo.b.foo.c.foo = b;
    ok(_.isEqual(a, b), &quot;Cyclic structures with nested and identically-named properties are equal&quot;);

    // Chaining.
    ok(!_.isEqual(_({x: 1, y: undefined}).chain(), _({x: 1, z: 2}).chain()), &#039;Chained objects containing different values are not equal&#039;);
    equals(_({x: 1, y: 2}).chain().isEqual(_({x: 1, y: 2}).chain()).value(), true, &#039;`isEqual` can be chained&#039;);

    // Custom `isEqual` methods.
    var isEqualObj = {isEqual: function (o) { return o.isEqual == this.isEqual; }, unique: {}};
    var isEqualObjClone = {isEqual: isEqualObj.isEqual, unique: {}};

    ok(_.isEqual(isEqualObj, isEqualObjClone), &#039;Both objects implement identical `isEqual` methods&#039;);
    ok(_.isEqual(isEqualObjClone, isEqualObj), &#039;Commutative equality is implemented for objects with custom `isEqual` methods&#039;);
    ok(!_.isEqual(isEqualObj, {}), &#039;Objects that do not implement equivalent `isEqual` methods are not equal&#039;);
    ok(!_.isEqual({}, isEqualObj), &#039;Commutative equality is implemented for objects with different `isEqual` methods&#039;);

    // Custom `isEqual` methods - comparing different types
    LocalizedString = (function() {
      function LocalizedString(id) { this.id = id; this.string = (this.id===10)? &#039;Bonjour&#039;: &#039;&#039;; }
      LocalizedString.prototype.isEqual = function(that) {
        if (_.isString(that)) return this.string == that;
        else if (that instanceof LocalizedString) return this.id == that.id;
        return false;
      };
      return LocalizedString;
    })();
    var localized_string1 = new LocalizedString(10), localized_string2 = new LocalizedString(10), localized_string3 = new LocalizedString(11);
    ok(_.isEqual(localized_string1, localized_string2), &#039;comparing same typed instances with same ids&#039;);
    ok(!_.isEqual(localized_string1, localized_string3), &#039;comparing same typed instances with different ids&#039;);
    ok(_.isEqual(localized_string1, &#039;Bonjour&#039;), &#039;comparing different typed instances with same values&#039;);
    ok(_.isEqual(&#039;Bonjour&#039;, localized_string1), &#039;comparing different typed instances with same values&#039;);
    ok(!_.isEqual(&#039;Bonjour&#039;, localized_string3), &#039;comparing two localized strings with different ids&#039;);
    ok(!_.isEqual(localized_string1, &#039;Au revoir&#039;), &#039;comparing different typed instances with different values&#039;);
    ok(!_.isEqual(&#039;Au revoir&#039;, localized_string1), &#039;comparing different typed instances with different values&#039;);

    // Custom `isEqual` methods - comparing with serialized data
    Date.prototype.toJSON = function() {
      return {
        _type:&#039;Date&#039;,
        year:this.getUTCFullYear(),
        month:this.getUTCMonth(),
        day:this.getUTCDate(),
        hours:this.getUTCHours(),
        minutes:this.getUTCMinutes(),
        seconds:this.getUTCSeconds()
      };
    };
    Date.prototype.isEqual = function(that) {
      var this_date_components = this.toJSON();
      var that_date_components = (that instanceof Date) ? that.toJSON() : that;
      delete this_date_components[&#039;_type&#039;]; delete that_date_components[&#039;_type&#039;]
      return _.isEqual(this_date_components, that_date_components);
    };

    var date = new Date();
    var date_json = {
      _type:&#039;Date&#039;,
      year:date.getUTCFullYear(),
      month:date.getUTCMonth(),
      day:date.getUTCDate(),
      hours:date.getUTCHours(),
      minutes:date.getUTCMinutes(),
      seconds:date.getUTCSeconds()
    };

    ok(_.isEqual(date_json, date), &#039;serialized date matches date&#039;);
    ok(_.isEqual(date, date_json), &#039;date matches serialized date&#039;);
  });

  test(&quot;objects: isEmpty&quot;, function() {
    ok(!_([1]).isEmpty(), &#039;[1] is not empty&#039;);
    ok(_.isEmpty([]), &#039;[] is empty&#039;);
    ok(!_.isEmpty({one : 1}), &#039;{one : 1} is not empty&#039;);
    ok(_.isEmpty({}), &#039;{} is empty&#039;);
    ok(_.isEmpty(new RegExp(&#039;&#039;)), &#039;objects with prototype properties are empty&#039;);
    ok(_.isEmpty(null), &#039;null is empty&#039;);
    ok(_.isEmpty(), &#039;undefined is empty&#039;);
    ok(_.isEmpty(&#039;&#039;), &#039;the empty string is empty&#039;);
    ok(!_.isEmpty(&#039;moe&#039;), &#039;but other strings are not&#039;);

    var obj = {one : 1};
    delete obj.one;
    ok(_.isEmpty(obj), &#039;deleting all the keys from an object empties it&#039;);
  });

  // Setup remote variables for iFrame tests.
  var iframe = document.createElement(&#039;iframe&#039;);
  jQuery(iframe).appendTo(document.body);
  var iDoc = iframe.contentDocument || iframe.contentWindow.document;
  iDoc.write(
    &quot;&lt;script&gt;\
      parent.iElement   = document.createElement(&#039;div&#039;);\
      parent.iArguments = (function(){ return arguments; })(1, 2, 3);\
      parent.iArray     = [1, 2, 3];\
      parent.iString    = new String(&#039;hello&#039;);\
      parent.iNumber    = new Number(100);\
      parent.iFunction  = (function(){});\
      parent.iDate      = new Date();\
      parent.iRegExp    = /hi/;\
      parent.iNaN       = NaN;\
      parent.iNull      = null;\
      parent.iBoolean   = new Boolean(false);\
      parent.iUndefined = undefined;\
    &lt;/script&gt;&quot;
  );
  iDoc.close();

  test(&quot;objects: isElement&quot;, function() {
    ok(!_.isElement(&#039;div&#039;), &#039;strings are not dom elements&#039;);
    ok(_.isElement($(&#039;html&#039;)[0]), &#039;the html tag is a DOM element&#039;);
    ok(_.isElement(iElement), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isArguments&quot;, function() {
    var args = (function(){ return arguments; })(1, 2, 3);
    ok(!_.isArguments(&#039;string&#039;), &#039;a string is not an arguments object&#039;);
    ok(!_.isArguments(_.isArguments), &#039;a function is not an arguments object&#039;);
    ok(_.isArguments(args), &#039;but the arguments object is an arguments object&#039;);
    ok(!_.isArguments(_.toArray(args)), &#039;but not when it\&#039;s converted into an array&#039;);
    ok(!_.isArguments([1,2,3]), &#039;and not vanilla arrays.&#039;);
    ok(_.isArguments(iArguments), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isObject&quot;, function() {
    ok(_.isObject(arguments), &#039;the arguments object is object&#039;);
    ok(_.isObject([1, 2, 3]), &#039;and arrays&#039;);
    ok(_.isObject($(&#039;html&#039;)[0]), &#039;and DOM element&#039;);
    ok(_.isObject(iElement), &#039;even from another frame&#039;);
    ok(_.isObject(function () {}), &#039;and functions&#039;);
    ok(_.isObject(iFunction), &#039;even from another frame&#039;);
    ok(!_.isObject(null), &#039;but not null&#039;);
    ok(!_.isObject(undefined), &#039;and not undefined&#039;);
    ok(!_.isObject(&#039;string&#039;), &#039;and not string&#039;);
    ok(!_.isObject(12), &#039;and not number&#039;);
    ok(!_.isObject(true), &#039;and not boolean&#039;);
    ok(_.isObject(new String(&#039;string&#039;)), &#039;but new String()&#039;);
  });

  test(&quot;objects: isArray&quot;, function() {
    ok(!_.isArray(arguments), &#039;the arguments object is not an array&#039;);
    ok(_.isArray([1, 2, 3]), &#039;but arrays are&#039;);
    ok(_.isArray(iArray), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isString&quot;, function() {
    ok(!_.isString(document.body), &#039;the document body is not a string&#039;);
    ok(_.isString([1, 2, 3].join(&#039;, &#039;)), &#039;but strings are&#039;);
    ok(_.isString(iString), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isNumber&quot;, function() {
    ok(!_.isNumber(&#039;string&#039;), &#039;a string is not a number&#039;);
    ok(!_.isNumber(arguments), &#039;the arguments object is not a number&#039;);
    ok(!_.isNumber(undefined), &#039;undefined is not a number&#039;);
    ok(_.isNumber(3 * 4 - 7 / 10), &#039;but numbers are&#039;);
    ok(_.isNumber(NaN), &#039;NaN *is* a number&#039;);
    ok(_.isNumber(Infinity), &#039;Infinity is a number&#039;);
    ok(_.isNumber(iNumber), &#039;even from another frame&#039;);
    ok(!_.isNumber(&#039;1&#039;), &#039;numeric strings are not numbers&#039;);
  });

  test(&quot;objects: isBoolean&quot;, function() {
    ok(!_.isBoolean(2), &#039;a number is not a boolean&#039;);
    ok(!_.isBoolean(&quot;string&quot;), &#039;a string is not a boolean&#039;);
    ok(!_.isBoolean(&quot;false&quot;), &#039;the string &quot;false&quot; is not a boolean&#039;);
    ok(!_.isBoolean(&quot;true&quot;), &#039;the string &quot;true&quot; is not a boolean&#039;);
    ok(!_.isBoolean(arguments), &#039;the arguments object is not a boolean&#039;);
    ok(!_.isBoolean(undefined), &#039;undefined is not a boolean&#039;);
    ok(!_.isBoolean(NaN), &#039;NaN is not a boolean&#039;);
    ok(!_.isBoolean(null), &#039;null is not a boolean&#039;);
    ok(_.isBoolean(true), &#039;but true is&#039;);
    ok(_.isBoolean(false), &#039;and so is false&#039;);
    ok(_.isBoolean(iBoolean), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isFunction&quot;, function() {
    ok(!_.isFunction([1, 2, 3]), &#039;arrays are not functions&#039;);
    ok(!_.isFunction(&#039;moe&#039;), &#039;strings are not functions&#039;);
    ok(_.isFunction(_.isFunction), &#039;but functions are&#039;);
    ok(_.isFunction(iFunction), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isDate&quot;, function() {
    ok(!_.isDate(100), &#039;numbers are not dates&#039;);
    ok(!_.isDate({}), &#039;objects are not dates&#039;);
    ok(_.isDate(new Date()), &#039;but dates are&#039;);
    ok(_.isDate(iDate), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isRegExp&quot;, function() {
    ok(!_.isRegExp(_.identity), &#039;functions are not RegExps&#039;);
    ok(_.isRegExp(/identity/), &#039;but RegExps are&#039;);
    ok(_.isRegExp(iRegExp), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isNaN&quot;, function() {
    ok(!_.isNaN(undefined), &#039;undefined is not NaN&#039;);
    ok(!_.isNaN(null), &#039;null is not NaN&#039;);
    ok(!_.isNaN(0), &#039;0 is not NaN&#039;);
    ok(_.isNaN(NaN), &#039;but NaN is&#039;);
    ok(_.isNaN(iNaN), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isNull&quot;, function() {
    ok(!_.isNull(undefined), &#039;undefined is not null&#039;);
    ok(!_.isNull(NaN), &#039;NaN is not null&#039;);
    ok(_.isNull(null), &#039;but null is&#039;);
    ok(_.isNull(iNull), &#039;even from another frame&#039;);
  });

  test(&quot;objects: isUndefined&quot;, function() {
    ok(!_.isUndefined(1), &#039;numbers are defined&#039;);
    ok(!_.isUndefined(null), &#039;null is defined&#039;);
    ok(!_.isUndefined(false), &#039;false is defined&#039;);
    ok(!_.isUndefined(NaN), &#039;NaN is defined&#039;);
    ok(_.isUndefined(), &#039;nothing is undefined&#039;);
    ok(_.isUndefined(undefined), &#039;undefined is undefined&#039;);
    ok(_.isUndefined(iUndefined), &#039;even from another frame&#039;);
  });

  if (window.ActiveXObject) {
    test(&quot;objects: IE host objects&quot;, function() {
      var xml = new ActiveXObject(&quot;Msxml2.DOMDocument.3.0&quot;);
      ok(!_.isNumber(xml));
      ok(!_.isBoolean(xml));
      ok(!_.isNaN(xml));
      ok(!_.isFunction(xml));
      ok(!_.isNull(xml));
      ok(!_.isUndefined(xml));
    });
  }

  test(&quot;objects: tap&quot;, function() {
    var intercepted = null;
    var interceptor = function(obj) { intercepted = obj; };
    var returned = _.tap(1, interceptor);
    equals(intercepted, 1, &quot;passes tapped object to interceptor&quot;);
    equals(returned, 1, &quot;returns tapped object&quot;);

    returned = _([1,2,3]).chain().
      map(function(n){ return n * 2; }).
      max().
      tap(interceptor).
      value();
    ok(returned == 6 &amp;&amp; intercepted == 6, &#039;can use tapped objects in a chain&#039;);
  });
});</textarea>
  </div>
</div>

<footer class="footer">
  <div class="container">
    <p>.</p>
  </div>
</footer>

<script type="text/html" id="complexity-popover-template">
  <div class="complexity-notice">
    Complexity : {{ complexity.cyclomatic }} <br>
    Length : {{ complexity.halstead.length }} <br>
    Difficulty : {{ complexity.halstead.difficulty.toFixed(2) }} <br>
    Est # bugs : {{ complexity.halstead.bugs.toFixed(2) }}<br>
  </div>
</script>

<script type="text/javascript" src="../../assets/scripts/bundles/core-bundle.js"></script>
<script type="text/javascript" src="../../assets/scripts/bundles/codemirror.js"></script>
<script type="text/javascript" src="../../assets/scripts/codemirror.markpopovertext.js"></script>
<script type="text/javascript" src="report.js"></script>
<script type="text/javascript" src="report.history.js"></script>
<script type="text/javascript" src="../../assets/scripts/plato-file.js"></script>
</body>
</html>
